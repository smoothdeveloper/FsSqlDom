module FsSqlDom.Dom
open System
open Microsoft.SqlServer.TransactSql

#nowarn "25"   // Turn off bogus missing pattern match cases warning
#nowarn "1182" // Turn off unused variables warning

type TSqlFragment = (* IsAbstract = true , children = 212*)
  | AdHocDataSource of initString:StringLiteral option * providerName:StringLiteral option
  | AddFileSpec of file:ScalarExpression option * fileName:Literal option
  | AlterAvailabilityGroupAction of alterAvailabilityGroupAction:AlterAvailabilityGroupAction
  | AlterAvailabilityGroupFailoverOption of optionKind:ScriptDom.FailoverActionOptionKind * value:Literal option
  | AlterDatabaseTermination of immediateRollback:bool * noWait:bool * rollbackAfter:Literal option
  | AlterFullTextIndexAction of alterFullTextIndexAction:AlterFullTextIndexAction
  | AlterRoleAction of alterRoleAction:AlterRoleAction
  | AlterServerConfigurationBufferPoolExtensionOption of alterServerConfigurationBufferPoolExtensionOption:AlterServerConfigurationBufferPoolExtensionOption
  | AlterServerConfigurationDiagnosticsLogOption of alterServerConfigurationDiagnosticsLogOption:AlterServerConfigurationDiagnosticsLogOption
  | AlterServerConfigurationFailoverClusterPropertyOption of optionKind:ScriptDom.AlterServerConfigurationFailoverClusterPropertyOptionKind * optionValue:OptionValue option
  | AlterServerConfigurationHadrClusterOption of isLocal:bool * optionKind:ScriptDom.AlterServerConfigurationHadrClusterOptionKind * optionValue:OptionValue option
  | AlterServerConfigurationSoftNumaOption of optionKind:ScriptDom.AlterServerConfigurationSoftNumaOptionKind * optionValue:OptionValue option
  | AlterTableDropTableElement of dropClusteredConstraintOptions:(DropClusteredConstraintOption) list * isIfExists:bool * name:Identifier option * tableElementType:ScriptDom.TableElementType
  | ApplicationRoleOption of optionKind:ScriptDom.ApplicationRoleOptionKind * value:IdentifierOrValueExpression option
  | AssemblyName of className:Identifier option * name:Identifier option
  | AssemblyOption of assemblyOption:AssemblyOption
  | AtomicBlockOption of atomicBlockOption:AtomicBlockOption
  | AuditOption of auditOption:AuditOption
  | AuditSpecificationDetail of auditSpecificationDetail:AuditSpecificationDetail
  | AuditSpecificationPart of details:AuditSpecificationDetail option * isDrop:bool
  | AuditTarget of targetKind:ScriptDom.AuditTargetKind * targetOptions:(AuditTargetOption) list
  | AuditTargetOption of auditTargetOption:AuditTargetOption
  | AutomaticTuningOption of automaticTuningOption:AutomaticTuningOption
  | AvailabilityGroupOption of availabilityGroupOption:AvailabilityGroupOption
  | AvailabilityReplica of options:(AvailabilityReplicaOption) list * serverName:StringLiteral option
  | AvailabilityReplicaOption of availabilityReplicaOption:AvailabilityReplicaOption
  | BackupOption of backupOption:BackupOption
  | BackupRestoreFileInfo of itemKind:ScriptDom.BackupRestoreItemKind * items:(ValueExpression) list
  | BooleanExpression of booleanExpression:BooleanExpression
  | BoundingBoxParameter of parameter:ScriptDom.BoundingBoxParameterType * value:ScalarExpression option
  | BrokerPriorityParameter of isDefaultOrAny:ScriptDom.BrokerPriorityParameterSpecialType * parameterType:ScriptDom.BrokerPriorityParameterType * parameterValue:IdentifierOrValueExpression option
  | BulkInsertOption of bulkInsertOption:BulkInsertOption
  | CallTarget of callTarget:CallTarget
  | CertificateOption of kind:ScriptDom.CertificateOptionKinds * value:Literal option
  | ChangeTrackingOptionDetail of changeTrackingOptionDetail:ChangeTrackingOptionDetail
  | ColumnDefinitionBase of columnDefinitionBase:ColumnDefinitionBase
  | ColumnEncryptionDefinition of parameters:(ColumnEncryptionDefinitionParameter) list
  | ColumnEncryptionDefinitionParameter of columnEncryptionDefinitionParameter:ColumnEncryptionDefinitionParameter
  | ColumnEncryptionKeyValue of parameters:(ColumnEncryptionKeyValueParameter) list
  | ColumnEncryptionKeyValueParameter of columnEncryptionKeyValueParameter:ColumnEncryptionKeyValueParameter
  | ColumnMasterKeyParameter of columnMasterKeyParameter:ColumnMasterKeyParameter
  | ColumnStorageOptions of isFileStream:bool * sparseOption:ScriptDom.SparseColumnOption
  | ColumnWithSortOrder of column:ColumnReferenceExpression option * sortOrder:ScriptDom.SortOrder
  | CommonTableExpression of columns:(Identifier) list * expressionName:Identifier option * queryExpression:QueryExpression option
  | CompressionPartitionRange of from:ScalarExpression option * to_:ScalarExpression option
  | ComputeClause of byExpressions:(ScalarExpression) list * computeFunctions:(ComputeFunction) list
  | ComputeFunction of computeFunctionType:ScriptDom.ComputeFunctionType * expression:ScalarExpression option
  | ConstraintDefinition of constraintDefinition:ConstraintDefinition
  | ContractMessage of name:Identifier option * sentBy:ScriptDom.MessageSender
  | CreateLoginSource of createLoginSource:CreateLoginSource
  | CryptoMechanism of cryptoMechanismType:ScriptDom.CryptoMechanismType * identifier:Identifier option * passwordOrSignature:Literal option
  | CursorDefinition of options:(CursorOption) list * select:SelectStatement option
  | CursorId of isGlobal:bool * name:IdentifierOrValueExpression option
  | CursorOption of optionKind:ScriptDom.CursorOptionKind
  | DataModificationSpecification of dataModificationSpecification:DataModificationSpecification
  | DataTypeReference of dataTypeReference:DataTypeReference
  | DatabaseAuditAction of actionKind:ScriptDom.DatabaseAuditActionKind
  | DatabaseConfigurationClearOption of optionKind:ScriptDom.DatabaseConfigClearOptionKind * planHandle:BinaryLiteral option
  | DatabaseConfigurationSetOption of databaseConfigurationSetOption:DatabaseConfigurationSetOption
  | DatabaseOption of databaseOption:DatabaseOption
  | DbccNamedLiteral of name:String * value:ScalarExpression option
  | DbccOption of optionKind:ScriptDom.DbccOptionKind
  | DeclareTableVariableBody of asDefined:bool * definition:TableDefinition option * variableName:Identifier option
  | DeclareVariableElement of declareVariableElement:DeclareVariableElement
  | DeviceInfo of deviceType:ScriptDom.DeviceType * logicalDevice:IdentifierOrValueExpression option * physicalDevice:ValueExpression option
  | DialogOption of dialogOption:DialogOption
  | DiskStatementOption of optionKind:ScriptDom.DiskStatementOptionKind * value:IdentifierOrValueExpression option
  | DropClusteredConstraintOption of dropClusteredConstraintOption:DropClusteredConstraintOption
  | DropIndexClauseBase of dropIndexClauseBase:DropIndexClauseBase
  | EncryptionSource of encryptionSource:EncryptionSource
  | EndpointAffinity of kind:ScriptDom.AffinityKind * value:Literal option
  | EndpointProtocolOption of endpointProtocolOption:EndpointProtocolOption
  | EventDeclaration of eventDeclarationActionParameters:(EventSessionObjectName) list * eventDeclarationPredicateParameter:BooleanExpression option * eventDeclarationSetParameters:(EventDeclarationSetParameter) list * objectName:EventSessionObjectName option
  | EventDeclarationSetParameter of eventField:Identifier option * eventValue:ScalarExpression option
  | EventNotificationObjectScope of queueName:SchemaObjectName option * target:ScriptDom.EventNotificationTarget
  | EventSessionObjectName of multiPartIdentifier:MultiPartIdentifier option
  | EventTypeGroupContainer of eventTypeGroupContainer:EventTypeGroupContainer
  | ExecutableEntity of executableEntity:ExecutableEntity
  | ExecuteAsClause of executeAsOption:ScriptDom.ExecuteAsOption * literal:Literal option
  | ExecuteContext of kind:ScriptDom.ExecuteAsOption * principal:ScalarExpression option
  | ExecuteOption of executeOption:ExecuteOption
  | ExecuteParameter of isOutput:bool * parameterValue:ScalarExpression option * variable:VariableReference option
  | ExecuteSpecification of executableEntity:ExecutableEntity option * executeContext:ExecuteContext option * linkedServer:Identifier option * variable:VariableReference option
  | ExpressionWithSortOrder of expression:ScalarExpression option * sortOrder:ScriptDom.SortOrder
  | ExternalDataSourceOption of externalDataSourceOption:ExternalDataSourceOption
  | ExternalFileFormatOption of externalFileFormatOption:ExternalFileFormatOption
  | ExternalResourcePoolAffinitySpecification of affinityType:ScriptDom.ExternalResourcePoolAffinityType * isAuto:bool * parameterValue:Literal option * poolAffinityRanges:(LiteralRange) list
  | ExternalResourcePoolParameter of affinitySpecification:ExternalResourcePoolAffinitySpecification option * parameterType:ScriptDom.ExternalResourcePoolParameterType * parameterValue:Literal option
  | ExternalTableColumnDefinition of columnDefinition:ColumnDefinitionBase option * nullableConstraint:NullableConstraintDefinition option
  | ExternalTableDistributionPolicy of externalTableDistributionPolicy:ExternalTableDistributionPolicy
  | ExternalTableOption of externalTableOption:ExternalTableOption
  | FederationScheme of columnName:Identifier option * distributionName:Identifier option
  | FetchType of orientation:ScriptDom.FetchOrientation * rowOffset:ScalarExpression option
  | FileDeclaration of isPrimary:bool * options:(FileDeclarationOption) list
  | FileDeclarationOption of fileDeclarationOption:FileDeclarationOption
  | FileGroupDefinition of containsFileStream:bool * containsMemoryOptimizedData:bool * fileDeclarations:(FileDeclaration) list * isDefault:bool * name:Identifier option
  | FileGroupOrPartitionScheme of name:IdentifierOrValueExpression option * partitionSchemeColumns:(Identifier) list
  | ForClause of forClause:ForClause
  | FromClause of tableReferences:(TableReference) list
  | FullTextCatalogAndFileGroup of catalogName:Identifier option * fileGroupIsFirst:bool * fileGroupName:Identifier option
  | FullTextCatalogOption of fullTextCatalogOption:FullTextCatalogOption
  | FullTextIndexColumn of languageTerm:IdentifierOrValueExpression option * name:Identifier option * statisticalSemantics:bool * typeColumn:Identifier option
  | FullTextIndexOption of fullTextIndexOption:FullTextIndexOption
  | FullTextStopListAction of isAdd:bool * isAll:bool * languageTerm:IdentifierOrValueExpression option * stopWord:Literal option
  | FunctionOption of functionOption:FunctionOption
  | FunctionReturnType of functionReturnType:FunctionReturnType
  | GraphConnectionBetweenNodes of fromNode:SchemaObjectName option * toNode:SchemaObjectName option
  | GridParameter of parameter:ScriptDom.GridParameterType * value:ScriptDom.ImportanceParameterType
  | GroupByClause of all:bool * groupByOption:ScriptDom.GroupByOption * groupingSpecifications:(GroupingSpecification) list
  | GroupingSpecification of groupingSpecification:GroupingSpecification
  | HavingClause of searchCondition:BooleanExpression option
  | IPv4 of octetFour:Literal option * octetOne:Literal option * octetThree:Literal option * octetTwo:Literal option
  | Identifier of identifier:Identifier
  | IdentifierOrScalarExpression of identifier:Identifier option * scalarExpression:ScalarExpression option
  | IdentifierOrValueExpression of identifier:Identifier option * value:String * valueExpression:ValueExpression option
  | IdentityOptions of identityIncrement:ScalarExpression option * identitySeed:ScalarExpression option * isIdentityNotForReplication:bool
  | IndexOption of indexOption:IndexOption
  | IndexType of indexTypeKind:(ScriptDom.IndexTypeKind) option
  | InsertBulkColumnDefinition of column:ColumnDefinitionBase option * nullNotNull:ScriptDom.NullNotNull
  | InsertSource of insertSource:InsertSource
  | KeyOption of keyOption:KeyOption
  | LiteralRange of literalRange:LiteralRange
  | LowPriorityLockWaitOption of lowPriorityLockWaitOption:LowPriorityLockWaitOption
  | MergeAction of mergeAction:MergeAction
  | MergeActionClause of action:MergeAction option * condition:ScriptDom.MergeCondition * searchCondition:BooleanExpression option
  | MethodSpecifier of assemblyName:Identifier option * className:Identifier option * methodName:Identifier option
  | MirrorToClause of devices:(DeviceInfo) list
  | MultiPartIdentifier of multiPartIdentifier:MultiPartIdentifier
  | OffsetClause of fetchExpression:ScalarExpression option * offsetExpression:ScalarExpression option
  | OnlineIndexLowPriorityLockWaitOption of options:(LowPriorityLockWaitOption) list
  | OptimizerHint of optimizerHint:OptimizerHint
  | OptionValue of optionValue:OptionValue
  | OrderByClause of orderByElements:(ExpressionWithSortOrder) list
  | OutputClause of selectColumns:(SelectElement) list
  | OutputIntoClause of intoTable:TableReference option * intoTableColumns:(ColumnReferenceExpression) list * selectColumns:(SelectElement) list
  | OverClause of orderByClause:OrderByClause option * partitions:(ScalarExpression) list * windowFrameClause:WindowFrameClause option
  | PartitionParameterType of collation:Identifier option * dataType:DataTypeReference option
  | PartitionSpecifications of partitionSpecifications:PartitionSpecifications
  | PartitionSpecifier of all:bool * number:ScalarExpression option
  | PayloadOption of payloadOption:PayloadOption
  | Permission of columns:(Identifier) list * identifiers:(Identifier) list
  | PrincipalOption of principalOption:PrincipalOption
  | Privilege80 of columns:(Identifier) list * privilegeType80:ScriptDom.PrivilegeType80
  | ProcedureOption of procedureOption:ProcedureOption
  | ProcedureReference of name:SchemaObjectName option * number:Literal option
  | ProcedureReferenceName of procedureReference:ProcedureReference option * procedureVariable:VariableReference option
  | QueryExpression of queryExpression:QueryExpression
  | QueryStoreOption of queryStoreOption:QueryStoreOption
  | QueueOption of queueOption:QueueOption
  | RemoteDataArchiveDatabaseSetting of remoteDataArchiveDatabaseSetting:RemoteDataArchiveDatabaseSetting
  | RemoteServiceBindingOption of remoteServiceBindingOption:RemoteServiceBindingOption
  | ResourcePoolAffinitySpecification of affinityType:ScriptDom.ResourcePoolAffinityType * isAuto:bool * parameterValue:Literal option * poolAffinityRanges:(LiteralRange) list
  | ResourcePoolParameter of affinitySpecification:ResourcePoolAffinitySpecification option * parameterType:ScriptDom.ResourcePoolParameterType * parameterValue:Literal option
  | RestoreOption of restoreOption:RestoreOption
  | ResultColumnDefinition of columnDefinition:ColumnDefinitionBase option * nullable:NullableConstraintDefinition option
  | ResultSetDefinition of resultSetDefinition:ResultSetDefinition
  | RetentionPeriodDefinition of duration:IntegerLiteral option * isInfinity:bool * units:ScriptDom.TemporalRetentionPeriodUnit
  | RouteOption of literal:Literal option * optionKind:ScriptDom.RouteOptionKind
  | RowValue of columnValues:(ScalarExpression) list
  | ScalarExpression of scalarExpression:ScalarExpression
  | SchemaDeclarationItem of schemaDeclarationItem:SchemaDeclarationItem
  | SchemaObjectNameOrValueExpression of schemaObjectName:SchemaObjectName option * valueExpression:ValueExpression option
  | SearchPropertyListAction of searchPropertyListAction:SearchPropertyListAction
  | SecurityElement80 of securityElement80:SecurityElement80
  | SecurityPolicyOption of optionKind:ScriptDom.SecurityPolicyOptionKind * optionState:ScriptDom.OptionState
  | SecurityPredicateAction of actionType:ScriptDom.SecurityPredicateActionType * functionCall:FunctionCall option * securityPredicateOperation:ScriptDom.SecurityPredicateOperation * securityPredicateType:ScriptDom.SecurityPredicateType * targetObjectName:SchemaObjectName option
  | SecurityPrincipal of identifier:Identifier option * principalType:ScriptDom.PrincipalType
  | SecurityTargetObject of columns:(Identifier) list * objectKind:ScriptDom.SecurityObjectKind * objectName:SecurityTargetObjectName option
  | SecurityTargetObjectName of multiPartIdentifier:MultiPartIdentifier option
  | SecurityUserClause80 of userType80:ScriptDom.UserType80 * users:(Identifier) list
  | SelectElement of selectElement:SelectElement
  | SelectiveXmlIndexPromotedPath of isSingleton:bool * maxLength:IntegerLiteral option * name:Identifier option * path:Literal option * sQLDataType:DataTypeReference option * xQueryDataType:Literal option
  | SequenceOption of sequenceOption:SequenceOption
  | ServiceContract of action:ScriptDom.AlterAction * name:Identifier option
  | SessionOption of sessionOption:SessionOption
  | SetClause of setClause:SetClause
  | SetCommand of setCommand:SetCommand
  | SpatialIndexOption of spatialIndexOption:SpatialIndexOption
  | StatementList of statementList:StatementList
  | StatisticsOption of statisticsOption:StatisticsOption
  | StatisticsPartitionRange of from:IntegerLiteral option * to_:IntegerLiteral option
  | SystemTimePeriodDefinition of endTimeColumn:Identifier option * startTimeColumn:Identifier option
  | TSqlBatch of statements:(TSqlStatement) list
  | TSqlFragmentSnippet of script:String
  | TSqlScript of batches:(TSqlBatch) list
  | TSqlStatement of tSqlStatement:TSqlStatement
  | TableDefinition of columnDefinitions:(ColumnDefinition) list * indexes:(IndexDefinition) list * systemTimePeriod:SystemTimePeriodDefinition option * tableConstraints:(ConstraintDefinition) list
  | TableDistributionPolicy of tableDistributionPolicy:TableDistributionPolicy
  | TableHint of tableHint:TableHint
  | TableIndexType of tableIndexType:TableIndexType
  | TableOption of tableOption:TableOption
  | TableReference of tableReference:TableReference
  | TableSampleClause of repeatSeed:ScalarExpression option * sampleNumber:ScalarExpression option * system:bool * tableSampleClauseOption:ScriptDom.TableSampleClauseOption
  | TableSwitchOption of tableSwitchOption:TableSwitchOption
  | TargetDeclaration of objectName:EventSessionObjectName option * targetDeclarationParameters:(EventDeclarationSetParameter) list
  | TemporalClause of endTime:ScalarExpression option * startTime:ScalarExpression option * temporalClauseType:ScriptDom.TemporalClauseType
  | TopRowFilter of expression:ScalarExpression option * percent:bool * withTies:bool
  | TriggerAction of eventTypeGroup:EventTypeGroupContainer option * triggerActionType:ScriptDom.TriggerActionType
  | TriggerObject of name:SchemaObjectName option * triggerScope:ScriptDom.TriggerScope
  | TriggerOption of triggerOption:TriggerOption
  | UserLoginOption of identifier:Identifier option * userLoginOptionType:ScriptDom.UserLoginOptionType
  | VariableValuePair of isForUnknown:bool * value:ScalarExpression option * variable:VariableReference option
  | ViewOption of optionKind:ScriptDom.ViewOptionKind
  | WhenClause of whenClause:WhenClause
  | WhereClause of cursor:CursorId option * searchCondition:BooleanExpression option
  | WindowDelimiter of offsetValue:ScalarExpression option * windowDelimiterType:ScriptDom.WindowDelimiterType
  | WindowFrameClause of bottom:WindowDelimiter option * top:WindowDelimiter option * windowFrameType:ScriptDom.WindowFrameType
  | WithCtesAndXmlNamespaces of changeTrackingContext:ValueExpression option * commonTableExpressions:(CommonTableExpression) list * xmlNamespaces:XmlNamespaces option
  | WithinGroupClause of hasGraphPath:bool * orderByClause:OrderByClause option
  | WorkloadGroupParameter of workloadGroupParameter:WorkloadGroupParameter
  | XmlNamespaces of xmlNamespacesElements:(XmlNamespacesElement) list
  | XmlNamespacesElement of xmlNamespacesElement:XmlNamespacesElement
  member this.ToCs() : ScriptDom.TSqlFragment =
    match this with
    | AdHocDataSource(initString=aInitString; providerName=aProviderName) ->
      let ret = ScriptDom.AdHocDataSource()
      ret.InitString <- aInitString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderName <- aProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AddFileSpec(file=aFile; fileName=aFileName) ->
      let ret = ScriptDom.AddFileSpec()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileName <- aFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AlterAvailabilityGroupAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AlterAvailabilityGroupFailoverOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AlterAvailabilityGroupFailoverOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AlterDatabaseTermination(immediateRollback=aImmediateRollback; noWait=aNoWait; rollbackAfter=aRollbackAfter) ->
      let ret = ScriptDom.AlterDatabaseTermination()
      ret.ImmediateRollback <- aImmediateRollback
      ret.NoWait <- aNoWait
      ret.RollbackAfter <- aRollbackAfter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AlterFullTextIndexAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AlterRoleAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AlterServerConfigurationBufferPoolExtensionOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AlterServerConfigurationDiagnosticsLogOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AlterServerConfigurationFailoverClusterPropertyOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AlterServerConfigurationHadrClusterOption(isLocal=aIsLocal; optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationHadrClusterOption()
      ret.IsLocal <- aIsLocal
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AlterServerConfigurationSoftNumaOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationSoftNumaOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AlterTableDropTableElement(dropClusteredConstraintOptions=aDropClusteredConstraintOptions; isIfExists=aIsIfExists; name=aName; tableElementType=aTableElementType) ->
      let ret = ScriptDom.AlterTableDropTableElement()
      for e in aDropClusteredConstraintOptions do ret.DropClusteredConstraintOptions.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableElementType <- aTableElementType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ApplicationRoleOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ApplicationRoleOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AssemblyName(className=aClassName; name=aName) ->
      let ret = ScriptDom.AssemblyName()
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AssemblyOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AtomicBlockOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AuditOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AuditSpecificationDetail(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AuditSpecificationPart(details=aDetails; isDrop=aIsDrop) ->
      let ret = ScriptDom.AuditSpecificationPart()
      ret.Details <- aDetails |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDrop <- aIsDrop
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AuditTarget(targetKind=aTargetKind; targetOptions=aTargetOptions) ->
      let ret = ScriptDom.AuditTarget()
      ret.TargetKind <- aTargetKind
      for e in aTargetOptions do ret.TargetOptions.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AuditTargetOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AutomaticTuningOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AvailabilityGroupOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | AvailabilityReplica(options=aOptions; serverName=aServerName) ->
      let ret = ScriptDom.AvailabilityReplica()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.ServerName <- aServerName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | AvailabilityReplicaOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | BackupOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | BackupRestoreFileInfo(itemKind=aItemKind; items=aItems) ->
      let ret = ScriptDom.BackupRestoreFileInfo()
      ret.ItemKind <- aItemKind
      for e in aItems do ret.Items.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | BooleanExpression(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | BoundingBoxParameter(parameter=aParameter; value=aValue) ->
      let ret = ScriptDom.BoundingBoxParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | BrokerPriorityParameter(isDefaultOrAny=aIsDefaultOrAny; parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.BrokerPriorityParameter()
      ret.IsDefaultOrAny <- aIsDefaultOrAny
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | BulkInsertOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | CallTarget(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | CertificateOption(kind=aKind; value=aValue) ->
      let ret = ScriptDom.CertificateOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ChangeTrackingOptionDetail(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ColumnDefinitionBase(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ColumnEncryptionDefinition(parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionDefinition()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ColumnEncryptionDefinitionParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ColumnEncryptionKeyValue(parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionKeyValue()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ColumnEncryptionKeyValueParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ColumnMasterKeyParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ColumnStorageOptions(isFileStream=aIsFileStream; sparseOption=aSparseOption) ->
      let ret = ScriptDom.ColumnStorageOptions()
      ret.IsFileStream <- aIsFileStream
      ret.SparseOption <- aSparseOption
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ColumnWithSortOrder(column=aColumn; sortOrder=aSortOrder) ->
      let ret = ScriptDom.ColumnWithSortOrder()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | CommonTableExpression(columns=aColumns; expressionName=aExpressionName; queryExpression=aQueryExpression) ->
      let ret = ScriptDom.CommonTableExpression()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ExpressionName <- aExpressionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | CompressionPartitionRange(from=aFrom; to_=aTo) ->
      let ret = ScriptDom.CompressionPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ComputeClause(byExpressions=aByExpressions; computeFunctions=aComputeFunctions) ->
      let ret = ScriptDom.ComputeClause()
      for e in aByExpressions do ret.ByExpressions.Add (e.ToCs())
      for e in aComputeFunctions do ret.ComputeFunctions.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ComputeFunction(computeFunctionType=aComputeFunctionType; expression=aExpression) ->
      let ret = ScriptDom.ComputeFunction()
      ret.ComputeFunctionType <- aComputeFunctionType
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ConstraintDefinition(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ContractMessage(name=aName; sentBy=aSentBy) ->
      let ret = ScriptDom.ContractMessage()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SentBy <- aSentBy
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | CreateLoginSource(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | CryptoMechanism(cryptoMechanismType=aCryptoMechanismType; identifier=aIdentifier; passwordOrSignature=aPasswordOrSignature) ->
      let ret = ScriptDom.CryptoMechanism()
      ret.CryptoMechanismType <- aCryptoMechanismType
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PasswordOrSignature <- aPasswordOrSignature |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | CursorDefinition(options=aOptions; select=aSelect) ->
      let ret = ScriptDom.CursorDefinition()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Select <- aSelect |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | CursorId(isGlobal=aIsGlobal; name=aName) ->
      let ret = ScriptDom.CursorId()
      ret.IsGlobal <- aIsGlobal
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | CursorOption(optionKind=aOptionKind) ->
      let ret = ScriptDom.CursorOption()
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DataModificationSpecification(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DataTypeReference(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DatabaseAuditAction(actionKind=aActionKind) ->
      let ret = ScriptDom.DatabaseAuditAction()
      ret.ActionKind <- aActionKind
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DatabaseConfigurationClearOption(optionKind=aOptionKind; planHandle=aPlanHandle) ->
      let ret = ScriptDom.DatabaseConfigurationClearOption()
      ret.OptionKind <- aOptionKind
      ret.PlanHandle <- aPlanHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DatabaseConfigurationSetOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DatabaseOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DbccNamedLiteral(name=aName; value=aValue) ->
      let ret = ScriptDom.DbccNamedLiteral()
      ret.Name <- aName
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DbccOption(optionKind=aOptionKind) ->
      let ret = ScriptDom.DbccOption()
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DeclareTableVariableBody(asDefined=aAsDefined; definition=aDefinition; variableName=aVariableName) ->
      let ret = ScriptDom.DeclareTableVariableBody()
      ret.AsDefined <- aAsDefined
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DeclareVariableElement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DeviceInfo(deviceType=aDeviceType; logicalDevice=aLogicalDevice; physicalDevice=aPhysicalDevice) ->
      let ret = ScriptDom.DeviceInfo()
      ret.DeviceType <- aDeviceType
      ret.LogicalDevice <- aLogicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PhysicalDevice <- aPhysicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DialogOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DiskStatementOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.DiskStatementOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | DropClusteredConstraintOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | DropIndexClauseBase(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | EncryptionSource(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | EndpointAffinity(kind=aKind; value=aValue) ->
      let ret = ScriptDom.EndpointAffinity()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | EndpointProtocolOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | EventDeclaration(eventDeclarationActionParameters=aEventDeclarationActionParameters; eventDeclarationPredicateParameter=aEventDeclarationPredicateParameter; eventDeclarationSetParameters=aEventDeclarationSetParameters; objectName=aObjectName) ->
      let ret = ScriptDom.EventDeclaration()
      for e in aEventDeclarationActionParameters do ret.EventDeclarationActionParameters.Add (e.ToCs())
      ret.EventDeclarationPredicateParameter <- aEventDeclarationPredicateParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aEventDeclarationSetParameters do ret.EventDeclarationSetParameters.Add (e.ToCs())
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | EventDeclarationSetParameter(eventField=aEventField; eventValue=aEventValue) ->
      let ret = ScriptDom.EventDeclarationSetParameter()
      ret.EventField <- aEventField |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EventValue <- aEventValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | EventNotificationObjectScope(queueName=aQueueName; target=aTarget) ->
      let ret = ScriptDom.EventNotificationObjectScope()
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | EventSessionObjectName(multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.EventSessionObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | EventTypeGroupContainer(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ExecutableEntity(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ExecuteAsClause(executeAsOption=aExecuteAsOption; literal=aLiteral) ->
      let ret = ScriptDom.ExecuteAsClause()
      ret.ExecuteAsOption <- aExecuteAsOption
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExecuteContext(kind=aKind; principal=aPrincipal) ->
      let ret = ScriptDom.ExecuteContext()
      ret.Kind <- aKind
      ret.Principal <- aPrincipal |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExecuteOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ExecuteParameter(isOutput=aIsOutput; parameterValue=aParameterValue; variable=aVariable) ->
      let ret = ScriptDom.ExecuteParameter()
      ret.IsOutput <- aIsOutput
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExecuteSpecification(executableEntity=aExecutableEntity; executeContext=aExecuteContext; linkedServer=aLinkedServer; variable=aVariable) ->
      let ret = ScriptDom.ExecuteSpecification()
      ret.ExecutableEntity <- aExecutableEntity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExecuteContext <- aExecuteContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LinkedServer <- aLinkedServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExpressionWithSortOrder(expression=aExpression; sortOrder=aSortOrder) ->
      let ret = ScriptDom.ExpressionWithSortOrder()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExternalDataSourceOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ExternalFileFormatOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ExternalResourcePoolAffinitySpecification(affinityType=aAffinityType; isAuto=aIsAuto; parameterValue=aParameterValue; poolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ExternalResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExternalResourcePoolParameter(affinitySpecification=aAffinitySpecification; parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.ExternalResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExternalTableColumnDefinition(columnDefinition=aColumnDefinition; nullableConstraint=aNullableConstraint) ->
      let ret = ScriptDom.ExternalTableColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullableConstraint <- aNullableConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ExternalTableDistributionPolicy(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ExternalTableOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | FederationScheme(columnName=aColumnName; distributionName=aDistributionName) ->
      let ret = ScriptDom.FederationScheme()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FetchType(orientation=aOrientation; rowOffset=aRowOffset) ->
      let ret = ScriptDom.FetchType()
      ret.Orientation <- aOrientation
      ret.RowOffset <- aRowOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FileDeclaration(isPrimary=aIsPrimary; options=aOptions) ->
      let ret = ScriptDom.FileDeclaration()
      ret.IsPrimary <- aIsPrimary
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FileDeclarationOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | FileGroupDefinition(containsFileStream=aContainsFileStream; containsMemoryOptimizedData=aContainsMemoryOptimizedData; fileDeclarations=aFileDeclarations; isDefault=aIsDefault; name=aName) ->
      let ret = ScriptDom.FileGroupDefinition()
      ret.ContainsFileStream <- aContainsFileStream
      ret.ContainsMemoryOptimizedData <- aContainsMemoryOptimizedData
      for e in aFileDeclarations do ret.FileDeclarations.Add (e.ToCs())
      ret.IsDefault <- aIsDefault
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FileGroupOrPartitionScheme(name=aName; partitionSchemeColumns=aPartitionSchemeColumns) ->
      let ret = ScriptDom.FileGroupOrPartitionScheme()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitionSchemeColumns do ret.PartitionSchemeColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ForClause(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | FromClause(tableReferences=aTableReferences) ->
      let ret = ScriptDom.FromClause()
      for e in aTableReferences do ret.TableReferences.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FullTextCatalogAndFileGroup(catalogName=aCatalogName; fileGroupIsFirst=aFileGroupIsFirst; fileGroupName=aFileGroupName) ->
      let ret = ScriptDom.FullTextCatalogAndFileGroup()
      ret.CatalogName <- aCatalogName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroupIsFirst <- aFileGroupIsFirst
      ret.FileGroupName <- aFileGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FullTextCatalogOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | FullTextIndexColumn(languageTerm=aLanguageTerm; name=aName; statisticalSemantics=aStatisticalSemantics; typeColumn=aTypeColumn) ->
      let ret = ScriptDom.FullTextIndexColumn()
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatisticalSemantics <- aStatisticalSemantics
      ret.TypeColumn <- aTypeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FullTextIndexOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | FullTextStopListAction(isAdd=aIsAdd; isAll=aIsAll; languageTerm=aLanguageTerm; stopWord=aStopWord) ->
      let ret = ScriptDom.FullTextStopListAction()
      ret.IsAdd <- aIsAdd
      ret.IsAll <- aIsAll
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StopWord <- aStopWord |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | FunctionOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | FunctionReturnType(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | GraphConnectionBetweenNodes(fromNode=aFromNode; toNode=aToNode) ->
      let ret = ScriptDom.GraphConnectionBetweenNodes()
      ret.FromNode <- aFromNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ToNode <- aToNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | GridParameter(parameter=aParameter; value=aValue) ->
      let ret = ScriptDom.GridParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | GroupByClause(all=aAll; groupByOption=aGroupByOption; groupingSpecifications=aGroupingSpecifications) ->
      let ret = ScriptDom.GroupByClause()
      ret.All <- aAll
      ret.GroupByOption <- aGroupByOption
      for e in aGroupingSpecifications do ret.GroupingSpecifications.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | GroupingSpecification(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | HavingClause(searchCondition=aSearchCondition) ->
      let ret = ScriptDom.HavingClause()
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | IPv4(octetFour=aOctetFour; octetOne=aOctetOne; octetThree=aOctetThree; octetTwo=aOctetTwo) ->
      let ret = ScriptDom.IPv4()
      ret.OctetFour <- aOctetFour |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetOne <- aOctetOne |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetThree <- aOctetThree |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetTwo <- aOctetTwo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | Identifier(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | IdentifierOrScalarExpression(identifier=aIdentifier; scalarExpression=aScalarExpression) ->
      let ret = ScriptDom.IdentifierOrScalarExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ScalarExpression <- aScalarExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | IdentifierOrValueExpression(identifier=aIdentifier; value=aValue; valueExpression=aValueExpression) ->
      let ret = ScriptDom.IdentifierOrValueExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop Value - it is Readonly
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | IdentityOptions(identityIncrement=aIdentityIncrement; identitySeed=aIdentitySeed; isIdentityNotForReplication=aIsIdentityNotForReplication) ->
      let ret = ScriptDom.IdentityOptions()
      ret.IdentityIncrement <- aIdentityIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IdentitySeed <- aIdentitySeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsIdentityNotForReplication <- aIsIdentityNotForReplication
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | IndexOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | IndexType(indexTypeKind=aIndexTypeKind) ->
      let ret = ScriptDom.IndexType()
      ret.IndexTypeKind <- Option.toNullable aIndexTypeKind
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | InsertBulkColumnDefinition(column=aColumn; nullNotNull=aNullNotNull) ->
      let ret = ScriptDom.InsertBulkColumnDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullNotNull <- aNullNotNull
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | InsertSource(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | KeyOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | LiteralRange(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | LowPriorityLockWaitOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | MergeAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | MergeActionClause(action=aAction; condition=aCondition; searchCondition=aSearchCondition) ->
      let ret = ScriptDom.MergeActionClause()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Condition <- aCondition
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | MethodSpecifier(assemblyName=aAssemblyName; className=aClassName; methodName=aMethodName) ->
      let ret = ScriptDom.MethodSpecifier()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MethodName <- aMethodName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | MirrorToClause(devices=aDevices) ->
      let ret = ScriptDom.MirrorToClause()
      for e in aDevices do ret.Devices.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | MultiPartIdentifier(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | OffsetClause(fetchExpression=aFetchExpression; offsetExpression=aOffsetExpression) ->
      let ret = ScriptDom.OffsetClause()
      ret.FetchExpression <- aFetchExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetExpression <- aOffsetExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | OnlineIndexLowPriorityLockWaitOption(options=aOptions) ->
      let ret = ScriptDom.OnlineIndexLowPriorityLockWaitOption()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | OptimizerHint(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | OptionValue(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | OrderByClause(orderByElements=aOrderByElements) ->
      let ret = ScriptDom.OrderByClause()
      for e in aOrderByElements do ret.OrderByElements.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | OutputClause(selectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputClause()
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | OutputIntoClause(intoTable=aIntoTable; intoTableColumns=aIntoTableColumns; selectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputIntoClause()
      ret.IntoTable <- aIntoTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIntoTableColumns do ret.IntoTableColumns.Add (e.ToCs())
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | OverClause(orderByClause=aOrderByClause; partitions=aPartitions; windowFrameClause=aWindowFrameClause) ->
      let ret = ScriptDom.OverClause()
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitions do ret.Partitions.Add (e.ToCs())
      ret.WindowFrameClause <- aWindowFrameClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | PartitionParameterType(collation=aCollation; dataType=aDataType) ->
      let ret = ScriptDom.PartitionParameterType()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | PartitionSpecifications(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | PartitionSpecifier(all=aAll; number=aNumber) ->
      let ret = ScriptDom.PartitionSpecifier()
      ret.All <- aAll
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | PayloadOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | Permission(columns=aColumns; identifiers=aIdentifiers) ->
      let ret = ScriptDom.Permission()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | PrincipalOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | Privilege80(columns=aColumns; privilegeType80=aPrivilegeType80) ->
      let ret = ScriptDom.Privilege80()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.PrivilegeType80 <- aPrivilegeType80
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ProcedureOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ProcedureReference(name=aName; number=aNumber) ->
      let ret = ScriptDom.ProcedureReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ProcedureReferenceName(procedureReference=aProcedureReference; procedureVariable=aProcedureVariable) ->
      let ret = ScriptDom.ProcedureReferenceName()
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProcedureVariable <- aProcedureVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | QueryExpression(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | QueryStoreOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | QueueOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | RemoteDataArchiveDatabaseSetting(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | RemoteServiceBindingOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ResourcePoolAffinitySpecification(affinityType=aAffinityType; isAuto=aIsAuto; parameterValue=aParameterValue; poolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ResourcePoolParameter(affinitySpecification=aAffinitySpecification; parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.ResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | RestoreOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ResultColumnDefinition(columnDefinition=aColumnDefinition; nullable=aNullable) ->
      let ret = ScriptDom.ResultColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ResultSetDefinition(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | RetentionPeriodDefinition(duration=aDuration; isInfinity=aIsInfinity; units=aUnits) ->
      let ret = ScriptDom.RetentionPeriodDefinition()
      ret.Duration <- aDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsInfinity <- aIsInfinity
      ret.Units <- aUnits
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | RouteOption(literal=aLiteral; optionKind=aOptionKind) ->
      let ret = ScriptDom.RouteOption()
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | RowValue(columnValues=aColumnValues) ->
      let ret = ScriptDom.RowValue()
      for e in aColumnValues do ret.ColumnValues.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ScalarExpression(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SchemaDeclarationItem(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SchemaObjectNameOrValueExpression(schemaObjectName=aSchemaObjectName; valueExpression=aValueExpression) ->
      let ret = ScriptDom.SchemaObjectNameOrValueExpression()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SearchPropertyListAction(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SecurityElement80(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SecurityPolicyOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.SecurityPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SecurityPredicateAction(actionType=aActionType; functionCall=aFunctionCall; securityPredicateOperation=aSecurityPredicateOperation; securityPredicateType=aSecurityPredicateType; targetObjectName=aTargetObjectName) ->
      let ret = ScriptDom.SecurityPredicateAction()
      ret.ActionType <- aActionType
      ret.FunctionCall <- aFunctionCall |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityPredicateOperation <- aSecurityPredicateOperation
      ret.SecurityPredicateType <- aSecurityPredicateType
      ret.TargetObjectName <- aTargetObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SecurityPrincipal(identifier=aIdentifier; principalType=aPrincipalType) ->
      let ret = ScriptDom.SecurityPrincipal()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrincipalType <- aPrincipalType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SecurityTargetObject(columns=aColumns; objectKind=aObjectKind; objectName=aObjectName) ->
      let ret = ScriptDom.SecurityTargetObject()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ObjectKind <- aObjectKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SecurityTargetObjectName(multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.SecurityTargetObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SecurityUserClause80(userType80=aUserType80; users=aUsers) ->
      let ret = ScriptDom.SecurityUserClause80()
      ret.UserType80 <- aUserType80
      for e in aUsers do ret.Users.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SelectElement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SelectiveXmlIndexPromotedPath(isSingleton=aIsSingleton; maxLength=aMaxLength; name=aName; path=aPath; sQLDataType=aSQLDataType; xQueryDataType=aXQueryDataType) ->
      let ret = ScriptDom.SelectiveXmlIndexPromotedPath()
      ret.IsSingleton <- aIsSingleton
      ret.MaxLength <- aMaxLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SQLDataType <- aSQLDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XQueryDataType <- aXQueryDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SequenceOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | ServiceContract(action=aAction; name=aName) ->
      let ret = ScriptDom.ServiceContract()
      ret.Action <- aAction
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SessionOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SetClause(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SetCommand(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | SpatialIndexOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | StatementList(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | StatisticsOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | StatisticsPartitionRange(from=aFrom; to_=aTo) ->
      let ret = ScriptDom.StatisticsPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | SystemTimePeriodDefinition(endTimeColumn=aEndTimeColumn; startTimeColumn=aStartTimeColumn) ->
      let ret = ScriptDom.SystemTimePeriodDefinition()
      ret.EndTimeColumn <- aEndTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTimeColumn <- aStartTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TSqlBatch(statements=aStatements) ->
      let ret = ScriptDom.TSqlBatch()
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TSqlFragmentSnippet(script=aScript) ->
      let ret = ScriptDom.TSqlFragmentSnippet()
      ret.Script <- aScript
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TSqlScript(batches=aBatches) ->
      let ret = ScriptDom.TSqlScript()
      for e in aBatches do ret.Batches.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TSqlStatement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TableDefinition(columnDefinitions=aColumnDefinitions; indexes=aIndexes; systemTimePeriod=aSystemTimePeriod; tableConstraints=aTableConstraints) ->
      let ret = ScriptDom.TableDefinition()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      for e in aIndexes do ret.Indexes.Add (e.ToCs())
      ret.SystemTimePeriod <- aSystemTimePeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableConstraints do ret.TableConstraints.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TableDistributionPolicy(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TableHint(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TableIndexType(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TableOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TableReference(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TableSampleClause(repeatSeed=aRepeatSeed; sampleNumber=aSampleNumber; system=aSystem; tableSampleClauseOption=aTableSampleClauseOption) ->
      let ret = ScriptDom.TableSampleClause()
      ret.RepeatSeed <- aRepeatSeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SampleNumber <- aSampleNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.System <- aSystem
      ret.TableSampleClauseOption <- aTableSampleClauseOption
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TableSwitchOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | TargetDeclaration(objectName=aObjectName; targetDeclarationParameters=aTargetDeclarationParameters) ->
      let ret = ScriptDom.TargetDeclaration()
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTargetDeclarationParameters do ret.TargetDeclarationParameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TemporalClause(endTime=aEndTime; startTime=aStartTime; temporalClauseType=aTemporalClauseType) ->
      let ret = ScriptDom.TemporalClause()
      ret.EndTime <- aEndTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTime <- aStartTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TemporalClauseType <- aTemporalClauseType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TopRowFilter(expression=aExpression; percent=aPercent; withTies=aWithTies) ->
      let ret = ScriptDom.TopRowFilter()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Percent <- aPercent
      ret.WithTies <- aWithTies
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TriggerAction(eventTypeGroup=aEventTypeGroup; triggerActionType=aTriggerActionType) ->
      let ret = ScriptDom.TriggerAction()
      ret.EventTypeGroup <- aEventTypeGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerActionType <- aTriggerActionType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TriggerObject(name=aName; triggerScope=aTriggerScope) ->
      let ret = ScriptDom.TriggerObject()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerScope <- aTriggerScope
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | TriggerOption(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | UserLoginOption(identifier=aIdentifier; userLoginOptionType=aUserLoginOptionType) ->
      let ret = ScriptDom.UserLoginOption()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserLoginOptionType <- aUserLoginOptionType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | VariableValuePair(isForUnknown=aIsForUnknown; value=aValue; variable=aVariable) ->
      let ret = ScriptDom.VariableValuePair()
      ret.IsForUnknown <- aIsForUnknown
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | ViewOption(optionKind=aOptionKind) ->
      let ret = ScriptDom.ViewOption()
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | WhenClause(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | WhereClause(cursor=aCursor; searchCondition=aSearchCondition) ->
      let ret = ScriptDom.WhereClause()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | WindowDelimiter(offsetValue=aOffsetValue; windowDelimiterType=aWindowDelimiterType) ->
      let ret = ScriptDom.WindowDelimiter()
      ret.OffsetValue <- aOffsetValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowDelimiterType <- aWindowDelimiterType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | WindowFrameClause(bottom=aBottom; top=aTop; windowFrameType=aWindowFrameType) ->
      let ret = ScriptDom.WindowFrameClause()
      ret.Bottom <- aBottom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Top <- aTop |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowFrameType <- aWindowFrameType
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | WithCtesAndXmlNamespaces(changeTrackingContext=aChangeTrackingContext; commonTableExpressions=aCommonTableExpressions; xmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.WithCtesAndXmlNamespaces()
      ret.ChangeTrackingContext <- aChangeTrackingContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aCommonTableExpressions do ret.CommonTableExpressions.Add (e.ToCs())
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | WithinGroupClause(hasGraphPath=aHasGraphPath; orderByClause=aOrderByClause) ->
      let ret = ScriptDom.WithinGroupClause()
      ret.HasGraphPath <- aHasGraphPath
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | WorkloadGroupParameter(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
    | XmlNamespaces(xmlNamespacesElements=aXmlNamespacesElements) ->
      let ret = ScriptDom.XmlNamespaces()
      for e in aXmlNamespacesElements do ret.XmlNamespacesElements.Add (e.ToCs())
      ret :> ScriptDom.TSqlFragment (* 404 *)
    | XmlNamespacesElement(x) -> x.ToCs() :> ScriptDom.TSqlFragment (* 414 *)
  static member FromCs(src:ScriptDom.TSqlFragment) : TSqlFragment =
    match src with
    | :? ScriptDom.AdHocDataSource as src ->
      TSqlFragment.AdHocDataSource((src.InitString |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ProviderName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.AddFileSpec as src ->
      TSqlFragment.AddFileSpec((src.File |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FileName |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.AlterAvailabilityGroupAction as src ->
      match src with
      | :? ScriptDom.AlterAvailabilityGroupFailoverAction as src->
        TSqlFragment.AlterAvailabilityGroupAction((AlterAvailabilityGroupAction.AlterAvailabilityGroupFailoverAction((src.ActionType), (src.Options |> Seq.map (fun src -> AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
      | _ -> (* :? ScriptDom.AlterAvailabilityGroupAction as src *)
        TSqlFragment.AlterAvailabilityGroupAction((AlterAvailabilityGroupAction.Base((src.ActionType))))
    | :? ScriptDom.AlterAvailabilityGroupFailoverOption as src ->
      TSqlFragment.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.AlterDatabaseTermination as src ->
      TSqlFragment.AlterDatabaseTermination((src.ImmediateRollback), (src.NoWait), (src.RollbackAfter |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.AlterFullTextIndexAction as src ->
      match src with
      | :? ScriptDom.AddAlterFullTextIndexAction as src->
        TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.AddAlterFullTextIndexAction((src.Columns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.WithNoPopulation))))
      | :? ScriptDom.AlterColumnAlterFullTextIndexAction as src->
        TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.AlterColumnAlterFullTextIndexAction((src.Column |> Option.ofObj |> Option.map (FullTextIndexColumn.FromCs)), (src.WithNoPopulation))))
      | :? ScriptDom.DropAlterFullTextIndexAction as src->
        TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.DropAlterFullTextIndexAction((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.WithNoPopulation))))
      | :? ScriptDom.SetSearchPropertyListAlterFullTextIndexAction as src->
        TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.SetSearchPropertyListAlterFullTextIndexAction((src.SearchPropertyListOption |> Option.ofObj |> Option.map (SearchPropertyListFullTextIndexOption.FromCs)), (src.WithNoPopulation))))
      | :? ScriptDom.SetStopListAlterFullTextIndexAction as src->
        TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.SetStopListAlterFullTextIndexAction((src.StopListOption |> Option.ofObj |> Option.map (StopListFullTextIndexOption.FromCs)), (src.WithNoPopulation))))
      | :? ScriptDom.SimpleAlterFullTextIndexAction as src->
        TSqlFragment.AlterFullTextIndexAction((AlterFullTextIndexAction.SimpleAlterFullTextIndexAction((src.ActionKind))))
    | :? ScriptDom.AlterRoleAction as src ->
      match src with
      | :? ScriptDom.AddMemberAlterRoleAction as src->
        TSqlFragment.AlterRoleAction((AlterRoleAction.AddMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropMemberAlterRoleAction as src->
        TSqlFragment.AlterRoleAction((AlterRoleAction.DropMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.RenameAlterRoleAction as src->
        TSqlFragment.AlterRoleAction((AlterRoleAction.RenameAlterRoleAction((src.NewName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionOption as src ->
      match src with
      | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionContainerOption as src->
        TSqlFragment.AlterServerConfigurationBufferPoolExtensionOption((AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionContainerOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)), (src.Suboptions |> Seq.map (AlterServerConfigurationBufferPoolExtensionOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionSizeOption as src->
        TSqlFragment.AlterServerConfigurationBufferPoolExtensionOption((AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionSizeOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)), (src.SizeUnit))))
      | _ -> (* :? ScriptDom.AlterServerConfigurationBufferPoolExtensionOption as src *)
        TSqlFragment.AlterServerConfigurationBufferPoolExtensionOption((AlterServerConfigurationBufferPoolExtensionOption.Base((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))))
    | :? ScriptDom.AlterServerConfigurationDiagnosticsLogOption as src ->
      match src with
      | :? ScriptDom.AlterServerConfigurationDiagnosticsLogMaxSizeOption as src->
        TSqlFragment.AlterServerConfigurationDiagnosticsLogOption((AlterServerConfigurationDiagnosticsLogOption.AlterServerConfigurationDiagnosticsLogMaxSizeOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)), (src.SizeUnit))))
      | _ -> (* :? ScriptDom.AlterServerConfigurationDiagnosticsLogOption as src *)
        TSqlFragment.AlterServerConfigurationDiagnosticsLogOption((AlterServerConfigurationDiagnosticsLogOption.Base((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))))
    | :? ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption as src ->
      TSqlFragment.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))
    | :? ScriptDom.AlterServerConfigurationHadrClusterOption as src ->
      TSqlFragment.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))
    | :? ScriptDom.AlterServerConfigurationSoftNumaOption as src ->
      TSqlFragment.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))
    | :? ScriptDom.AlterTableDropTableElement as src ->
      TSqlFragment.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (DropClusteredConstraintOption.FromCs) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableElementType))
    | :? ScriptDom.ApplicationRoleOption as src ->
      TSqlFragment.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.AssemblyName as src ->
      TSqlFragment.AssemblyName((src.ClassName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AssemblyOption as src ->
      match src with
      | :? ScriptDom.OnOffAssemblyOption as src->
        TSqlFragment.AssemblyOption((AssemblyOption.OnOffAssemblyOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.PermissionSetAssemblyOption as src->
        TSqlFragment.AssemblyOption((AssemblyOption.PermissionSetAssemblyOption((src.OptionKind), (src.PermissionSetOption))))
      | _ -> (* :? ScriptDom.AssemblyOption as src *)
        TSqlFragment.AssemblyOption((AssemblyOption.Base((src.OptionKind))))
    | :? ScriptDom.AtomicBlockOption as src ->
      match src with
      | :? ScriptDom.IdentifierAtomicBlockOption as src->
        TSqlFragment.AtomicBlockOption((AtomicBlockOption.IdentifierAtomicBlockOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.LiteralAtomicBlockOption as src->
        TSqlFragment.AtomicBlockOption((AtomicBlockOption.LiteralAtomicBlockOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OnOffAtomicBlockOption as src->
        TSqlFragment.AtomicBlockOption((AtomicBlockOption.OnOffAtomicBlockOption((src.OptionKind), (src.OptionState))))
    | :? ScriptDom.AuditOption as src ->
      match src with
      | :? ScriptDom.AuditGuidAuditOption as src->
        TSqlFragment.AuditOption((AuditOption.AuditGuidAuditOption((src.Guid |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.OnFailureAuditOption as src->
        TSqlFragment.AuditOption((AuditOption.OnFailureAuditOption((src.OnFailureAction), (src.OptionKind))))
      | :? ScriptDom.QueueDelayAuditOption as src->
        TSqlFragment.AuditOption((AuditOption.QueueDelayAuditOption((src.Delay |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.StateAuditOption as src->
        TSqlFragment.AuditOption((AuditOption.StateAuditOption((src.OptionKind), (src.Value))))
    | :? ScriptDom.AuditSpecificationDetail as src ->
      match src with
      | :? ScriptDom.AuditActionGroupReference as src->
        TSqlFragment.AuditSpecificationDetail((AuditSpecificationDetail.AuditActionGroupReference((src.Group))))
      | :? ScriptDom.AuditActionSpecification as src->
        TSqlFragment.AuditSpecificationDetail((AuditSpecificationDetail.AuditActionSpecification((src.Actions |> Seq.map (fun src -> DatabaseAuditAction.DatabaseAuditAction((src.ActionKind))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.TargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)))))
    | :? ScriptDom.AuditSpecificationPart as src ->
      TSqlFragment.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))
    | :? ScriptDom.AuditTarget as src ->
      TSqlFragment.AuditTarget((src.TargetKind), (src.TargetOptions |> Seq.map (AuditTargetOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.AuditTargetOption as src ->
      match src with
      | :? ScriptDom.LiteralAuditTargetOption as src->
        TSqlFragment.AuditTargetOption((AuditTargetOption.LiteralAuditTargetOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.MaxRolloverFilesAuditTargetOption as src->
        TSqlFragment.AuditTargetOption((AuditTargetOption.MaxRolloverFilesAuditTargetOption((src.IsUnlimited), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.MaxSizeAuditTargetOption as src->
        TSqlFragment.AuditTargetOption((AuditTargetOption.MaxSizeAuditTargetOption((src.IsUnlimited), (src.OptionKind), (src.Size |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unit))))
      | :? ScriptDom.OnOffAuditTargetOption as src->
        TSqlFragment.AuditTargetOption((AuditTargetOption.OnOffAuditTargetOption((src.OptionKind), (src.Value))))
    | :? ScriptDom.AutomaticTuningOption as src ->
      match src with
      | :? ScriptDom.AutomaticTuningCreateIndexOption as src->
        TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningCreateIndexOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.AutomaticTuningDropIndexOption as src->
        TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningDropIndexOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.AutomaticTuningForceLastGoodPlanOption as src->
        TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningForceLastGoodPlanOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.AutomaticTuningMaintainIndexOption as src->
        TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.AutomaticTuningMaintainIndexOption((src.OptionKind), (src.Value))))
      | _ -> (* :? ScriptDom.AutomaticTuningOption as src *)
        TSqlFragment.AutomaticTuningOption((AutomaticTuningOption.Base((src.OptionKind), (src.Value))))
    | :? ScriptDom.AvailabilityGroupOption as src ->
      match src with
      | :? ScriptDom.LiteralAvailabilityGroupOption as src->
        TSqlFragment.AvailabilityGroupOption((AvailabilityGroupOption.LiteralAvailabilityGroupOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.AvailabilityReplica as src ->
      TSqlFragment.AvailabilityReplica((src.Options |> Seq.map (AvailabilityReplicaOption.FromCs) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.AvailabilityReplicaOption as src ->
      match src with
      | :? ScriptDom.AvailabilityModeReplicaOption as src->
        TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.AvailabilityModeReplicaOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.FailoverModeReplicaOption as src->
        TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.FailoverModeReplicaOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.LiteralReplicaOption as src->
        TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.LiteralReplicaOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.PrimaryRoleReplicaOption as src->
        TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.PrimaryRoleReplicaOption((src.AllowConnections), (src.OptionKind))))
      | :? ScriptDom.SecondaryRoleReplicaOption as src->
        TSqlFragment.AvailabilityReplicaOption((AvailabilityReplicaOption.SecondaryRoleReplicaOption((src.AllowConnections), (src.OptionKind))))
    | :? ScriptDom.BackupOption as src ->
      match src with
      | :? ScriptDom.BackupEncryptionOption as src->
        TSqlFragment.BackupOption((BackupOption.BackupEncryptionOption((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | _ -> (* :? ScriptDom.BackupOption as src *)
        TSqlFragment.BackupOption((BackupOption.Base((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
    | :? ScriptDom.BackupRestoreFileInfo as src ->
      TSqlFragment.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.BooleanExpression as src ->
      match src with
      | :? ScriptDom.BooleanBinaryExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanBinaryExpression((src.BinaryExpressionType), (src.FirstExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))))
      | :? ScriptDom.BooleanComparisonExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanComparisonExpression((src.ComparisonType), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.BooleanExpressionSnippet as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanExpressionSnippet((src.Script))))
      | :? ScriptDom.BooleanIsNullExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanIsNullExpression((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsNot))))
      | :? ScriptDom.BooleanNotExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanNotExpression((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))))
      | :? ScriptDom.BooleanParenthesisExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanParenthesisExpression((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))))
      | :? ScriptDom.BooleanTernaryExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.BooleanTernaryExpression((src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TernaryExpressionType), (src.ThirdExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.EventDeclarationCompareFunctionParameter as src->
        TSqlFragment.BooleanExpression((BooleanExpression.EventDeclarationCompareFunctionParameter((src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.SourceDeclaration |> Option.ofObj |> Option.map (SourceDeclaration.FromCs)))))
      | :? ScriptDom.ExistsPredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.ExistsPredicate((src.Subquery |> Option.ofObj |> Option.map (ScalarSubquery.FromCs)))))
      | :? ScriptDom.FullTextPredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.FullTextPredicate((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FullTextFunctionType), (src.LanguageTerm |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Value |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.GraphMatchCompositeExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchCompositeExpression((src.ArrowOnRight), (src.Edge |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LeftNode |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)), (src.RightNode |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)))))
      | :? ScriptDom.GraphMatchExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchExpression((src.ArrowOnRight), (src.Edge |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LeftNode |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RightNode |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.GraphMatchLastNodePredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchLastNodePredicate((src.LeftExpression |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)), (src.RightExpression |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)))))
      | :? ScriptDom.GraphMatchNodeExpression as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchNodeExpression((src.Node |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UsesLastNode))))
      | :? ScriptDom.GraphMatchPredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchPredicate((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))))
      | :? ScriptDom.GraphMatchRecursivePredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphMatchRecursivePredicate((src.AnchorOnLeft), (src.Expression |> Seq.map (BooleanExpression.FromCs) |> List.ofSeq), (src.Function), (src.OuterNodeExpression |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)), (src.RecursiveQuantifier |> Option.ofObj |> Option.map (GraphRecursiveMatchQuantifier.FromCs)))))
      | :? ScriptDom.GraphRecursiveMatchQuantifier as src->
        TSqlFragment.BooleanExpression((BooleanExpression.GraphRecursiveMatchQuantifier((src.IsPlusSign), (src.LowerLimit |> Option.ofObj |> Option.map (Literal.FromCs)), (src.UpperLimit |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.InPredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.InPredicate((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.NotDefined), (src.Subquery |> Option.ofObj |> Option.map (ScalarSubquery.FromCs)), (src.Values |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.LikePredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.LikePredicate((src.EscapeExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.NotDefined), (src.OdbcEscape), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.SubqueryComparisonPredicate as src->
        TSqlFragment.BooleanExpression((BooleanExpression.SubqueryComparisonPredicate((src.ComparisonType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Subquery |> Option.ofObj |> Option.map (ScalarSubquery.FromCs)), (src.SubqueryComparisonPredicateType))))
      | :? ScriptDom.TSEqualCall as src->
        TSqlFragment.BooleanExpression((BooleanExpression.TSEqualCall((src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.UpdateCall as src->
        TSqlFragment.BooleanExpression((BooleanExpression.UpdateCall((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.BoundingBoxParameter as src ->
      TSqlFragment.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.BrokerPriorityParameter as src ->
      TSqlFragment.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.BulkInsertOption as src ->
      match src with
      | :? ScriptDom.LiteralBulkInsertOption as src->
        TSqlFragment.BulkInsertOption((BulkInsertOption.LiteralBulkInsertOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OrderBulkInsertOption as src->
        TSqlFragment.BulkInsertOption((BulkInsertOption.OrderBulkInsertOption((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.IsUnique), (src.OptionKind))))
      | _ -> (* :? ScriptDom.BulkInsertOption as src *)
        TSqlFragment.BulkInsertOption((BulkInsertOption.Base((src.OptionKind))))
    | :? ScriptDom.CallTarget as src ->
      match src with
      | :? ScriptDom.ExpressionCallTarget as src->
        TSqlFragment.CallTarget((CallTarget.ExpressionCallTarget((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.MultiPartIdentifierCallTarget as src->
        TSqlFragment.CallTarget((CallTarget.MultiPartIdentifierCallTarget((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))))
      | :? ScriptDom.UserDefinedTypeCallTarget as src->
        TSqlFragment.CallTarget((CallTarget.UserDefinedTypeCallTarget((src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.CertificateOption as src ->
      TSqlFragment.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ChangeTrackingOptionDetail as src ->
      match src with
      | :? ScriptDom.AutoCleanupChangeTrackingOptionDetail as src->
        TSqlFragment.ChangeTrackingOptionDetail((ChangeTrackingOptionDetail.AutoCleanupChangeTrackingOptionDetail((src.IsOn))))
      | :? ScriptDom.ChangeRetentionChangeTrackingOptionDetail as src->
        TSqlFragment.ChangeTrackingOptionDetail((ChangeTrackingOptionDetail.ChangeRetentionChangeTrackingOptionDetail((src.RetentionPeriod |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unit))))
    | :? ScriptDom.ColumnDefinitionBase as src ->
      match src with
      | :? ScriptDom.ColumnDefinition as src->
        TSqlFragment.ColumnDefinitionBase((ColumnDefinitionBase.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Constraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DefaultConstraint |> Option.ofObj |> Option.map (DefaultConstraintDefinition.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (IdentityOptions.FromCs)), (src.Index |> Option.ofObj |> Option.map (IndexDefinition.FromCs)), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))))
      | _ -> (* :? ScriptDom.ColumnDefinitionBase as src *)
        TSqlFragment.ColumnDefinitionBase((ColumnDefinitionBase.Base((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))))
    | :? ScriptDom.ColumnEncryptionDefinition as src ->
      TSqlFragment.ColumnEncryptionDefinition((src.Parameters |> Seq.map (ColumnEncryptionDefinitionParameter.FromCs) |> List.ofSeq))
    | :? ScriptDom.ColumnEncryptionDefinitionParameter as src ->
      match src with
      | :? ScriptDom.ColumnEncryptionAlgorithmParameter as src->
        TSqlFragment.ColumnEncryptionDefinitionParameter((ColumnEncryptionDefinitionParameter.ColumnEncryptionAlgorithmParameter((src.EncryptionAlgorithm |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ParameterKind))))
      | :? ScriptDom.ColumnEncryptionKeyNameParameter as src->
        TSqlFragment.ColumnEncryptionDefinitionParameter((ColumnEncryptionDefinitionParameter.ColumnEncryptionKeyNameParameter((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterKind))))
      | :? ScriptDom.ColumnEncryptionTypeParameter as src->
        TSqlFragment.ColumnEncryptionDefinitionParameter((ColumnEncryptionDefinitionParameter.ColumnEncryptionTypeParameter((src.EncryptionType), (src.ParameterKind))))
    | :? ScriptDom.ColumnEncryptionKeyValue as src ->
      TSqlFragment.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (ColumnEncryptionKeyValueParameter.FromCs) |> List.ofSeq))
    | :? ScriptDom.ColumnEncryptionKeyValueParameter as src ->
      match src with
      | :? ScriptDom.ColumnEncryptionAlgorithmNameParameter as src->
        TSqlFragment.ColumnEncryptionKeyValueParameter((ColumnEncryptionKeyValueParameter.ColumnEncryptionAlgorithmNameParameter((src.Algorithm |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ParameterKind))))
      | :? ScriptDom.ColumnMasterKeyNameParameter as src->
        TSqlFragment.ColumnEncryptionKeyValueParameter((ColumnEncryptionKeyValueParameter.ColumnMasterKeyNameParameter((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterKind))))
      | :? ScriptDom.EncryptedValueParameter as src->
        TSqlFragment.ColumnEncryptionKeyValueParameter((ColumnEncryptionKeyValueParameter.EncryptedValueParameter((src.ParameterKind), (src.Value |> Option.ofObj |> Option.map (BinaryLiteral.FromCs)))))
    | :? ScriptDom.ColumnMasterKeyParameter as src ->
      match src with
      | :? ScriptDom.ColumnMasterKeyPathParameter as src->
        TSqlFragment.ColumnMasterKeyParameter((ColumnMasterKeyParameter.ColumnMasterKeyPathParameter((src.ParameterKind), (src.Path |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
      | :? ScriptDom.ColumnMasterKeyStoreProviderNameParameter as src->
        TSqlFragment.ColumnMasterKeyParameter((ColumnMasterKeyParameter.ColumnMasterKeyStoreProviderNameParameter((src.Name |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ParameterKind))))
    | :? ScriptDom.ColumnStorageOptions as src ->
      TSqlFragment.ColumnStorageOptions((src.IsFileStream), (src.SparseOption))
    | :? ScriptDom.ColumnWithSortOrder as src ->
      TSqlFragment.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))
    | :? ScriptDom.CommonTableExpression as src ->
      TSqlFragment.CommonTableExpression((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
    | :? ScriptDom.CompressionPartitionRange as src ->
      TSqlFragment.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ComputeClause as src ->
      TSqlFragment.ComputeClause((src.ByExpressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.ComputeFunction as src ->
      TSqlFragment.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ConstraintDefinition as src ->
      match src with
      | :? ScriptDom.CheckConstraintDefinition as src->
        TSqlFragment.ConstraintDefinition((ConstraintDefinition.CheckConstraintDefinition((src.CheckCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.NotForReplication))))
      | :? ScriptDom.DefaultConstraintDefinition as src->
        TSqlFragment.ConstraintDefinition((ConstraintDefinition.DefaultConstraintDefinition((src.Column |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WithValues))))
      | :? ScriptDom.ForeignKeyConstraintDefinition as src->
        TSqlFragment.ConstraintDefinition((ConstraintDefinition.ForeignKeyConstraintDefinition((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DeleteAction), (src.NotForReplication), (src.ReferenceTableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ReferencedTableColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.UpdateAction))))
      | :? ScriptDom.GraphConnectionConstraintDefinition as src->
        TSqlFragment.ConstraintDefinition((ConstraintDefinition.GraphConnectionConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DeleteAction), (src.FromNodeToNodeList |> Seq.map (fun src -> GraphConnectionBetweenNodes.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ToNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.NullableConstraintDefinition as src->
        TSqlFragment.ConstraintDefinition((ConstraintDefinition.NullableConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Nullable))))
      | :? ScriptDom.UniqueConstraintDefinition as src->
        TSqlFragment.ConstraintDefinition((ConstraintDefinition.UniqueConstraintDefinition((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.IsPrimaryKey), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)))))
    | :? ScriptDom.ContractMessage as src ->
      TSqlFragment.ContractMessage((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SentBy))
    | :? ScriptDom.CreateLoginSource as src ->
      match src with
      | :? ScriptDom.AsymmetricKeyCreateLoginSource as src->
        TSqlFragment.CreateLoginSource((CreateLoginSource.AsymmetricKeyCreateLoginSource((src.Credential |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Key |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CertificateCreateLoginSource as src->
        TSqlFragment.CreateLoginSource((CreateLoginSource.CertificateCreateLoginSource((src.Certificate |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Credential |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.PasswordCreateLoginSource as src->
        TSqlFragment.CreateLoginSource((CreateLoginSource.PasswordCreateLoginSource((src.Hashed), (src.MustChange), (src.Options |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.WindowsCreateLoginSource as src->
        TSqlFragment.CreateLoginSource((CreateLoginSource.WindowsCreateLoginSource((src.Options |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.CryptoMechanism as src ->
      TSqlFragment.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.CursorDefinition as src ->
      TSqlFragment.CursorDefinition((src.Options |> Seq.map (fun src -> CursorOption.CursorOption((src.OptionKind))) |> List.ofSeq), (src.Select |> Option.ofObj |> Option.map (SelectStatement.FromCs)))
    | :? ScriptDom.CursorId as src ->
      TSqlFragment.CursorId((src.IsGlobal), (src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.CursorOption as src ->
      TSqlFragment.CursorOption((src.OptionKind))
    | :? ScriptDom.DataModificationSpecification as src ->
      match src with
      | :? ScriptDom.InsertSpecification as src->
        TSqlFragment.DataModificationSpecification((DataModificationSpecification.InsertSpecification((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.InsertOption), (src.InsertSource |> Option.ofObj |> Option.map (InsertSource.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)))))
      | :? ScriptDom.MergeSpecification as src->
        TSqlFragment.DataModificationSpecification((DataModificationSpecification.MergeSpecification((src.ActionClauses |> Seq.map (fun src -> MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (MergeAction.FromCs)), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))) |> List.ofSeq), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.TableAlias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)))))
      | :? ScriptDom.UpdateDeleteSpecificationBase as src->
        TSqlFragment.DataModificationSpecification((DataModificationSpecification.UpdateDeleteSpecificationBase((UpdateDeleteSpecificationBase.FromCs(src)))))
    | :? ScriptDom.DataTypeReference as src ->
      match src with
      | :? ScriptDom.ParameterizedDataTypeReference as src->
        TSqlFragment.DataTypeReference((DataTypeReference.ParameterizedDataTypeReference((ParameterizedDataTypeReference.FromCs(src)))))
      | :? ScriptDom.XmlDataTypeReference as src->
        TSqlFragment.DataTypeReference((DataTypeReference.XmlDataTypeReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.XmlDataTypeOption), (src.XmlSchemaCollection |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.DatabaseAuditAction as src ->
      TSqlFragment.DatabaseAuditAction((src.ActionKind))
    | :? ScriptDom.DatabaseConfigurationClearOption as src ->
      TSqlFragment.DatabaseConfigurationClearOption((src.OptionKind), (src.PlanHandle |> Option.ofObj |> Option.map (BinaryLiteral.FromCs)))
    | :? ScriptDom.DatabaseConfigurationSetOption as src ->
      match src with
      | :? ScriptDom.GenericConfigurationOption as src->
        TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.GenericConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.GenericOptionState |> Option.ofObj |> Option.map (IdentifierOrScalarExpression.FromCs)), (src.OptionKind))))
      | :? ScriptDom.MaxDopConfigurationOption as src->
        TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.MaxDopConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind), (src.Primary), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OnOffPrimaryConfigurationOption as src->
        TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.OnOffPrimaryConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind), (src.OptionState))))
      | _ -> (* :? ScriptDom.DatabaseConfigurationSetOption as src *)
        TSqlFragment.DatabaseConfigurationSetOption((DatabaseConfigurationSetOption.Base((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind))))
    | :? ScriptDom.DatabaseOption as src ->
      match src with
      | :? ScriptDom.AutomaticTuningDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.AutomaticTuningDatabaseOption((src.AutomaticTuningState), (src.OptionKind), (src.Options |> Seq.map (AutomaticTuningOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CatalogCollationOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.CatalogCollationOption((Option.ofNullable (src.CatalogCollation)), (src.OptionKind))))
      | :? ScriptDom.ChangeTrackingDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.ChangeTrackingDatabaseOption((src.Details |> Seq.map (ChangeTrackingOptionDetail.FromCs) |> List.ofSeq), (src.OptionKind), (src.OptionState))))
      | :? ScriptDom.ContainmentDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.ContainmentDatabaseOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.CursorDefaultDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.CursorDefaultDatabaseOption((src.IsLocal), (src.OptionKind))))
      | :? ScriptDom.DelayedDurabilityDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.DelayedDurabilityDatabaseOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.FileStreamDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.FileStreamDatabaseOption((src.DirectoryName |> Option.ofObj |> Option.map (Literal.FromCs)), (Option.ofNullable (src.NonTransactedAccess)), (src.OptionKind))))
      | :? ScriptDom.HadrDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.HadrDatabaseOption((HadrDatabaseOption.FromCs(src)))))
      | :? ScriptDom.IdentifierDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.IdentifierDatabaseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.LiteralDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.LiteralDatabaseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.MaxSizeDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.MaxSizeDatabaseOption((src.MaxSize |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Units))))
      | :? ScriptDom.OnOffDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.OnOffDatabaseOption((OnOffDatabaseOption.FromCs(src)))))
      | :? ScriptDom.PageVerifyDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.PageVerifyDatabaseOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.ParameterizationDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.ParameterizationDatabaseOption((src.IsSimple), (src.OptionKind))))
      | :? ScriptDom.PartnerDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.PartnerDatabaseOption((src.OptionKind), (src.PartnerOption), (src.PartnerServer |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Timeout |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.QueryStoreDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.QueryStoreDatabaseOption((src.Clear), (src.ClearAll), (src.OptionKind), (src.OptionState), (src.Options |> Seq.map (QueryStoreOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.RecoveryDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.RecoveryDatabaseOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.RemoteDataArchiveDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.RemoteDataArchiveDatabaseOption((src.OptionKind), (src.OptionState), (src.Settings |> Seq.map (RemoteDataArchiveDatabaseSetting.FromCs) |> List.ofSeq))))
      | :? ScriptDom.TargetRecoveryTimeDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.TargetRecoveryTimeDatabaseOption((src.OptionKind), (src.RecoveryTime |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unit))))
      | :? ScriptDom.WitnessDatabaseOption as src->
        TSqlFragment.DatabaseOption((DatabaseOption.WitnessDatabaseOption((src.IsOff), (src.OptionKind), (src.WitnessServer |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | _ -> (* :? ScriptDom.DatabaseOption as src *)
        TSqlFragment.DatabaseOption((DatabaseOption.Base((src.OptionKind))))
    | :? ScriptDom.DbccNamedLiteral as src ->
      TSqlFragment.DbccNamedLiteral((src.Name), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.DbccOption as src ->
      TSqlFragment.DbccOption((src.OptionKind))
    | :? ScriptDom.DeclareTableVariableBody as src ->
      TSqlFragment.DeclareTableVariableBody((src.AsDefined), (src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DeclareVariableElement as src ->
      match src with
      | :? ScriptDom.ProcedureParameter as src->
        TSqlFragment.DeclareVariableElement((DeclareVariableElement.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | _ -> (* :? ScriptDom.DeclareVariableElement as src *)
        TSqlFragment.DeclareVariableElement((DeclareVariableElement.Base((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.DeviceInfo as src ->
      TSqlFragment.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.DialogOption as src ->
      match src with
      | :? ScriptDom.OnOffDialogOption as src->
        TSqlFragment.DialogOption((DialogOption.OnOffDialogOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.ScalarExpressionDialogOption as src->
        TSqlFragment.DialogOption((DialogOption.ScalarExpressionDialogOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
    | :? ScriptDom.DiskStatementOption as src ->
      TSqlFragment.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.DropClusteredConstraintOption as src ->
      match src with
      | :? ScriptDom.DropClusteredConstraintMoveOption as src->
        TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintMoveOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)))))
      | :? ScriptDom.DropClusteredConstraintStateOption as src->
        TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintStateOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.DropClusteredConstraintValueOption as src->
        TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintValueOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.DropClusteredConstraintWaitAtLowPriorityLockOption as src->
        TSqlFragment.DropClusteredConstraintOption((DropClusteredConstraintOption.DropClusteredConstraintWaitAtLowPriorityLockOption((src.OptionKind), (src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.DropIndexClauseBase as src ->
      match src with
      | :? ScriptDom.BackwardsCompatibleDropIndexClause as src->
        TSqlFragment.DropIndexClauseBase((DropIndexClauseBase.BackwardsCompatibleDropIndexClause((src.Index |> Option.ofObj |> Option.map (ChildObjectName.FromCs)))))
      | :? ScriptDom.DropIndexClause as src->
        TSqlFragment.DropIndexClauseBase((DropIndexClauseBase.DropIndexClause((src.Index |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (IndexOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.EncryptionSource as src ->
      match src with
      | :? ScriptDom.AssemblyEncryptionSource as src->
        TSqlFragment.EncryptionSource((EncryptionSource.AssemblyEncryptionSource((src.Assembly |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.FileEncryptionSource as src->
        TSqlFragment.EncryptionSource((EncryptionSource.FileEncryptionSource((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsExecutable))))
      | :? ScriptDom.ProviderEncryptionSource as src->
        TSqlFragment.EncryptionSource((EncryptionSource.ProviderEncryptionSource((src.KeyOptions |> Seq.map (KeyOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.EndpointAffinity as src ->
      TSqlFragment.EndpointAffinity((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.EndpointProtocolOption as src ->
      match src with
      | :? ScriptDom.AuthenticationEndpointProtocolOption as src->
        TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.AuthenticationEndpointProtocolOption((src.AuthenticationTypes), (src.Kind))))
      | :? ScriptDom.CompressionEndpointProtocolOption as src->
        TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.CompressionEndpointProtocolOption((src.IsEnabled), (src.Kind))))
      | :? ScriptDom.ListenerIPEndpointProtocolOption as src->
        TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.ListenerIPEndpointProtocolOption((src.IPv4PartOne |> Option.ofObj |> Option.map (IPv4.FromCs)), (src.IPv4PartTwo |> Option.ofObj |> Option.map (IPv4.FromCs)), (src.IPv6 |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsAll), (src.Kind))))
      | :? ScriptDom.LiteralEndpointProtocolOption as src->
        TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.LiteralEndpointProtocolOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.PortsEndpointProtocolOption as src->
        TSqlFragment.EndpointProtocolOption((EndpointProtocolOption.PortsEndpointProtocolOption((src.Kind), (src.PortTypes))))
    | :? ScriptDom.EventDeclaration as src ->
      TSqlFragment.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))
    | :? ScriptDom.EventDeclarationSetParameter as src ->
      TSqlFragment.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.EventNotificationObjectScope as src ->
      TSqlFragment.EventNotificationObjectScope((src.QueueName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Target))
    | :? ScriptDom.EventSessionObjectName as src ->
      TSqlFragment.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
    | :? ScriptDom.EventTypeGroupContainer as src ->
      match src with
      | :? ScriptDom.EventGroupContainer as src->
        TSqlFragment.EventTypeGroupContainer((EventTypeGroupContainer.EventGroupContainer((src.EventGroup))))
      | :? ScriptDom.EventTypeContainer as src->
        TSqlFragment.EventTypeGroupContainer((EventTypeGroupContainer.EventTypeContainer((src.EventType))))
    | :? ScriptDom.ExecutableEntity as src ->
      match src with
      | :? ScriptDom.ExecutableProcedureReference as src->
        TSqlFragment.ExecutableEntity((ExecutableEntity.ExecutableProcedureReference((src.AdHocDataSource |> Option.ofObj |> Option.map (AdHocDataSource.FromCs)), (src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReferenceName.FromCs)))))
      | :? ScriptDom.ExecutableStringList as src->
        TSqlFragment.ExecutableEntity((ExecutableEntity.ExecutableStringList((src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))) |> List.ofSeq), (src.Strings |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))))
    | :? ScriptDom.ExecuteAsClause as src ->
      TSqlFragment.ExecuteAsClause((src.ExecuteAsOption), (src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ExecuteContext as src ->
      TSqlFragment.ExecuteContext((src.Kind), (src.Principal |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ExecuteOption as src ->
      match src with
      | :? ScriptDom.ResultSetsExecuteOption as src->
        TSqlFragment.ExecuteOption((ExecuteOption.ResultSetsExecuteOption((src.Definitions |> Seq.map (ResultSetDefinition.FromCs) |> List.ofSeq), (src.OptionKind), (src.ResultSetsOptionKind))))
      | _ -> (* :? ScriptDom.ExecuteOption as src *)
        TSqlFragment.ExecuteOption((ExecuteOption.Base((src.OptionKind))))
    | :? ScriptDom.ExecuteParameter as src ->
      TSqlFragment.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.ExecuteSpecification as src ->
      TSqlFragment.ExecuteSpecification((src.ExecutableEntity |> Option.ofObj |> Option.map (ExecutableEntity.FromCs)), (src.ExecuteContext |> Option.ofObj |> Option.map (ExecuteContext.FromCs)), (src.LinkedServer |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.ExpressionWithSortOrder as src ->
      TSqlFragment.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SortOrder))
    | :? ScriptDom.ExternalDataSourceOption as src ->
      match src with
      | :? ScriptDom.ExternalDataSourceLiteralOrIdentifierOption as src->
        TSqlFragment.ExternalDataSourceOption((ExternalDataSourceOption.ExternalDataSourceLiteralOrIdentifierOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
    | :? ScriptDom.ExternalFileFormatOption as src ->
      match src with
      | :? ScriptDom.ExternalFileFormatContainerOption as src->
        TSqlFragment.ExternalFileFormatOption((ExternalFileFormatOption.ExternalFileFormatContainerOption((src.OptionKind), (src.Suboptions |> Seq.map (ExternalFileFormatOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ExternalFileFormatLiteralOption as src->
        TSqlFragment.ExternalFileFormatOption((ExternalFileFormatOption.ExternalFileFormatLiteralOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.ExternalFileFormatUseDefaultTypeOption as src->
        TSqlFragment.ExternalFileFormatOption((ExternalFileFormatOption.ExternalFileFormatUseDefaultTypeOption((src.ExternalFileFormatUseDefaultType), (src.OptionKind))))
    | :? ScriptDom.ExternalResourcePoolAffinitySpecification as src ->
      TSqlFragment.ExternalResourcePoolAffinitySpecification((src.AffinityType), (src.IsAuto), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)), (src.PoolAffinityRanges |> Seq.map (LiteralRange.FromCs) |> List.ofSeq))
    | :? ScriptDom.ExternalResourcePoolParameter as src ->
      TSqlFragment.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ExternalTableColumnDefinition as src ->
      TSqlFragment.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullableConstraint |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))
    | :? ScriptDom.ExternalTableDistributionPolicy as src ->
      match src with
      | :? ScriptDom.ExternalTableReplicatedDistributionPolicy as src->
        TSqlFragment.ExternalTableDistributionPolicy((ExternalTableDistributionPolicy.ExternalTableReplicatedDistributionPolicy))
      | :? ScriptDom.ExternalTableRoundRobinDistributionPolicy as src->
        TSqlFragment.ExternalTableDistributionPolicy((ExternalTableDistributionPolicy.ExternalTableRoundRobinDistributionPolicy))
      | :? ScriptDom.ExternalTableShardedDistributionPolicy as src->
        TSqlFragment.ExternalTableDistributionPolicy((ExternalTableDistributionPolicy.ExternalTableShardedDistributionPolicy((src.ShardingColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.ExternalTableOption as src ->
      match src with
      | :? ScriptDom.ExternalTableDistributionOption as src->
        TSqlFragment.ExternalTableOption((ExternalTableOption.ExternalTableDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ExternalTableDistributionPolicy.FromCs)))))
      | :? ScriptDom.ExternalTableLiteralOrIdentifierOption as src->
        TSqlFragment.ExternalTableOption((ExternalTableOption.ExternalTableLiteralOrIdentifierOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.ExternalTableRejectTypeOption as src->
        TSqlFragment.ExternalTableOption((ExternalTableOption.ExternalTableRejectTypeOption((src.OptionKind), (src.Value))))
    | :? ScriptDom.FederationScheme as src ->
      TSqlFragment.FederationScheme((src.ColumnName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FetchType as src ->
      TSqlFragment.FetchType((src.Orientation), (src.RowOffset |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.FileDeclaration as src ->
      TSqlFragment.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.FileDeclarationOption as src ->
      match src with
      | :? ScriptDom.FileGrowthFileDeclarationOption as src->
        TSqlFragment.FileDeclarationOption((FileDeclarationOption.FileGrowthFileDeclarationOption((src.GrowthIncrement |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Units))))
      | :? ScriptDom.FileNameFileDeclarationOption as src->
        TSqlFragment.FileDeclarationOption((FileDeclarationOption.FileNameFileDeclarationOption((src.OSFileName |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.MaxSizeFileDeclarationOption as src->
        TSqlFragment.FileDeclarationOption((FileDeclarationOption.MaxSizeFileDeclarationOption((src.MaxSize |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Units), (src.Unlimited))))
      | :? ScriptDom.NameFileDeclarationOption as src->
        TSqlFragment.FileDeclarationOption((FileDeclarationOption.NameFileDeclarationOption((src.IsNewName), (src.LogicalFileName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.OptionKind))))
      | :? ScriptDom.SizeFileDeclarationOption as src->
        TSqlFragment.FileDeclarationOption((FileDeclarationOption.SizeFileDeclarationOption((src.OptionKind), (src.Size |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Units))))
      | _ -> (* :? ScriptDom.FileDeclarationOption as src *)
        TSqlFragment.FileDeclarationOption((FileDeclarationOption.Base((src.OptionKind))))
    | :? ScriptDom.FileGroupDefinition as src ->
      TSqlFragment.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FileGroupOrPartitionScheme as src ->
      TSqlFragment.FileGroupOrPartitionScheme((src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PartitionSchemeColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq))
    | :? ScriptDom.ForClause as src ->
      match src with
      | :? ScriptDom.BrowseForClause as src->
        TSqlFragment.ForClause((ForClause.BrowseForClause))
      | :? ScriptDom.JsonForClause as src->
        TSqlFragment.ForClause((ForClause.JsonForClause((src.Options |> Seq.map (fun src -> JsonForClauseOption.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.JsonForClauseOption as src->
        TSqlFragment.ForClause((ForClause.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.ReadOnlyForClause as src->
        TSqlFragment.ForClause((ForClause.ReadOnlyForClause))
      | :? ScriptDom.UpdateForClause as src->
        TSqlFragment.ForClause((ForClause.UpdateForClause((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.XmlForClause as src->
        TSqlFragment.ForClause((ForClause.XmlForClause((src.Options |> Seq.map (fun src -> XmlForClauseOption.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.XmlForClauseOption as src->
        TSqlFragment.ForClause((ForClause.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.FromClause as src ->
      TSqlFragment.FromClause((src.TableReferences |> Seq.map (TableReference.FromCs) |> List.ofSeq))
    | :? ScriptDom.FullTextCatalogAndFileGroup as src ->
      TSqlFragment.FullTextCatalogAndFileGroup((src.CatalogName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroupIsFirst), (src.FileGroupName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FullTextCatalogOption as src ->
      match src with
      | :? ScriptDom.OnOffFullTextCatalogOption as src->
        TSqlFragment.FullTextCatalogOption((FullTextCatalogOption.OnOffFullTextCatalogOption((src.OptionKind), (src.OptionState))))
    | :? ScriptDom.FullTextIndexColumn as src ->
      TSqlFragment.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FullTextIndexOption as src ->
      match src with
      | :? ScriptDom.ChangeTrackingFullTextIndexOption as src->
        TSqlFragment.FullTextIndexOption((FullTextIndexOption.ChangeTrackingFullTextIndexOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.SearchPropertyListFullTextIndexOption as src->
        TSqlFragment.FullTextIndexOption((FullTextIndexOption.SearchPropertyListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.PropertyListName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.StopListFullTextIndexOption as src->
        TSqlFragment.FullTextIndexOption((FullTextIndexOption.StopListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.StopListName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.FullTextStopListAction as src ->
      TSqlFragment.FullTextStopListAction((src.IsAdd), (src.IsAll), (src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.StopWord |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.FunctionOption as src ->
      match src with
      | :? ScriptDom.ExecuteAsFunctionOption as src->
        TSqlFragment.FunctionOption((FunctionOption.ExecuteAsFunctionOption((src.ExecuteAs |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)), (src.OptionKind))))
      | :? ScriptDom.InlineFunctionOption as src->
        TSqlFragment.FunctionOption((FunctionOption.InlineFunctionOption((src.OptionKind), (src.OptionState))))
      | _ -> (* :? ScriptDom.FunctionOption as src *)
        TSqlFragment.FunctionOption((FunctionOption.Base((src.OptionKind))))
    | :? ScriptDom.FunctionReturnType as src ->
      match src with
      | :? ScriptDom.ScalarFunctionReturnType as src->
        TSqlFragment.FunctionReturnType((FunctionReturnType.ScalarFunctionReturnType((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))))
      | :? ScriptDom.SelectFunctionReturnType as src->
        TSqlFragment.FunctionReturnType((FunctionReturnType.SelectFunctionReturnType((src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)))))
      | :? ScriptDom.TableValuedFunctionReturnType as src->
        TSqlFragment.FunctionReturnType((FunctionReturnType.TableValuedFunctionReturnType((src.DeclareTableVariableBody |> Option.ofObj |> Option.map (DeclareTableVariableBody.FromCs)))))
    | :? ScriptDom.GraphConnectionBetweenNodes as src ->
      TSqlFragment.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ToNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.GridParameter as src ->
      TSqlFragment.GridParameter((src.Parameter), (src.Value))
    | :? ScriptDom.GroupByClause as src ->
      TSqlFragment.GroupByClause((src.All), (src.GroupByOption), (src.GroupingSpecifications |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))
    | :? ScriptDom.GroupingSpecification as src ->
      match src with
      | :? ScriptDom.CompositeGroupingSpecification as src->
        TSqlFragment.GroupingSpecification((GroupingSpecification.CompositeGroupingSpecification((src.Items |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CubeGroupingSpecification as src->
        TSqlFragment.GroupingSpecification((GroupingSpecification.CubeGroupingSpecification((src.Arguments |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ExpressionGroupingSpecification as src->
        TSqlFragment.GroupingSpecification((GroupingSpecification.ExpressionGroupingSpecification((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.GrandTotalGroupingSpecification as src->
        TSqlFragment.GroupingSpecification((GroupingSpecification.GrandTotalGroupingSpecification))
      | :? ScriptDom.GroupingSetsGroupingSpecification as src->
        TSqlFragment.GroupingSpecification((GroupingSpecification.GroupingSetsGroupingSpecification((src.Sets |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))))
      | :? ScriptDom.RollupGroupingSpecification as src->
        TSqlFragment.GroupingSpecification((GroupingSpecification.RollupGroupingSpecification((src.Arguments |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))))
    | :? ScriptDom.HavingClause as src ->
      TSqlFragment.HavingClause((src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.IPv4 as src ->
      TSqlFragment.IPv4((src.OctetFour |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OctetOne |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OctetThree |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OctetTwo |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.Identifier as src ->
      match src with
      | :? ScriptDom.IdentifierSnippet as src->
        TSqlFragment.Identifier((Identifier.IdentifierSnippet((src.QuoteType), (src.Script), (src.Value))))
      | :? ScriptDom.SqlCommandIdentifier as src->
        TSqlFragment.Identifier((Identifier.SqlCommandIdentifier((src.QuoteType), (src.Value))))
      | _ -> (* :? ScriptDom.Identifier as src *)
        TSqlFragment.Identifier((Identifier.Base((src.QuoteType), (src.Value))))
    | :? ScriptDom.IdentifierOrScalarExpression as src ->
      TSqlFragment.IdentifierOrScalarExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ScalarExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.IdentifierOrValueExpression as src ->
      TSqlFragment.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Value), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.IdentityOptions as src ->
      TSqlFragment.IdentityOptions((src.IdentityIncrement |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IdentitySeed |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsIdentityNotForReplication))
    | :? ScriptDom.IndexOption as src ->
      match src with
      | :? ScriptDom.CompressionDelayIndexOption as src->
        TSqlFragment.IndexOption((IndexOption.CompressionDelayIndexOption((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OptionKind), (src.TimeUnit))))
      | :? ScriptDom.DataCompressionOption as src->
        TSqlFragment.IndexOption((IndexOption.DataCompressionOption((src.CompressionLevel), (src.OptionKind), (src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.FileStreamOnDropIndexOption as src->
        TSqlFragment.IndexOption((IndexOption.FileStreamOnDropIndexOption((src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.OptionKind))))
      | :? ScriptDom.IndexExpressionOption as src->
        TSqlFragment.IndexOption((IndexOption.IndexExpressionOption((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OptionKind))))
      | :? ScriptDom.IndexStateOption as src->
        TSqlFragment.IndexOption((IndexOption.IndexStateOption((IndexStateOption.FromCs(src)))))
      | :? ScriptDom.MaxDurationOption as src->
        TSqlFragment.IndexOption((IndexOption.MaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (Option.ofNullable (src.Unit)))))
      | :? ScriptDom.MoveToDropIndexOption as src->
        TSqlFragment.IndexOption((IndexOption.MoveToDropIndexOption((src.MoveTo |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.OptionKind))))
      | :? ScriptDom.OrderIndexOption as src->
        TSqlFragment.IndexOption((IndexOption.OrderIndexOption((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.OptionKind))))
      | :? ScriptDom.WaitAtLowPriorityOption as src->
        TSqlFragment.IndexOption((IndexOption.WaitAtLowPriorityOption((src.OptionKind), (src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.IndexType as src ->
      TSqlFragment.IndexType((Option.ofNullable (src.IndexTypeKind)))
    | :? ScriptDom.InsertBulkColumnDefinition as src ->
      TSqlFragment.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullNotNull))
    | :? ScriptDom.InsertSource as src ->
      match src with
      | :? ScriptDom.ExecuteInsertSource as src->
        TSqlFragment.InsertSource((InsertSource.ExecuteInsertSource((src.Execute |> Option.ofObj |> Option.map (ExecuteSpecification.FromCs)))))
      | :? ScriptDom.SelectInsertSource as src->
        TSqlFragment.InsertSource((InsertSource.SelectInsertSource((src.Select |> Option.ofObj |> Option.map (QueryExpression.FromCs)))))
      | :? ScriptDom.ValuesInsertSource as src->
        TSqlFragment.InsertSource((InsertSource.ValuesInsertSource((src.IsDefaultValues), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))) |> List.ofSeq))))
    | :? ScriptDom.KeyOption as src ->
      match src with
      | :? ScriptDom.AlgorithmKeyOption as src->
        TSqlFragment.KeyOption((KeyOption.AlgorithmKeyOption((src.Algorithm), (src.OptionKind))))
      | :? ScriptDom.CreationDispositionKeyOption as src->
        TSqlFragment.KeyOption((KeyOption.CreationDispositionKeyOption((src.IsCreateNew), (src.OptionKind))))
      | :? ScriptDom.IdentityValueKeyOption as src->
        TSqlFragment.KeyOption((KeyOption.IdentityValueKeyOption((src.IdentityPhrase |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.KeySourceKeyOption as src->
        TSqlFragment.KeyOption((KeyOption.KeySourceKeyOption((src.OptionKind), (src.PassPhrase |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.ProviderKeyNameKeyOption as src->
        TSqlFragment.KeyOption((KeyOption.ProviderKeyNameKeyOption((src.KeyName |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
    | :? ScriptDom.LiteralRange as src ->
      match src with
      | :? ScriptDom.ProcessAffinityRange as src->
        TSqlFragment.LiteralRange((LiteralRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | _ -> (* :? ScriptDom.LiteralRange as src *)
        TSqlFragment.LiteralRange((LiteralRange.Base((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.LowPriorityLockWaitOption as src ->
      match src with
      | :? ScriptDom.LowPriorityLockWaitAbortAfterWaitOption as src->
        TSqlFragment.LowPriorityLockWaitOption((LowPriorityLockWaitOption.LowPriorityLockWaitAbortAfterWaitOption((src.AbortAfterWait), (src.OptionKind))))
      | :? ScriptDom.LowPriorityLockWaitMaxDurationOption as src->
        TSqlFragment.LowPriorityLockWaitOption((LowPriorityLockWaitOption.LowPriorityLockWaitMaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (Option.ofNullable (src.Unit)))))
    | :? ScriptDom.MergeAction as src ->
      match src with
      | :? ScriptDom.DeleteMergeAction as src->
        TSqlFragment.MergeAction((MergeAction.DeleteMergeAction))
      | :? ScriptDom.InsertMergeAction as src->
        TSqlFragment.MergeAction((MergeAction.InsertMergeAction((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.Source |> Option.ofObj |> Option.map (ValuesInsertSource.FromCs)))))
      | :? ScriptDom.UpdateMergeAction as src->
        TSqlFragment.MergeAction((MergeAction.UpdateMergeAction((src.SetClauses |> Seq.map (SetClause.FromCs) |> List.ofSeq))))
    | :? ScriptDom.MergeActionClause as src ->
      TSqlFragment.MergeActionClause((src.Action |> Option.ofObj |> Option.map (MergeAction.FromCs)), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.MethodSpecifier as src ->
      TSqlFragment.MethodSpecifier((src.AssemblyName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ClassName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.MethodName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.MirrorToClause as src ->
      TSqlFragment.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.MultiPartIdentifier as src ->
      match src with
      | :? ScriptDom.SchemaObjectName as src->
        TSqlFragment.MultiPartIdentifier((MultiPartIdentifier.SchemaObjectName((SchemaObjectName.FromCs(src)))))
      | _ -> (* :? ScriptDom.MultiPartIdentifier as src *)
        TSqlFragment.MultiPartIdentifier((MultiPartIdentifier.Base((src.Count), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))))
    | :? ScriptDom.OffsetClause as src ->
      TSqlFragment.OffsetClause((src.FetchExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OffsetExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.OnlineIndexLowPriorityLockWaitOption as src ->
      TSqlFragment.OnlineIndexLowPriorityLockWaitOption((src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.OptimizerHint as src ->
      match src with
      | :? ScriptDom.LiteralOptimizerHint as src->
        TSqlFragment.OptimizerHint((OptimizerHint.LiteralOptimizerHint((src.HintKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OptimizeForOptimizerHint as src->
        TSqlFragment.OptimizerHint((OptimizerHint.OptimizeForOptimizerHint((src.HintKind), (src.IsForUnknown), (src.Pairs |> Seq.map (fun src -> VariableValuePair.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.TableHintsOptimizerHint as src->
        TSqlFragment.OptimizerHint((OptimizerHint.TableHintsOptimizerHint((src.HintKind), (src.ObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TableHints |> Seq.map (TableHint.FromCs) |> List.ofSeq))))
      | :? ScriptDom.UseHintList as src->
        TSqlFragment.OptimizerHint((OptimizerHint.UseHintList((src.HintKind), (src.Hints |> Seq.map (fun src -> StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (src.Value))) |> List.ofSeq))))
      | _ -> (* :? ScriptDom.OptimizerHint as src *)
        TSqlFragment.OptimizerHint((OptimizerHint.Base((src.HintKind))))
    | :? ScriptDom.OptionValue as src ->
      match src with
      | :? ScriptDom.LiteralOptionValue as src->
        TSqlFragment.OptionValue((OptionValue.LiteralOptionValue((src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OnOffOptionValue as src->
        TSqlFragment.OptionValue((OptionValue.OnOffOptionValue((src.OptionState))))
    | :? ScriptDom.OrderByClause as src ->
      TSqlFragment.OrderByClause((src.OrderByElements |> Seq.map (fun src -> ExpressionWithSortOrder.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SortOrder))) |> List.ofSeq))
    | :? ScriptDom.OutputClause as src ->
      TSqlFragment.OutputClause((src.SelectColumns |> Seq.map (SelectElement.FromCs) |> List.ofSeq))
    | :? ScriptDom.OutputIntoClause as src ->
      TSqlFragment.OutputIntoClause((src.IntoTable |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.IntoTableColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.SelectColumns |> Seq.map (SelectElement.FromCs) |> List.ofSeq))
    | :? ScriptDom.OverClause as src ->
      TSqlFragment.OverClause((src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.Partitions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.WindowFrameClause |> Option.ofObj |> Option.map (WindowFrameClause.FromCs)))
    | :? ScriptDom.PartitionParameterType as src ->
      TSqlFragment.PartitionParameterType((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))
    | :? ScriptDom.PartitionSpecifications as src ->
      match src with
      | :? ScriptDom.TablePartitionOptionSpecifications as src->
        TSqlFragment.PartitionSpecifications((PartitionSpecifications.TablePartitionOptionSpecifications((src.BoundaryValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Range))))
    | :? ScriptDom.PartitionSpecifier as src ->
      TSqlFragment.PartitionSpecifier((src.All), (src.Number |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.PayloadOption as src ->
      match src with
      | :? ScriptDom.AuthenticationPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.AuthenticationPayloadOption((src.Certificate |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Kind), (src.Protocol), (src.TryCertificateFirst))))
      | :? ScriptDom.CharacterSetPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.CharacterSetPayloadOption((src.IsSql), (src.Kind))))
      | :? ScriptDom.EnabledDisabledPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.EnabledDisabledPayloadOption((src.IsEnabled), (src.Kind))))
      | :? ScriptDom.EncryptionPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.EncryptionPayloadOption((src.AlgorithmPartOne), (src.AlgorithmPartTwo), (src.EncryptionSupport), (src.Kind))))
      | :? ScriptDom.LiteralPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.LiteralPayloadOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.LoginTypePayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.LoginTypePayloadOption((src.IsWindows), (src.Kind))))
      | :? ScriptDom.RolePayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.RolePayloadOption((src.Kind), (src.Role))))
      | :? ScriptDom.SchemaPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.SchemaPayloadOption((src.IsStandard), (src.Kind))))
      | :? ScriptDom.SessionTimeoutPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.SessionTimeoutPayloadOption((src.IsNever), (src.Kind), (src.Timeout |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.SoapMethod as src->
        TSqlFragment.PayloadOption((PayloadOption.SoapMethod((src.Action), (src.Alias |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Format), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Namespace |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Schema))))
      | :? ScriptDom.WsdlPayloadOption as src->
        TSqlFragment.PayloadOption((PayloadOption.WsdlPayloadOption((src.IsNone), (src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.Permission as src ->
      TSqlFragment.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))
    | :? ScriptDom.PrincipalOption as src ->
      match src with
      | :? ScriptDom.IdentifierPrincipalOption as src->
        TSqlFragment.PrincipalOption((PrincipalOption.IdentifierPrincipalOption((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind))))
      | :? ScriptDom.LiteralPrincipalOption as src->
        TSqlFragment.PrincipalOption((PrincipalOption.LiteralPrincipalOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OnOffPrincipalOption as src->
        TSqlFragment.PrincipalOption((PrincipalOption.OnOffPrincipalOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.PasswordAlterPrincipalOption as src->
        TSqlFragment.PrincipalOption((PrincipalOption.PasswordAlterPrincipalOption((src.Hashed), (src.MustChange), (src.OldPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unlock))))
      | _ -> (* :? ScriptDom.PrincipalOption as src *)
        TSqlFragment.PrincipalOption((PrincipalOption.Base((src.OptionKind))))
    | :? ScriptDom.Privilege80 as src ->
      TSqlFragment.Privilege80((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrivilegeType80))
    | :? ScriptDom.ProcedureOption as src ->
      match src with
      | :? ScriptDom.ExecuteAsProcedureOption as src->
        TSqlFragment.ProcedureOption((ProcedureOption.ExecuteAsProcedureOption((src.ExecuteAs |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)), (src.OptionKind))))
      | _ -> (* :? ScriptDom.ProcedureOption as src *)
        TSqlFragment.ProcedureOption((ProcedureOption.Base((src.OptionKind))))
    | :? ScriptDom.ProcedureReference as src ->
      TSqlFragment.ProcedureReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Number |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ProcedureReferenceName as src ->
      TSqlFragment.ProcedureReferenceName((src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.ProcedureVariable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.QueryExpression as src ->
      match src with
      | :? ScriptDom.BinaryQueryExpression as src->
        TSqlFragment.QueryExpression((QueryExpression.BinaryQueryExpression((src.All), (src.BinaryQueryExpressionType), (src.FirstQueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)), (src.ForClause |> Option.ofObj |> Option.map (ForClause.FromCs)), (src.OffsetClause |> Option.ofObj |> Option.map (OffsetClause.FromCs)), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.SecondQueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))))
      | :? ScriptDom.QueryParenthesisExpression as src->
        TSqlFragment.QueryExpression((QueryExpression.QueryParenthesisExpression((src.ForClause |> Option.ofObj |> Option.map (ForClause.FromCs)), (src.OffsetClause |> Option.ofObj |> Option.map (OffsetClause.FromCs)), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))))
      | :? ScriptDom.QuerySpecification as src->
        TSqlFragment.QueryExpression((QueryExpression.QuerySpecification((src.ForClause |> Option.ofObj |> Option.map (ForClause.FromCs)), (src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.GroupByClause |> Option.ofObj |> Option.map (GroupByClause.FromCs)), (src.HavingClause |> Option.ofObj |> Option.map (HavingClause.FromCs)), (src.OffsetClause |> Option.ofObj |> Option.map (OffsetClause.FromCs)), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.SelectElements |> Seq.map (SelectElement.FromCs) |> List.ofSeq), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.UniqueRowFilter), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))))
    | :? ScriptDom.QueryStoreOption as src ->
      match src with
      | :? ScriptDom.QueryStoreCapturePolicyOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreCapturePolicyOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.QueryStoreDataFlushIntervalOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreDataFlushIntervalOption((src.FlushInterval |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.QueryStoreDesiredStateOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreDesiredStateOption((src.OperationModeSpecified), (src.OptionKind), (src.Value))))
      | :? ScriptDom.QueryStoreIntervalLengthOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreIntervalLengthOption((src.OptionKind), (src.StatsIntervalLength |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.QueryStoreMaxPlansPerQueryOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreMaxPlansPerQueryOption((src.MaxPlansPerQuery |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.QueryStoreMaxStorageSizeOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreMaxStorageSizeOption((src.MaxQdsSize |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.QueryStoreSizeCleanupPolicyOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreSizeCleanupPolicyOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.QueryStoreTimeCleanupPolicyOption as src->
        TSqlFragment.QueryStoreOption((QueryStoreOption.QueryStoreTimeCleanupPolicyOption((src.OptionKind), (src.StaleQueryThreshold |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.QueueOption as src ->
      match src with
      | :? ScriptDom.QueueExecuteAsOption as src->
        TSqlFragment.QueueOption((QueueOption.QueueExecuteAsOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)))))
      | :? ScriptDom.QueueProcedureOption as src->
        TSqlFragment.QueueOption((QueueOption.QueueProcedureOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.QueueStateOption as src->
        TSqlFragment.QueueOption((QueueOption.QueueStateOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.QueueValueOption as src->
        TSqlFragment.QueueOption((QueueOption.QueueValueOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | _ -> (* :? ScriptDom.QueueOption as src *)
        TSqlFragment.QueueOption((QueueOption.Base((src.OptionKind))))
    | :? ScriptDom.RemoteDataArchiveDatabaseSetting as src ->
      match src with
      | :? ScriptDom.RemoteDataArchiveDbCredentialSetting as src->
        TSqlFragment.RemoteDataArchiveDatabaseSetting((RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbCredentialSetting((src.Credential |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SettingKind))))
      | :? ScriptDom.RemoteDataArchiveDbFederatedServiceAccountSetting as src->
        TSqlFragment.RemoteDataArchiveDatabaseSetting((RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbFederatedServiceAccountSetting((src.IsOn), (src.SettingKind))))
      | :? ScriptDom.RemoteDataArchiveDbServerSetting as src->
        TSqlFragment.RemoteDataArchiveDatabaseSetting((RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbServerSetting((src.Server |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.SettingKind))))
    | :? ScriptDom.RemoteServiceBindingOption as src ->
      match src with
      | :? ScriptDom.OnOffRemoteServiceBindingOption as src->
        TSqlFragment.RemoteServiceBindingOption((RemoteServiceBindingOption.OnOffRemoteServiceBindingOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.UserRemoteServiceBindingOption as src->
        TSqlFragment.RemoteServiceBindingOption((RemoteServiceBindingOption.UserRemoteServiceBindingOption((src.OptionKind), (src.User |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.ResourcePoolAffinitySpecification as src ->
      TSqlFragment.ResourcePoolAffinitySpecification((src.AffinityType), (src.IsAuto), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)), (src.PoolAffinityRanges |> Seq.map (LiteralRange.FromCs) |> List.ofSeq))
    | :? ScriptDom.ResourcePoolParameter as src ->
      TSqlFragment.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.RestoreOption as src ->
      match src with
      | :? ScriptDom.FileStreamRestoreOption as src->
        TSqlFragment.RestoreOption((RestoreOption.FileStreamRestoreOption((src.FileStreamOption |> Option.ofObj |> Option.map (FileStreamDatabaseOption.FromCs)), (src.OptionKind))))
      | :? ScriptDom.MoveRestoreOption as src->
        TSqlFragment.RestoreOption((RestoreOption.MoveRestoreOption((src.LogicalFileName |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.OSFileName |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.OptionKind))))
      | :? ScriptDom.ScalarExpressionRestoreOption as src->
        TSqlFragment.RestoreOption((RestoreOption.ScalarExpressionRestoreOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.StopRestoreOption as src->
        TSqlFragment.RestoreOption((RestoreOption.StopRestoreOption((src.After |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.IsStopAt), (src.Mark |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.OptionKind))))
      | _ -> (* :? ScriptDom.RestoreOption as src *)
        TSqlFragment.RestoreOption((RestoreOption.Base((src.OptionKind))))
    | :? ScriptDom.ResultColumnDefinition as src ->
      TSqlFragment.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))
    | :? ScriptDom.ResultSetDefinition as src ->
      match src with
      | :? ScriptDom.InlineResultSetDefinition as src->
        TSqlFragment.ResultSetDefinition((ResultSetDefinition.InlineResultSetDefinition((src.ResultColumnDefinitions |> Seq.map (fun src -> ResultColumnDefinition.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))) |> List.ofSeq), (src.ResultSetType))))
      | :? ScriptDom.SchemaObjectResultSetDefinition as src->
        TSqlFragment.ResultSetDefinition((ResultSetDefinition.SchemaObjectResultSetDefinition((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ResultSetType))))
      | _ -> (* :? ScriptDom.ResultSetDefinition as src *)
        TSqlFragment.ResultSetDefinition((ResultSetDefinition.Base((src.ResultSetType))))
    | :? ScriptDom.RetentionPeriodDefinition as src ->
      TSqlFragment.RetentionPeriodDefinition((src.Duration |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.IsInfinity), (src.Units))
    | :? ScriptDom.RouteOption as src ->
      TSqlFragment.RouteOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.RowValue as src ->
      TSqlFragment.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.ScalarExpression as src ->
      match src with
      | :? ScriptDom.BinaryExpression as src->
        TSqlFragment.ScalarExpression((ScalarExpression.BinaryExpression((src.BinaryExpressionType), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.ExtractFromExpression as src->
        TSqlFragment.ScalarExpression((ScalarExpression.ExtractFromExpression((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.ExtractedElement |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.IdentityFunctionCall as src->
        TSqlFragment.ScalarExpression((ScalarExpression.IdentityFunctionCall((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Increment |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Seed |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.OdbcConvertSpecification as src->
        TSqlFragment.ScalarExpression((ScalarExpression.OdbcConvertSpecification((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.PrimaryExpression as src->
        TSqlFragment.ScalarExpression((ScalarExpression.PrimaryExpression((PrimaryExpression.FromCs(src)))))
      | :? ScriptDom.ScalarExpressionSnippet as src->
        TSqlFragment.ScalarExpression((ScalarExpression.ScalarExpressionSnippet((src.Script))))
      | :? ScriptDom.SourceDeclaration as src->
        TSqlFragment.ScalarExpression((ScalarExpression.SourceDeclaration((src.Value |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))))
      | :? ScriptDom.UnaryExpression as src->
        TSqlFragment.ScalarExpression((ScalarExpression.UnaryExpression((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.UnaryExpressionType))))
    | :? ScriptDom.SchemaDeclarationItem as src ->
      match src with
      | :? ScriptDom.SchemaDeclarationItemOpenjson as src->
        TSqlFragment.SchemaDeclarationItem((SchemaDeclarationItem.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | _ -> (* :? ScriptDom.SchemaDeclarationItem as src *)
        TSqlFragment.SchemaDeclarationItem((SchemaDeclarationItem.Base((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
    | :? ScriptDom.SchemaObjectNameOrValueExpression as src ->
      TSqlFragment.SchemaObjectNameOrValueExpression((src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.SearchPropertyListAction as src ->
      match src with
      | :? ScriptDom.AddSearchPropertyListAction as src->
        TSqlFragment.SearchPropertyListAction((SearchPropertyListAction.AddSearchPropertyListAction((src.Description |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Guid |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Id |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
      | :? ScriptDom.DropSearchPropertyListAction as src->
        TSqlFragment.SearchPropertyListAction((SearchPropertyListAction.DropSearchPropertyListAction((src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
    | :? ScriptDom.SecurityElement80 as src ->
      match src with
      | :? ScriptDom.CommandSecurityElement80 as src->
        TSqlFragment.SecurityElement80((SecurityElement80.CommandSecurityElement80((src.All), (src.CommandOptions))))
      | :? ScriptDom.PrivilegeSecurityElement80 as src->
        TSqlFragment.SecurityElement80((SecurityElement80.PrivilegeSecurityElement80((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Privileges |> Seq.map (fun src -> Privilege80.Privilege80((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrivilegeType80))) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.SecurityPolicyOption as src ->
      TSqlFragment.SecurityPolicyOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.SecurityPredicateAction as src ->
      TSqlFragment.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.SecurityPrincipal as src ->
      TSqlFragment.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))
    | :? ScriptDom.SecurityTargetObject as src ->
      TSqlFragment.SecurityTargetObject((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ObjectKind), (src.ObjectName |> Option.ofObj |> Option.map (SecurityTargetObjectName.FromCs)))
    | :? ScriptDom.SecurityTargetObjectName as src ->
      TSqlFragment.SecurityTargetObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
    | :? ScriptDom.SecurityUserClause80 as src ->
      TSqlFragment.SecurityUserClause80((src.UserType80), (src.Users |> Seq.map (Identifier.FromCs) |> List.ofSeq))
    | :? ScriptDom.SelectElement as src ->
      match src with
      | :? ScriptDom.SelectScalarExpression as src->
        TSqlFragment.SelectElement((SelectElement.SelectScalarExpression((src.ColumnName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.SelectSetVariable as src->
        TSqlFragment.SelectElement((SelectElement.SelectSetVariable((src.AssignmentKind), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))))
      | :? ScriptDom.SelectStarExpression as src->
        TSqlFragment.SelectElement((SelectElement.SelectStarExpression((src.Qualifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))))
    | :? ScriptDom.SelectiveXmlIndexPromotedPath as src ->
      TSqlFragment.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)), (src.SQLDataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.XQueryDataType |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.SequenceOption as src ->
      match src with
      | :? ScriptDom.DataTypeSequenceOption as src->
        TSqlFragment.SequenceOption((SequenceOption.DataTypeSequenceOption((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.NoValue), (src.OptionKind))))
      | :? ScriptDom.ScalarExpressionSequenceOption as src->
        TSqlFragment.SequenceOption((SequenceOption.ScalarExpressionSequenceOption((src.NoValue), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | _ -> (* :? ScriptDom.SequenceOption as src *)
        TSqlFragment.SequenceOption((SequenceOption.Base((src.NoValue), (src.OptionKind))))
    | :? ScriptDom.ServiceContract as src ->
      TSqlFragment.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.SessionOption as src ->
      match src with
      | :? ScriptDom.EventRetentionSessionOption as src->
        TSqlFragment.SessionOption((SessionOption.EventRetentionSessionOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.LiteralSessionOption as src->
        TSqlFragment.SessionOption((SessionOption.LiteralSessionOption((src.OptionKind), (src.Unit), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.MaxDispatchLatencySessionOption as src->
        TSqlFragment.SessionOption((SessionOption.MaxDispatchLatencySessionOption((src.IsInfinite), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.MemoryPartitionSessionOption as src->
        TSqlFragment.SessionOption((SessionOption.MemoryPartitionSessionOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.OnOffSessionOption as src->
        TSqlFragment.SessionOption((SessionOption.OnOffSessionOption((src.OptionKind), (src.OptionState))))
    | :? ScriptDom.SetClause as src ->
      match src with
      | :? ScriptDom.AssignmentSetClause as src->
        TSqlFragment.SetClause((SetClause.AssignmentSetClause((src.AssignmentKind), (src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.NewValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))))
      | :? ScriptDom.FunctionCallSetClause as src->
        TSqlFragment.SetClause((SetClause.FunctionCallSetClause((src.MutatorFunction |> Option.ofObj |> Option.map (FunctionCall.FromCs)))))
    | :? ScriptDom.SetCommand as src ->
      match src with
      | :? ScriptDom.GeneralSetCommand as src->
        TSqlFragment.SetCommand((SetCommand.GeneralSetCommand((src.CommandType), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.SetFipsFlaggerCommand as src->
        TSqlFragment.SetCommand((SetCommand.SetFipsFlaggerCommand((src.ComplianceLevel))))
    | :? ScriptDom.SpatialIndexOption as src ->
      match src with
      | :? ScriptDom.BoundingBoxSpatialIndexOption as src->
        TSqlFragment.SpatialIndexOption((SpatialIndexOption.BoundingBoxSpatialIndexOption((src.BoundingBoxParameters |> Seq.map (fun src -> BoundingBoxParameter.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.CellsPerObjectSpatialIndexOption as src->
        TSqlFragment.SpatialIndexOption((SpatialIndexOption.CellsPerObjectSpatialIndexOption((src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.GridsSpatialIndexOption as src->
        TSqlFragment.SpatialIndexOption((SpatialIndexOption.GridsSpatialIndexOption((src.GridParameters |> Seq.map (fun src -> GridParameter.GridParameter((src.Parameter), (src.Value))) |> List.ofSeq))))
      | :? ScriptDom.SpatialIndexRegularOption as src->
        TSqlFragment.SpatialIndexOption((SpatialIndexOption.SpatialIndexRegularOption((src.Option |> Option.ofObj |> Option.map (IndexOption.FromCs)))))
    | :? ScriptDom.StatementList as src ->
      match src with
      | :? ScriptDom.StatementListSnippet as src->
        TSqlFragment.StatementList((StatementList.StatementListSnippet((src.Script), (src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq))))
      | _ -> (* :? ScriptDom.StatementList as src *)
        TSqlFragment.StatementList((StatementList.Base((src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq))))
    | :? ScriptDom.StatisticsOption as src ->
      match src with
      | :? ScriptDom.LiteralStatisticsOption as src->
        TSqlFragment.StatisticsOption((StatisticsOption.LiteralStatisticsOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))))
      | :? ScriptDom.OnOffStatisticsOption as src->
        TSqlFragment.StatisticsOption((StatisticsOption.OnOffStatisticsOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.ResampleStatisticsOption as src->
        TSqlFragment.StatisticsOption((StatisticsOption.ResampleStatisticsOption((src.OptionKind), (src.Partitions |> Seq.map (fun src -> StatisticsPartitionRange.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.To |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)))) |> List.ofSeq))))
      | _ -> (* :? ScriptDom.StatisticsOption as src *)
        TSqlFragment.StatisticsOption((StatisticsOption.Base((src.OptionKind))))
    | :? ScriptDom.StatisticsPartitionRange as src ->
      TSqlFragment.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.To |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)))
    | :? ScriptDom.SystemTimePeriodDefinition as src ->
      TSqlFragment.SystemTimePeriodDefinition((src.EndTimeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StartTimeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.TSqlBatch as src ->
      TSqlFragment.TSqlBatch((src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq))
    | :? ScriptDom.TSqlFragmentSnippet as src ->
      TSqlFragment.TSqlFragmentSnippet((src.Script))
    | :? ScriptDom.TSqlScript as src ->
      TSqlFragment.TSqlScript((src.Batches |> Seq.map (fun src -> TSqlBatch.TSqlBatch((src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq))) |> List.ofSeq))
    | :? ScriptDom.TSqlStatement as src ->
      match src with
      | :? ScriptDom.AlterAsymmetricKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterAsymmetricKeyStatement((src.AttestedBy |> Option.ofObj |> Option.map (Literal.FromCs)), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterAuthorizationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterAuthorizationStatement((src.PrincipalName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)), (src.ToSchemaOwner))))
      | :? ScriptDom.AlterCreateEndpointStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterCreateEndpointStatementBase((AlterCreateEndpointStatementBase.FromCs(src)))))
      | :? ScriptDom.AlterCreateServiceStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterCreateServiceStatementBase((AlterCreateServiceStatementBase.FromCs(src)))))
      | :? ScriptDom.AlterCryptographicProviderStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Option))))
      | :? ScriptDom.AlterDatabaseScopedConfigurationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterDatabaseScopedConfigurationStatement((AlterDatabaseScopedConfigurationStatement.FromCs(src)))))
      | :? ScriptDom.AlterDatabaseStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.FromCs(src)))))
      | :? ScriptDom.AlterFederationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterFederationStatement((src.Boundary |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterFullTextIndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterFullTextIndexStatement((src.Action |> Option.ofObj |> Option.map (AlterFullTextIndexAction.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterFullTextStopListStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterFullTextStopListStatement((src.Action |> Option.ofObj |> Option.map (FullTextStopListAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterLoginStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterLoginStatement((AlterLoginStatement.FromCs(src)))))
      | :? ScriptDom.AlterPartitionFunctionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterPartitionFunctionStatement((src.Boundary |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsSplit), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterPartitionSchemeStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterPartitionSchemeStatement((src.FileGroup |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterResourceGovernorStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterResourceGovernorStatement((src.ClassifierFunction |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Command))))
      | :? ScriptDom.AlterSchemaStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterSchemaStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ObjectKind), (src.ObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterSearchPropertyListStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterSearchPropertyListStatement((src.Action |> Option.ofObj |> Option.map (SearchPropertyListAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterServerConfigurationSetBufferPoolExtensionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetBufferPoolExtensionStatement((src.Options |> Seq.map (AlterServerConfigurationBufferPoolExtensionOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.AlterServerConfigurationSetDiagnosticsLogStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetDiagnosticsLogStatement((src.Options |> Seq.map (AlterServerConfigurationDiagnosticsLogOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.AlterServerConfigurationSetFailoverClusterPropertyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetFailoverClusterPropertyStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.AlterServerConfigurationSetHadrClusterStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetHadrClusterStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.AlterServerConfigurationSetSoftNumaStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationSetSoftNumaStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.AlterServerConfigurationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServerConfigurationStatement((src.ProcessAffinity), (src.ProcessAffinityRanges |> Seq.map (fun src -> ProcessAffinityRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.AlterServiceMasterKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterServiceMasterKeyStatement((src.Account |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Kind), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.AlterTableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterTableStatement((AlterTableStatement.FromCs(src)))))
      | :? ScriptDom.AlterXmlSchemaCollectionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AlterXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.ApplicationRoleStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ApplicationRoleStatement((ApplicationRoleStatement.FromCs(src)))))
      | :? ScriptDom.AssemblyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AssemblyStatement((AssemblyStatement.FromCs(src)))))
      | :? ScriptDom.AuditSpecificationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.FromCs(src)))))
      | :? ScriptDom.AvailabilityGroupStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.AvailabilityGroupStatement((AvailabilityGroupStatement.FromCs(src)))))
      | :? ScriptDom.BackupRestoreMasterKeyStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.FromCs(src)))))
      | :? ScriptDom.BackupStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BackupStatement((BackupStatement.FromCs(src)))))
      | :? ScriptDom.BeginConversationTimerStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BeginConversationTimerStatement((src.Handle |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Timeout |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.BeginDialogStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BeginDialogStatement((src.ContractName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Handle |> Option.ofObj |> Option.map (VariableReference.FromCs)), (src.InitiatorServiceName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.InstanceSpec |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.IsConversation), (src.Options |> Seq.map (DialogOption.FromCs) |> List.ofSeq), (src.TargetServiceName |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.BeginEndBlockStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BeginEndBlockStatement((BeginEndBlockStatement.FromCs(src)))))
      | :? ScriptDom.BreakStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BreakStatement))
      | :? ScriptDom.BrokerPriorityStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BrokerPriorityStatement((BrokerPriorityStatement.FromCs(src)))))
      | :? ScriptDom.BulkInsertBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.BulkInsertBase((BulkInsertBase.FromCs(src)))))
      | :? ScriptDom.CertificateStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CertificateStatementBase((CertificateStatementBase.FromCs(src)))))
      | :? ScriptDom.CheckpointStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CheckpointStatement((src.Duration |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.CloseMasterKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CloseMasterKeyStatement))
      | :? ScriptDom.CloseSymmetricKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CloseSymmetricKeyStatement((src.All), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.ColumnEncryptionKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ColumnEncryptionKeyStatement((ColumnEncryptionKeyStatement.FromCs(src)))))
      | :? ScriptDom.ContinueStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ContinueStatement))
      | :? ScriptDom.CreateAggregateStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateAggregateStatement((src.AssemblyName |> Option.ofObj |> Option.map (AssemblyName.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))))
      | :? ScriptDom.CreateAsymmetricKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateAsymmetricKeyStatement((src.EncryptionAlgorithm), (src.KeySource |> Option.ofObj |> Option.map (EncryptionSource.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.CreateColumnMasterKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateColumnMasterKeyStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ColumnMasterKeyParameter.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateColumnStoreIndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateColumnStoreIndexStatement((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.CreateContractStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateContractStatement((src.Messages |> Seq.map (fun src -> ContractMessage.ContractMessage((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SentBy))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateCryptographicProviderStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateDatabaseStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateDatabaseStatement((src.AttachMode), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Containment |> Option.ofObj |> Option.map (ContainmentDatabaseOption.FromCs)), (src.CopyOf |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DatabaseSnapshot |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroups |> Seq.map (fun src -> FileGroupDefinition.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.LogOn |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (DatabaseOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateDefaultStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateDefaultStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.CreateEventNotificationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateEventNotificationStatement((src.BrokerInstanceSpecifier |> Option.ofObj |> Option.map (Literal.FromCs)), (src.BrokerService |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EventTypeGroups |> Seq.map (EventTypeGroupContainer.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Scope |> Option.ofObj |> Option.map (EventNotificationObjectScope.FromCs)), (src.WithFanIn))))
      | :? ScriptDom.CreateFederationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateFederationStatement((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateFullTextIndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateFullTextIndexStatement((src.CatalogAndFileGroup |> Option.ofObj |> Option.map (FullTextCatalogAndFileGroup.FromCs)), (src.FullTextIndexColumns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.KeyIndexName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FullTextIndexOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateFullTextStopListStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateFullTextStopListStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsSystemStopList), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SourceStopListName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateLoginStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateLoginStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Source |> Option.ofObj |> Option.map (CreateLoginSource.FromCs)))))
      | :? ScriptDom.CreatePartitionFunctionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreatePartitionFunctionStatement((src.BoundaryValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterType |> Option.ofObj |> Option.map (PartitionParameterType.FromCs)), (src.Range))))
      | :? ScriptDom.CreatePartitionSchemeStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreatePartitionSchemeStatement((src.FileGroups |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Value), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.IsAll), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PartitionFunction |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateRuleStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateRuleStatement((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.CreateSchemaStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateSchemaStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | :? ScriptDom.CreateSearchPropertyListStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateSearchPropertyListStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SourceSearchPropertyList |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))))
      | :? ScriptDom.CreateSpatialIndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateSpatialIndexStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.OnFileGroup |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.SpatialColumnName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SpatialIndexOptions |> Seq.map (SpatialIndexOption.FromCs) |> List.ofSeq), (src.SpatialIndexingScheme))))
      | :? ScriptDom.CreateStatisticsStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateStatisticsStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.StatisticsOptions |> Seq.map (StatisticsOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateSynonymStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateSynonymStatement((src.ForName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.CreateTableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateTableStatement((src.AsEdge), (src.AsFileTable), (src.AsNode), (src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.FederationScheme |> Option.ofObj |> Option.map (FederationScheme.FromCs)), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Options |> Seq.map (TableOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TextImageOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.CreateTypeStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateTypeStatement((CreateTypeStatement.FromCs(src)))))
      | :? ScriptDom.CreateXmlSchemaCollectionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CreateXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.CredentialStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CredentialStatement((CredentialStatement.FromCs(src)))))
      | :? ScriptDom.CursorStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.CursorStatement((CursorStatement.FromCs(src)))))
      | :? ScriptDom.DatabaseEncryptionKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DatabaseEncryptionKeyStatement((DatabaseEncryptionKeyStatement.FromCs(src)))))
      | :? ScriptDom.DbccStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DbccStatement((src.Command), (src.DllName), (src.Literals |> Seq.map (fun src -> DbccNamedLiteral.DbccNamedLiteral((src.Name), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.Options |> Seq.map (fun src -> DbccOption.DbccOption((src.OptionKind))) |> List.ofSeq), (src.OptionsUseJoin), (src.ParenthesisRequired))))
      | :? ScriptDom.DeclareCursorStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DeclareCursorStatement((src.CursorDefinition |> Option.ofObj |> Option.map (CursorDefinition.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DeclareTableVariableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DeclareTableVariableStatement((src.Body |> Option.ofObj |> Option.map (DeclareTableVariableBody.FromCs)))))
      | :? ScriptDom.DeclareVariableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DeclareVariableStatement((src.Declarations |> Seq.map (DeclareVariableElement.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DiskStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DiskStatement((src.DiskStatementType), (src.Options |> Seq.map (fun src -> DiskStatementOption.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.DropChildObjectsStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropChildObjectsStatement((DropChildObjectsStatement.FromCs(src)))))
      | :? ScriptDom.DropDatabaseEncryptionKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropDatabaseEncryptionKeyStatement))
      | :? ScriptDom.DropDatabaseStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropDatabaseStatement((src.Databases |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.IsIfExists))))
      | :? ScriptDom.DropEventNotificationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropEventNotificationStatement((src.Notifications |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Scope |> Option.ofObj |> Option.map (EventNotificationObjectScope.FromCs)))))
      | :? ScriptDom.DropFullTextIndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropFullTextIndexStatement((src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.DropIndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropIndexStatement((src.DropIndexClauses |> Seq.map (DropIndexClauseBase.FromCs) |> List.ofSeq), (src.IsIfExists))))
      | :? ScriptDom.DropMasterKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropMasterKeyStatement))
      | :? ScriptDom.DropObjectsStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropObjectsStatement((DropObjectsStatement.FromCs(src)))))
      | :? ScriptDom.DropQueueStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropQueueStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.DropSchemaStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropSchemaStatement((src.DropBehavior), (src.IsIfExists), (src.Schema |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.DropTypeStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropTypeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.DropUnownedObjectStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.FromCs(src)))))
      | :? ScriptDom.DropXmlSchemaCollectionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.DropXmlSchemaCollectionStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.EnableDisableTriggerStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.EnableDisableTriggerStatement((src.All), (src.TriggerEnforcement), (src.TriggerNames |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)))))
      | :? ScriptDom.EndConversationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.EndConversationStatement((src.Conversation |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.ErrorCode |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.ErrorDescription |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.WithCleanup))))
      | :? ScriptDom.EventSessionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.EventSessionStatement((EventSessionStatement.FromCs(src)))))
      | :? ScriptDom.ExecuteAsStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ExecuteAsStatement((src.Cookie |> Option.ofObj |> Option.map (VariableReference.FromCs)), (src.ExecuteContext |> Option.ofObj |> Option.map (ExecuteContext.FromCs)), (src.WithNoRevert))))
      | :? ScriptDom.ExecuteStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ExecuteStatement((src.ExecuteSpecification |> Option.ofObj |> Option.map (ExecuteSpecification.FromCs)), (src.Options |> Seq.map (ExecuteOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ExternalDataSourceStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ExternalDataSourceStatement((ExternalDataSourceStatement.FromCs(src)))))
      | :? ScriptDom.ExternalFileFormatStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ExternalFileFormatStatement((ExternalFileFormatStatement.FromCs(src)))))
      | :? ScriptDom.ExternalResourcePoolStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.FromCs(src)))))
      | :? ScriptDom.ExternalTableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ExternalTableStatement((ExternalTableStatement.FromCs(src)))))
      | :? ScriptDom.FullTextCatalogStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.FullTextCatalogStatement((FullTextCatalogStatement.FromCs(src)))))
      | :? ScriptDom.GoToStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.GoToStatement((src.LabelName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.IfStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.IfStatement((src.ElseStatement |> Option.ofObj |> Option.map (TSqlStatement.FromCs)), (src.Predicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.ThenStatement |> Option.ofObj |> Option.map (TSqlStatement.FromCs)))))
      | :? ScriptDom.IndexDefinition as src->
        TSqlFragment.TSqlStatement((TSqlStatement.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Unique))))
      | :? ScriptDom.IndexStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.IndexStatement((IndexStatement.FromCs(src)))))
      | :? ScriptDom.KillQueryNotificationSubscriptionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.KillQueryNotificationSubscriptionStatement((src.All), (src.SubscriptionId |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.KillStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.KillStatement((src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WithStatusOnly))))
      | :? ScriptDom.KillStatsJobStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.KillStatsJobStatement((src.JobId |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.LabelStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.LabelStatement((src.Value))))
      | :? ScriptDom.LineNoStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.LineNoStatement((src.LineNo |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)))))
      | :? ScriptDom.MasterKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.MasterKeyStatement((MasterKeyStatement.FromCs(src)))))
      | :? ScriptDom.MessageTypeStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.MessageTypeStatementBase((MessageTypeStatementBase.FromCs(src)))))
      | :? ScriptDom.MoveConversationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.MoveConversationStatement((src.Conversation |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Group |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.OpenMasterKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.OpenMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.OpenSymmetricKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.OpenSymmetricKeyStatement((src.DecryptionMechanism |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.PrintStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.PrintStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.ProcedureStatementBodyBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ProcedureStatementBodyBase((ProcedureStatementBodyBase.FromCs(src)))))
      | :? ScriptDom.QueueStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.QueueStatement((QueueStatement.FromCs(src)))))
      | :? ScriptDom.RaiseErrorLegacyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RaiseErrorLegacyStatement((src.FirstParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondParameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.RaiseErrorStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RaiseErrorStatement((src.FirstParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OptionalParameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.RaiseErrorOptions), (src.SecondParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.ThirdParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.ReadTextStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ReadTextStatement((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.HoldLock), (src.Offset |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Size |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TextPointer |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.ReconfigureStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ReconfigureStatement((src.WithOverride))))
      | :? ScriptDom.RemoteServiceBindingStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RemoteServiceBindingStatementBase((RemoteServiceBindingStatementBase.FromCs(src)))))
      | :? ScriptDom.ResourcePoolStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.FromCs(src)))))
      | :? ScriptDom.RestoreStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RestoreStatement((src.DatabaseName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Kind), (src.Options |> Seq.map (RestoreOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ReturnStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ReturnStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.RevertStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RevertStatement((src.Cookie |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.RoleStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RoleStatement((RoleStatement.FromCs(src)))))
      | :? ScriptDom.RouteStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.RouteStatement((RouteStatement.FromCs(src)))))
      | :? ScriptDom.SecurityPolicyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SecurityPolicyStatement((SecurityPolicyStatement.FromCs(src)))))
      | :? ScriptDom.SecurityStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SecurityStatement((SecurityStatement.FromCs(src)))))
      | :? ScriptDom.SecurityStatementBody80 as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.FromCs(src)))))
      | :? ScriptDom.SendStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SendStatement((src.ConversationHandles |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.MessageBody |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.MessageTypeName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.SequenceStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SequenceStatement((SequenceStatement.FromCs(src)))))
      | :? ScriptDom.ServerAuditStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ServerAuditStatement((ServerAuditStatement.FromCs(src)))))
      | :? ScriptDom.SetCommandStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetCommandStatement((src.Commands |> Seq.map (SetCommand.FromCs) |> List.ofSeq))))
      | :? ScriptDom.SetErrorLevelStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetErrorLevelStatement((src.Level |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.SetOnOffStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetOnOffStatement((SetOnOffStatement.FromCs(src)))))
      | :? ScriptDom.SetRowCountStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetRowCountStatement((src.NumberRows |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.SetTextSizeStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetTextSizeStatement((src.TextSize |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.SetTransactionIsolationLevelStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetTransactionIsolationLevelStatement((src.Level))))
      | :? ScriptDom.SetUserStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetUserStatement((src.UserName |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.WithNoReset))))
      | :? ScriptDom.SetVariableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SetVariableStatement((src.AssignmentKind), (src.CursorDefinition |> Option.ofObj |> Option.map (CursorDefinition.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FunctionCallExists), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.SeparatorType), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))))
      | :? ScriptDom.ShutdownStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ShutdownStatement((src.WithNoWait))))
      | :? ScriptDom.SignatureStatementBase as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SignatureStatementBase((SignatureStatementBase.FromCs(src)))))
      | :? ScriptDom.StatementWithCtesAndXmlNamespaces as src->
        TSqlFragment.TSqlStatement((TSqlStatement.StatementWithCtesAndXmlNamespaces((StatementWithCtesAndXmlNamespaces.FromCs(src)))))
      | :? ScriptDom.SymmetricKeyStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.SymmetricKeyStatement((SymmetricKeyStatement.FromCs(src)))))
      | :? ScriptDom.TSqlStatementSnippet as src->
        TSqlFragment.TSqlStatement((TSqlStatement.TSqlStatementSnippet((src.Script))))
      | :? ScriptDom.TextModificationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.TextModificationStatement((TextModificationStatement.FromCs(src)))))
      | :? ScriptDom.ThrowStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ThrowStatement((src.ErrorNumber |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Message |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.State |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.TransactionStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.TransactionStatement((TransactionStatement.FromCs(src)))))
      | :? ScriptDom.TriggerStatementBody as src->
        TSqlFragment.TSqlStatement((TSqlStatement.TriggerStatementBody((TriggerStatementBody.FromCs(src)))))
      | :? ScriptDom.TruncateTableStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.TruncateTableStatement((src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.TryCatchStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.TryCatchStatement((src.CatchStatements |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TryStatements |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | :? ScriptDom.UpdateStatisticsStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.UpdateStatisticsStatement((src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.StatisticsOptions |> Seq.map (StatisticsOption.FromCs) |> List.ofSeq), (src.SubElements |> Seq.map (Identifier.FromCs) |> List.ofSeq))))
      | :? ScriptDom.UseFederationStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.UseFederationStatement((src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FederationName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Filtering), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.UseStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.UseStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.UserStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.UserStatement((UserStatement.FromCs(src)))))
      | :? ScriptDom.ViewStatementBody as src->
        TSqlFragment.TSqlStatement((TSqlStatement.ViewStatementBody((ViewStatementBody.FromCs(src)))))
      | :? ScriptDom.WaitForStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.WaitForStatement((src.Parameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Statement |> Option.ofObj |> Option.map (WaitForSupportedStatement.FromCs)), (src.Timeout |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WaitForOption))))
      | :? ScriptDom.WaitForSupportedStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.WaitForSupportedStatement((WaitForSupportedStatement.FromCs(src)))))
      | :? ScriptDom.WhileStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.WhileStatement((src.Predicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.Statement |> Option.ofObj |> Option.map (TSqlStatement.FromCs)))))
      | :? ScriptDom.WorkloadGroupStatement as src->
        TSqlFragment.TSqlStatement((TSqlStatement.WorkloadGroupStatement((WorkloadGroupStatement.FromCs(src)))))
    | :? ScriptDom.TableDefinition as src ->
      TSqlFragment.TableDefinition((src.ColumnDefinitions |> Seq.map (fun src -> ColumnDefinition.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Constraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DefaultConstraint |> Option.ofObj |> Option.map (DefaultConstraintDefinition.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (IdentityOptions.FromCs)), (src.Index |> Option.ofObj |> Option.map (IndexDefinition.FromCs)), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))) |> List.ofSeq), (src.Indexes |> Seq.map (fun src -> IndexDefinition.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Unique))) |> List.ofSeq), (src.SystemTimePeriod |> Option.ofObj |> Option.map (SystemTimePeriodDefinition.FromCs)), (src.TableConstraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq))
    | :? ScriptDom.TableDistributionPolicy as src ->
      match src with
      | :? ScriptDom.TableHashDistributionPolicy as src->
        TSqlFragment.TableDistributionPolicy((TableDistributionPolicy.TableHashDistributionPolicy((src.DistributionColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.TableReplicateDistributionPolicy as src->
        TSqlFragment.TableDistributionPolicy((TableDistributionPolicy.TableReplicateDistributionPolicy))
      | :? ScriptDom.TableRoundRobinDistributionPolicy as src->
        TSqlFragment.TableDistributionPolicy((TableDistributionPolicy.TableRoundRobinDistributionPolicy))
    | :? ScriptDom.TableHint as src ->
      match src with
      | :? ScriptDom.ForceSeekTableHint as src->
        TSqlFragment.TableHint((TableHint.ForceSeekTableHint((src.ColumnValues |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.HintKind), (src.IndexValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.IndexTableHint as src->
        TSqlFragment.TableHint((TableHint.IndexTableHint((src.HintKind), (src.IndexValues |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Value), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.LiteralTableHint as src->
        TSqlFragment.TableHint((TableHint.LiteralTableHint((src.HintKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | _ -> (* :? ScriptDom.TableHint as src *)
        TSqlFragment.TableHint((TableHint.Base((src.HintKind))))
    | :? ScriptDom.TableIndexType as src ->
      match src with
      | :? ScriptDom.TableClusteredIndexType as src->
        TSqlFragment.TableIndexType((TableIndexType.TableClusteredIndexType((src.ColumnStore), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq))))
      | :? ScriptDom.TableNonClusteredIndexType as src->
        TSqlFragment.TableIndexType((TableIndexType.TableNonClusteredIndexType))
    | :? ScriptDom.TableOption as src ->
      match src with
      | :? ScriptDom.DurabilityTableOption as src->
        TSqlFragment.TableOption((TableOption.DurabilityTableOption((src.DurabilityTableOptionKind), (src.OptionKind))))
      | :? ScriptDom.FileStreamOnTableOption as src->
        TSqlFragment.TableOption((TableOption.FileStreamOnTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.FileTableCollateFileNameTableOption as src->
        TSqlFragment.TableOption((TableOption.FileTableCollateFileNameTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.FileTableConstraintNameTableOption as src->
        TSqlFragment.TableOption((TableOption.FileTableConstraintNameTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.FileTableDirectoryTableOption as src->
        TSqlFragment.TableOption((TableOption.FileTableDirectoryTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.LockEscalationTableOption as src->
        TSqlFragment.TableOption((TableOption.LockEscalationTableOption((src.OptionKind), (src.Value))))
      | :? ScriptDom.MemoryOptimizedTableOption as src->
        TSqlFragment.TableOption((TableOption.MemoryOptimizedTableOption((src.OptionKind), (src.OptionState))))
      | :? ScriptDom.RemoteDataArchiveAlterTableOption as src->
        TSqlFragment.TableOption((TableOption.RemoteDataArchiveAlterTableOption((src.FilterPredicate |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.IsFilterPredicateSpecified), (src.IsMigrationStateSpecified), (src.MigrationState), (src.OptionKind), (src.RdaTableOption))))
      | :? ScriptDom.RemoteDataArchiveTableOption as src->
        TSqlFragment.TableOption((TableOption.RemoteDataArchiveTableOption((src.MigrationState), (src.OptionKind), (src.RdaTableOption))))
      | :? ScriptDom.SystemVersioningTableOption as src->
        TSqlFragment.TableOption((TableOption.SystemVersioningTableOption((src.ConsistencyCheckEnabled), (src.HistoryTable |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.OptionKind), (src.OptionState), (src.RetentionPeriod |> Option.ofObj |> Option.map (RetentionPeriodDefinition.FromCs)))))
      | :? ScriptDom.TableDataCompressionOption as src->
        TSqlFragment.TableOption((TableOption.TableDataCompressionOption((src.DataCompressionOption |> Option.ofObj |> Option.map (DataCompressionOption.FromCs)), (src.OptionKind))))
      | :? ScriptDom.TableDistributionOption as src->
        TSqlFragment.TableOption((TableOption.TableDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (TableDistributionPolicy.FromCs)))))
      | :? ScriptDom.TableIndexOption as src->
        TSqlFragment.TableOption((TableOption.TableIndexOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (TableIndexType.FromCs)))))
      | :? ScriptDom.TablePartitionOption as src->
        TSqlFragment.TableOption((TableOption.TablePartitionOption((src.OptionKind), (src.PartitionColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PartitionOptionSpecs |> Option.ofObj |> Option.map (TablePartitionOptionSpecifications.FromCs)))))
    | :? ScriptDom.TableReference as src ->
      match src with
      | :? ScriptDom.JoinParenthesisTableReference as src->
        TSqlFragment.TableReference((TableReference.JoinParenthesisTableReference((src.Join |> Option.ofObj |> Option.map (TableReference.FromCs)))))
      | :? ScriptDom.JoinTableReference as src->
        TSqlFragment.TableReference((TableReference.JoinTableReference((JoinTableReference.FromCs(src)))))
      | :? ScriptDom.OdbcQualifiedJoinTableReference as src->
        TSqlFragment.TableReference((TableReference.OdbcQualifiedJoinTableReference((src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)))))
      | :? ScriptDom.TableReferenceWithAlias as src->
        TSqlFragment.TableReference((TableReference.TableReferenceWithAlias((TableReferenceWithAlias.FromCs(src)))))
    | :? ScriptDom.TableSampleClause as src ->
      TSqlFragment.TableSampleClause((src.RepeatSeed |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SampleNumber |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.System), (src.TableSampleClauseOption))
    | :? ScriptDom.TableSwitchOption as src ->
      match src with
      | :? ScriptDom.LowPriorityLockWaitTableSwitchOption as src->
        TSqlFragment.TableSwitchOption((TableSwitchOption.LowPriorityLockWaitTableSwitchOption((src.OptionKind), (src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.TargetDeclaration as src ->
      TSqlFragment.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.TemporalClause as src ->
      TSqlFragment.TemporalClause((src.EndTime |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.StartTime |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TemporalClauseType))
    | :? ScriptDom.TopRowFilter as src ->
      TSqlFragment.TopRowFilter((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Percent), (src.WithTies))
    | :? ScriptDom.TriggerAction as src ->
      TSqlFragment.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))
    | :? ScriptDom.TriggerObject as src ->
      TSqlFragment.TriggerObject((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TriggerScope))
    | :? ScriptDom.TriggerOption as src ->
      match src with
      | :? ScriptDom.ExecuteAsTriggerOption as src->
        TSqlFragment.TriggerOption((TriggerOption.ExecuteAsTriggerOption((src.ExecuteAsClause |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)), (src.OptionKind))))
      | _ -> (* :? ScriptDom.TriggerOption as src *)
        TSqlFragment.TriggerOption((TriggerOption.Base((src.OptionKind))))
    | :? ScriptDom.UserLoginOption as src ->
      TSqlFragment.UserLoginOption((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UserLoginOptionType))
    | :? ScriptDom.VariableValuePair as src ->
      TSqlFragment.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.ViewOption as src ->
      TSqlFragment.ViewOption((src.OptionKind))
    | :? ScriptDom.WhenClause as src ->
      match src with
      | :? ScriptDom.SearchedWhenClause as src->
        TSqlFragment.WhenClause((WhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))))
      | :? ScriptDom.SimpleWhenClause as src->
        TSqlFragment.WhenClause((WhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
    | :? ScriptDom.WhereClause as src ->
      TSqlFragment.WhereClause((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.WindowDelimiter as src ->
      TSqlFragment.WindowDelimiter((src.OffsetValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WindowDelimiterType))
    | :? ScriptDom.WindowFrameClause as src ->
      TSqlFragment.WindowFrameClause((src.Bottom |> Option.ofObj |> Option.map (WindowDelimiter.FromCs)), (src.Top |> Option.ofObj |> Option.map (WindowDelimiter.FromCs)), (src.WindowFrameType))
    | :? ScriptDom.WithCtesAndXmlNamespaces as src ->
      TSqlFragment.WithCtesAndXmlNamespaces((src.ChangeTrackingContext |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.CommonTableExpressions |> Seq.map (fun src -> CommonTableExpression.CommonTableExpression((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))) |> List.ofSeq), (src.XmlNamespaces |> Option.ofObj |> Option.map (XmlNamespaces.FromCs)))
    | :? ScriptDom.WithinGroupClause as src ->
      TSqlFragment.WithinGroupClause((src.HasGraphPath), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)))
    | :? ScriptDom.WorkloadGroupParameter as src ->
      match src with
      | :? ScriptDom.WorkloadGroupImportanceParameter as src->
        TSqlFragment.WorkloadGroupParameter((WorkloadGroupParameter.WorkloadGroupImportanceParameter((src.ParameterType), (src.ParameterValue))))
      | :? ScriptDom.WorkloadGroupResourceParameter as src->
        TSqlFragment.WorkloadGroupParameter((WorkloadGroupParameter.WorkloadGroupResourceParameter((src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.XmlNamespaces as src ->
      TSqlFragment.XmlNamespaces((src.XmlNamespacesElements |> Seq.map (XmlNamespacesElement.FromCs) |> List.ofSeq))
    | :? ScriptDom.XmlNamespacesElement as src ->
      match src with
      | :? ScriptDom.XmlNamespacesAliasElement as src->
        TSqlFragment.XmlNamespacesElement((XmlNamespacesElement.XmlNamespacesAliasElement((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.String |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
      | :? ScriptDom.XmlNamespacesDefaultElement as src->
        TSqlFragment.XmlNamespacesElement((XmlNamespacesElement.XmlNamespacesDefaultElement((src.String |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
and AlterAvailabilityGroupAction = (* IsAbstract = false , children = 1*)
  | Base of actionType:ScriptDom.AlterAvailabilityGroupActionType
  | AlterAvailabilityGroupFailoverAction of actionType:ScriptDom.AlterAvailabilityGroupActionType * options:(AlterAvailabilityGroupFailoverOption) list
  member this.ToCs() : ScriptDom.AlterAvailabilityGroupAction =
    match this with
    | AlterAvailabilityGroupFailoverAction(actionType=aActionType; options=aOptions) ->
      let ret = ScriptDom.AlterAvailabilityGroupFailoverAction()
      ret.ActionType <- aActionType
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.AlterAvailabilityGroupAction (* 404 *)
    | Base(actionType=aActionType) ->

      let ret = ScriptDom.AlterAvailabilityGroupAction()
      ret.ActionType <- aActionType
      ret
//// shared props AlterAvailabilityGroupAction 
  member this.ActionType = 
    match this with
    | Base (actionType=actionType) -> actionType
    | AlterAvailabilityGroupFailoverAction(actionType=actionType) -> actionType
  static member FromCs(src:ScriptDom.AlterAvailabilityGroupAction) : AlterAvailabilityGroupAction =
    match src with
    | :? ScriptDom.AlterAvailabilityGroupFailoverAction as src ->
      AlterAvailabilityGroupAction.AlterAvailabilityGroupFailoverAction((src.ActionType), (src.Options |> Seq.map (fun src -> AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))
    | _ -> (* :? ScriptDom.AlterAvailabilityGroupAction as src *)
      AlterAvailabilityGroupAction.Base(((src.ActionType)))
and AlterFullTextIndexAction = (* IsAbstract = true , children = 6*)
  | AddAlterFullTextIndexAction of columns:(FullTextIndexColumn) list * withNoPopulation:bool
  | AlterColumnAlterFullTextIndexAction of column:FullTextIndexColumn option * withNoPopulation:bool
  | DropAlterFullTextIndexAction of columns:(Identifier) list * withNoPopulation:bool
  | SetSearchPropertyListAlterFullTextIndexAction of searchPropertyListOption:SearchPropertyListFullTextIndexOption option * withNoPopulation:bool
  | SetStopListAlterFullTextIndexAction of stopListOption:StopListFullTextIndexOption option * withNoPopulation:bool
  | SimpleAlterFullTextIndexAction of actionKind:ScriptDom.SimpleAlterFullTextIndexActionKind
  member this.ToCs() : ScriptDom.AlterFullTextIndexAction =
    match this with
    | AddAlterFullTextIndexAction(columns=aColumns; withNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.AddAlterFullTextIndexAction()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 404 *)
    | AlterColumnAlterFullTextIndexAction(column=aColumn; withNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.AlterColumnAlterFullTextIndexAction()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 404 *)
    | DropAlterFullTextIndexAction(columns=aColumns; withNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.DropAlterFullTextIndexAction()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 404 *)
    | SetSearchPropertyListAlterFullTextIndexAction(searchPropertyListOption=aSearchPropertyListOption; withNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.SetSearchPropertyListAlterFullTextIndexAction()
      ret.SearchPropertyListOption <- aSearchPropertyListOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 404 *)
    | SetStopListAlterFullTextIndexAction(stopListOption=aStopListOption; withNoPopulation=aWithNoPopulation) ->
      let ret = ScriptDom.SetStopListAlterFullTextIndexAction()
      ret.StopListOption <- aStopListOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoPopulation <- aWithNoPopulation
      ret :> ScriptDom.AlterFullTextIndexAction (* 404 *)
    | SimpleAlterFullTextIndexAction(actionKind=aActionKind) ->
      let ret = ScriptDom.SimpleAlterFullTextIndexAction()
      ret.ActionKind <- aActionKind
      ret :> ScriptDom.AlterFullTextIndexAction (* 404 *)
  static member FromCs(src:ScriptDom.AlterFullTextIndexAction) : AlterFullTextIndexAction =
    match src with
    | :? ScriptDom.AddAlterFullTextIndexAction as src ->
      AlterFullTextIndexAction.AddAlterFullTextIndexAction((src.Columns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.WithNoPopulation))
    | :? ScriptDom.AlterColumnAlterFullTextIndexAction as src ->
      AlterFullTextIndexAction.AlterColumnAlterFullTextIndexAction((src.Column |> Option.ofObj |> Option.map (FullTextIndexColumn.FromCs)), (src.WithNoPopulation))
    | :? ScriptDom.DropAlterFullTextIndexAction as src ->
      AlterFullTextIndexAction.DropAlterFullTextIndexAction((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.WithNoPopulation))
    | :? ScriptDom.SetSearchPropertyListAlterFullTextIndexAction as src ->
      AlterFullTextIndexAction.SetSearchPropertyListAlterFullTextIndexAction((src.SearchPropertyListOption |> Option.ofObj |> Option.map (SearchPropertyListFullTextIndexOption.FromCs)), (src.WithNoPopulation))
    | :? ScriptDom.SetStopListAlterFullTextIndexAction as src ->
      AlterFullTextIndexAction.SetStopListAlterFullTextIndexAction((src.StopListOption |> Option.ofObj |> Option.map (StopListFullTextIndexOption.FromCs)), (src.WithNoPopulation))
    | :? ScriptDom.SimpleAlterFullTextIndexAction as src ->
      AlterFullTextIndexAction.SimpleAlterFullTextIndexAction((src.ActionKind))
and AlterRoleAction = (* IsAbstract = true , children = 3*)
  | AddMemberAlterRoleAction of member_:Identifier option
  | DropMemberAlterRoleAction of member_:Identifier option
  | RenameAlterRoleAction of newName:Identifier option
  member this.ToCs() : ScriptDom.AlterRoleAction =
    match this with
    | AddMemberAlterRoleAction(member_=aMember) ->
      let ret = ScriptDom.AddMemberAlterRoleAction()
      ret.Member <- aMember |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleAction (* 404 *)
    | DropMemberAlterRoleAction(member_=aMember) ->
      let ret = ScriptDom.DropMemberAlterRoleAction()
      ret.Member <- aMember |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleAction (* 404 *)
    | RenameAlterRoleAction(newName=aNewName) ->
      let ret = ScriptDom.RenameAlterRoleAction()
      ret.NewName <- aNewName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleAction (* 404 *)
  static member FromCs(src:ScriptDom.AlterRoleAction) : AlterRoleAction =
    match src with
    | :? ScriptDom.AddMemberAlterRoleAction as src ->
      AlterRoleAction.AddMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropMemberAlterRoleAction as src ->
      AlterRoleAction.DropMemberAlterRoleAction((src.Member |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.RenameAlterRoleAction as src ->
      AlterRoleAction.RenameAlterRoleAction((src.NewName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and AlterServerConfigurationBufferPoolExtensionOption = (* IsAbstract = false , children = 2*)
  | Base of optionKind:ScriptDom.AlterServerConfigurationBufferPoolExtensionOptionKind * optionValue:OptionValue option
  | AlterServerConfigurationBufferPoolExtensionContainerOption of optionKind:ScriptDom.AlterServerConfigurationBufferPoolExtensionOptionKind * optionValue:OptionValue option * suboptions:(AlterServerConfigurationBufferPoolExtensionOption) list
  | AlterServerConfigurationBufferPoolExtensionSizeOption of optionKind:ScriptDom.AlterServerConfigurationBufferPoolExtensionOptionKind * optionValue:OptionValue option * sizeUnit:ScriptDom.MemoryUnit
  member this.ToCs() : ScriptDom.AlterServerConfigurationBufferPoolExtensionOption =
    match this with
    | AlterServerConfigurationBufferPoolExtensionContainerOption(optionKind=aOptionKind; optionValue=aOptionValue; suboptions=aSuboptions) ->
      let ret = ScriptDom.AlterServerConfigurationBufferPoolExtensionContainerOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSuboptions do ret.Suboptions.Add (e.ToCs())
      ret :> ScriptDom.AlterServerConfigurationBufferPoolExtensionOption (* 404 *)
    | AlterServerConfigurationBufferPoolExtensionSizeOption(optionKind=aOptionKind; optionValue=aOptionValue; sizeUnit=aSizeUnit) ->
      let ret = ScriptDom.AlterServerConfigurationBufferPoolExtensionSizeOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SizeUnit <- aSizeUnit
      ret :> ScriptDom.AlterServerConfigurationBufferPoolExtensionOption (* 404 *)
    | Base(optionKind=aOptionKind; optionValue=aOptionValue) ->

      let ret = ScriptDom.AlterServerConfigurationBufferPoolExtensionOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props AlterServerConfigurationBufferPoolExtensionOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | AlterServerConfigurationBufferPoolExtensionContainerOption(optionKind=optionKind) -> optionKind
    | AlterServerConfigurationBufferPoolExtensionSizeOption(optionKind=optionKind) -> optionKind
  member this.OptionValue = 
    match this with
    | Base (optionValue=optionValue) -> optionValue
    | AlterServerConfigurationBufferPoolExtensionContainerOption(optionValue=optionValue) -> optionValue
    | AlterServerConfigurationBufferPoolExtensionSizeOption(optionValue=optionValue) -> optionValue
  static member FromCs(src:ScriptDom.AlterServerConfigurationBufferPoolExtensionOption) : AlterServerConfigurationBufferPoolExtensionOption =
    match src with
    | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionContainerOption as src ->
      AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionContainerOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)), (src.Suboptions |> Seq.map (AlterServerConfigurationBufferPoolExtensionOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.AlterServerConfigurationBufferPoolExtensionSizeOption as src ->
      AlterServerConfigurationBufferPoolExtensionOption.AlterServerConfigurationBufferPoolExtensionSizeOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)), (src.SizeUnit))
    | _ -> (* :? ScriptDom.AlterServerConfigurationBufferPoolExtensionOption as src *)
      AlterServerConfigurationBufferPoolExtensionOption.Base(((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs))))
and AlterServerConfigurationDiagnosticsLogOption = (* IsAbstract = false , children = 1*)
  | Base of optionKind:ScriptDom.AlterServerConfigurationDiagnosticsLogOptionKind * optionValue:OptionValue option
  | AlterServerConfigurationDiagnosticsLogMaxSizeOption of optionKind:ScriptDom.AlterServerConfigurationDiagnosticsLogOptionKind * optionValue:OptionValue option * sizeUnit:ScriptDom.MemoryUnit
  member this.ToCs() : ScriptDom.AlterServerConfigurationDiagnosticsLogOption =
    match this with
    | AlterServerConfigurationDiagnosticsLogMaxSizeOption(optionKind=aOptionKind; optionValue=aOptionValue; sizeUnit=aSizeUnit) ->
      let ret = ScriptDom.AlterServerConfigurationDiagnosticsLogMaxSizeOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SizeUnit <- aSizeUnit
      ret :> ScriptDom.AlterServerConfigurationDiagnosticsLogOption (* 404 *)
    | Base(optionKind=aOptionKind; optionValue=aOptionValue) ->

      let ret = ScriptDom.AlterServerConfigurationDiagnosticsLogOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props AlterServerConfigurationDiagnosticsLogOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | AlterServerConfigurationDiagnosticsLogMaxSizeOption(optionKind=optionKind) -> optionKind
  member this.OptionValue = 
    match this with
    | Base (optionValue=optionValue) -> optionValue
    | AlterServerConfigurationDiagnosticsLogMaxSizeOption(optionValue=optionValue) -> optionValue
  static member FromCs(src:ScriptDom.AlterServerConfigurationDiagnosticsLogOption) : AlterServerConfigurationDiagnosticsLogOption =
    match src with
    | :? ScriptDom.AlterServerConfigurationDiagnosticsLogMaxSizeOption as src ->
      AlterServerConfigurationDiagnosticsLogOption.AlterServerConfigurationDiagnosticsLogMaxSizeOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)), (src.SizeUnit))
    | _ -> (* :? ScriptDom.AlterServerConfigurationDiagnosticsLogOption as src *)
      AlterServerConfigurationDiagnosticsLogOption.Base(((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs))))
and AssemblyOption = (* IsAbstract = false , children = 2*)
  | Base of optionKind:ScriptDom.AssemblyOptionKind
  | OnOffAssemblyOption of optionKind:ScriptDom.AssemblyOptionKind * optionState:ScriptDom.OptionState
  | PermissionSetAssemblyOption of optionKind:ScriptDom.AssemblyOptionKind * permissionSetOption:ScriptDom.PermissionSetOption
  member this.ToCs() : ScriptDom.AssemblyOption =
    match this with
    | OnOffAssemblyOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffAssemblyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.AssemblyOption (* 404 *)
    | PermissionSetAssemblyOption(optionKind=aOptionKind; permissionSetOption=aPermissionSetOption) ->
      let ret = ScriptDom.PermissionSetAssemblyOption()
      ret.OptionKind <- aOptionKind
      ret.PermissionSetOption <- aPermissionSetOption
      ret :> ScriptDom.AssemblyOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.AssemblyOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props AssemblyOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | OnOffAssemblyOption(optionKind=optionKind) -> optionKind
    | PermissionSetAssemblyOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.AssemblyOption) : AssemblyOption =
    match src with
    | :? ScriptDom.OnOffAssemblyOption as src ->
      AssemblyOption.OnOffAssemblyOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.PermissionSetAssemblyOption as src ->
      AssemblyOption.PermissionSetAssemblyOption((src.OptionKind), (src.PermissionSetOption))
    | _ -> (* :? ScriptDom.AssemblyOption as src *)
      AssemblyOption.Base(((src.OptionKind)))
and AtomicBlockOption = (* IsAbstract = true , children = 3*)
  | IdentifierAtomicBlockOption of optionKind:ScriptDom.AtomicBlockOptionKind * value:Identifier option
  | LiteralAtomicBlockOption of optionKind:ScriptDom.AtomicBlockOptionKind * value:Literal option
  | OnOffAtomicBlockOption of optionKind:ScriptDom.AtomicBlockOptionKind * optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.AtomicBlockOption =
    match this with
    | IdentifierAtomicBlockOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.IdentifierAtomicBlockOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AtomicBlockOption (* 404 *)
    | LiteralAtomicBlockOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralAtomicBlockOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AtomicBlockOption (* 404 *)
    | OnOffAtomicBlockOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffAtomicBlockOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.AtomicBlockOption (* 404 *)
//// shared props AtomicBlockOption 
  member this.OptionKind = 
    match this with
    | IdentifierAtomicBlockOption(optionKind=optionKind) -> optionKind
    | LiteralAtomicBlockOption(optionKind=optionKind) -> optionKind
    | OnOffAtomicBlockOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.AtomicBlockOption) : AtomicBlockOption =
    match src with
    | :? ScriptDom.IdentifierAtomicBlockOption as src ->
      AtomicBlockOption.IdentifierAtomicBlockOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.LiteralAtomicBlockOption as src ->
      AtomicBlockOption.LiteralAtomicBlockOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OnOffAtomicBlockOption as src ->
      AtomicBlockOption.OnOffAtomicBlockOption((src.OptionKind), (src.OptionState))
and AuditOption = (* IsAbstract = true , children = 4*)
  | AuditGuidAuditOption of guid:Literal option * optionKind:ScriptDom.AuditOptionKind
  | OnFailureAuditOption of onFailureAction:ScriptDom.AuditFailureActionType * optionKind:ScriptDom.AuditOptionKind
  | QueueDelayAuditOption of delay:Literal option * optionKind:ScriptDom.AuditOptionKind
  | StateAuditOption of optionKind:ScriptDom.AuditOptionKind * value:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.AuditOption =
    match this with
    | AuditGuidAuditOption(guid=aGuid; optionKind=aOptionKind) ->
      let ret = ScriptDom.AuditGuidAuditOption()
      ret.Guid <- aGuid |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditOption (* 404 *)
    | OnFailureAuditOption(onFailureAction=aOnFailureAction; optionKind=aOptionKind) ->
      let ret = ScriptDom.OnFailureAuditOption()
      ret.OnFailureAction <- aOnFailureAction
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditOption (* 404 *)
    | QueueDelayAuditOption(delay=aDelay; optionKind=aOptionKind) ->
      let ret = ScriptDom.QueueDelayAuditOption()
      ret.Delay <- aDelay |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AuditOption (* 404 *)
    | StateAuditOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.StateAuditOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AuditOption (* 404 *)
//// shared props AuditOption 
  member this.OptionKind = 
    match this with
    | AuditGuidAuditOption(optionKind=optionKind) -> optionKind
    | OnFailureAuditOption(optionKind=optionKind) -> optionKind
    | QueueDelayAuditOption(optionKind=optionKind) -> optionKind
    | StateAuditOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.AuditOption) : AuditOption =
    match src with
    | :? ScriptDom.AuditGuidAuditOption as src ->
      AuditOption.AuditGuidAuditOption((src.Guid |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.OnFailureAuditOption as src ->
      AuditOption.OnFailureAuditOption((src.OnFailureAction), (src.OptionKind))
    | :? ScriptDom.QueueDelayAuditOption as src ->
      AuditOption.QueueDelayAuditOption((src.Delay |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.StateAuditOption as src ->
      AuditOption.StateAuditOption((src.OptionKind), (src.Value))
and AuditSpecificationDetail = (* IsAbstract = true , children = 2*)
  | AuditActionGroupReference of group:ScriptDom.AuditActionGroup
  | AuditActionSpecification of actions:(DatabaseAuditAction) list * principals:(SecurityPrincipal) list * targetObject:SecurityTargetObject option
  member this.ToCs() : ScriptDom.AuditSpecificationDetail =
    match this with
    | AuditActionGroupReference(group=aGroup) ->
      let ret = ScriptDom.AuditActionGroupReference()
      ret.Group <- aGroup
      ret :> ScriptDom.AuditSpecificationDetail (* 404 *)
    | AuditActionSpecification(actions=aActions; principals=aPrincipals; targetObject=aTargetObject) ->
      let ret = ScriptDom.AuditActionSpecification()
      for e in aActions do ret.Actions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.TargetObject <- aTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationDetail (* 404 *)
  static member FromCs(src:ScriptDom.AuditSpecificationDetail) : AuditSpecificationDetail =
    match src with
    | :? ScriptDom.AuditActionGroupReference as src ->
      AuditSpecificationDetail.AuditActionGroupReference((src.Group))
    | :? ScriptDom.AuditActionSpecification as src ->
      AuditSpecificationDetail.AuditActionSpecification((src.Actions |> Seq.map (fun src -> DatabaseAuditAction.DatabaseAuditAction((src.ActionKind))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.TargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)))
and AuditTargetOption = (* IsAbstract = true , children = 4*)
  | LiteralAuditTargetOption of optionKind:ScriptDom.AuditTargetOptionKind * value:Literal option
  | MaxRolloverFilesAuditTargetOption of isUnlimited:bool * optionKind:ScriptDom.AuditTargetOptionKind * value:Literal option
  | MaxSizeAuditTargetOption of isUnlimited:bool * optionKind:ScriptDom.AuditTargetOptionKind * size:Literal option * unit:ScriptDom.MemoryUnit
  | OnOffAuditTargetOption of optionKind:ScriptDom.AuditTargetOptionKind * value:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.AuditTargetOption =
    match this with
    | LiteralAuditTargetOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralAuditTargetOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditTargetOption (* 404 *)
    | MaxRolloverFilesAuditTargetOption(isUnlimited=aIsUnlimited; optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.MaxRolloverFilesAuditTargetOption()
      ret.IsUnlimited <- aIsUnlimited
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditTargetOption (* 404 *)
    | MaxSizeAuditTargetOption(isUnlimited=aIsUnlimited; optionKind=aOptionKind; size=aSize; unit=aUnit) ->
      let ret = ScriptDom.MaxSizeAuditTargetOption()
      ret.IsUnlimited <- aIsUnlimited
      ret.OptionKind <- aOptionKind
      ret.Size <- aSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unit <- aUnit
      ret :> ScriptDom.AuditTargetOption (* 404 *)
    | OnOffAuditTargetOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.OnOffAuditTargetOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AuditTargetOption (* 404 *)
//// shared props AuditTargetOption 
  member this.OptionKind = 
    match this with
    | LiteralAuditTargetOption(optionKind=optionKind) -> optionKind
    | MaxRolloverFilesAuditTargetOption(optionKind=optionKind) -> optionKind
    | MaxSizeAuditTargetOption(optionKind=optionKind) -> optionKind
    | OnOffAuditTargetOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.AuditTargetOption) : AuditTargetOption =
    match src with
    | :? ScriptDom.LiteralAuditTargetOption as src ->
      AuditTargetOption.LiteralAuditTargetOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.MaxRolloverFilesAuditTargetOption as src ->
      AuditTargetOption.MaxRolloverFilesAuditTargetOption((src.IsUnlimited), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.MaxSizeAuditTargetOption as src ->
      AuditTargetOption.MaxSizeAuditTargetOption((src.IsUnlimited), (src.OptionKind), (src.Size |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unit))
    | :? ScriptDom.OnOffAuditTargetOption as src ->
      AuditTargetOption.OnOffAuditTargetOption((src.OptionKind), (src.Value))
and AutomaticTuningOption = (* IsAbstract = false , children = 4*)
  | Base of optionKind:ScriptDom.AutomaticTuningOptionKind * value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningCreateIndexOption of optionKind:ScriptDom.AutomaticTuningOptionKind * value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningDropIndexOption of optionKind:ScriptDom.AutomaticTuningOptionKind * value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningForceLastGoodPlanOption of optionKind:ScriptDom.AutomaticTuningOptionKind * value:ScriptDom.AutomaticTuningOptionState
  | AutomaticTuningMaintainIndexOption of optionKind:ScriptDom.AutomaticTuningOptionKind * value:ScriptDom.AutomaticTuningOptionState
  member this.ToCs() : ScriptDom.AutomaticTuningOption =
    match this with
    | AutomaticTuningCreateIndexOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AutomaticTuningCreateIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 404 *)
    | AutomaticTuningDropIndexOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AutomaticTuningDropIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 404 *)
    | AutomaticTuningForceLastGoodPlanOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AutomaticTuningForceLastGoodPlanOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 404 *)
    | AutomaticTuningMaintainIndexOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AutomaticTuningMaintainIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AutomaticTuningOption (* 404 *)
    | Base(optionKind=aOptionKind; value=aValue) ->

      let ret = ScriptDom.AutomaticTuningOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret
//// shared props AutomaticTuningOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | AutomaticTuningCreateIndexOption(optionKind=optionKind) -> optionKind
    | AutomaticTuningDropIndexOption(optionKind=optionKind) -> optionKind
    | AutomaticTuningForceLastGoodPlanOption(optionKind=optionKind) -> optionKind
    | AutomaticTuningMaintainIndexOption(optionKind=optionKind) -> optionKind
  member this.Value = 
    match this with
    | Base (value=value) -> value
    | AutomaticTuningCreateIndexOption(value=value) -> value
    | AutomaticTuningDropIndexOption(value=value) -> value
    | AutomaticTuningForceLastGoodPlanOption(value=value) -> value
    | AutomaticTuningMaintainIndexOption(value=value) -> value
  static member FromCs(src:ScriptDom.AutomaticTuningOption) : AutomaticTuningOption =
    match src with
    | :? ScriptDom.AutomaticTuningCreateIndexOption as src ->
      AutomaticTuningOption.AutomaticTuningCreateIndexOption((src.OptionKind), (src.Value))
    | :? ScriptDom.AutomaticTuningDropIndexOption as src ->
      AutomaticTuningOption.AutomaticTuningDropIndexOption((src.OptionKind), (src.Value))
    | :? ScriptDom.AutomaticTuningForceLastGoodPlanOption as src ->
      AutomaticTuningOption.AutomaticTuningForceLastGoodPlanOption((src.OptionKind), (src.Value))
    | :? ScriptDom.AutomaticTuningMaintainIndexOption as src ->
      AutomaticTuningOption.AutomaticTuningMaintainIndexOption((src.OptionKind), (src.Value))
    | _ -> (* :? ScriptDom.AutomaticTuningOption as src *)
      AutomaticTuningOption.Base(((src.OptionKind), (src.Value)))
and AvailabilityGroupOption = (* IsAbstract = true , children = 1*)
  | LiteralAvailabilityGroupOption of optionKind:ScriptDom.AvailabilityGroupOptionKind * value:Literal option
  member this.ToCs() : ScriptDom.AvailabilityGroupOption =
    match this with
    | LiteralAvailabilityGroupOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralAvailabilityGroupOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AvailabilityGroupOption (* 404 *)
//// shared props AvailabilityGroupOption 
  member this.OptionKind = 
    match this with
    | LiteralAvailabilityGroupOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.AvailabilityGroupOption) : AvailabilityGroupOption =
    match src with
    | :? ScriptDom.LiteralAvailabilityGroupOption as src ->
      AvailabilityGroupOption.LiteralAvailabilityGroupOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and AvailabilityReplicaOption = (* IsAbstract = true , children = 5*)
  | AvailabilityModeReplicaOption of optionKind:ScriptDom.AvailabilityReplicaOptionKind * value:ScriptDom.AvailabilityModeOptionKind
  | FailoverModeReplicaOption of optionKind:ScriptDom.AvailabilityReplicaOptionKind * value:ScriptDom.FailoverModeOptionKind
  | LiteralReplicaOption of optionKind:ScriptDom.AvailabilityReplicaOptionKind * value:Literal option
  | PrimaryRoleReplicaOption of allowConnections:ScriptDom.AllowConnectionsOptionKind * optionKind:ScriptDom.AvailabilityReplicaOptionKind
  | SecondaryRoleReplicaOption of allowConnections:ScriptDom.AllowConnectionsOptionKind * optionKind:ScriptDom.AvailabilityReplicaOptionKind
  member this.ToCs() : ScriptDom.AvailabilityReplicaOption =
    match this with
    | AvailabilityModeReplicaOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AvailabilityModeReplicaOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AvailabilityReplicaOption (* 404 *)
    | FailoverModeReplicaOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.FailoverModeReplicaOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.AvailabilityReplicaOption (* 404 *)
    | LiteralReplicaOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralReplicaOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AvailabilityReplicaOption (* 404 *)
    | PrimaryRoleReplicaOption(allowConnections=aAllowConnections; optionKind=aOptionKind) ->
      let ret = ScriptDom.PrimaryRoleReplicaOption()
      ret.AllowConnections <- aAllowConnections
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AvailabilityReplicaOption (* 404 *)
    | SecondaryRoleReplicaOption(allowConnections=aAllowConnections; optionKind=aOptionKind) ->
      let ret = ScriptDom.SecondaryRoleReplicaOption()
      ret.AllowConnections <- aAllowConnections
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.AvailabilityReplicaOption (* 404 *)
//// shared props AvailabilityReplicaOption 
  member this.OptionKind = 
    match this with
    | AvailabilityModeReplicaOption(optionKind=optionKind) -> optionKind
    | FailoverModeReplicaOption(optionKind=optionKind) -> optionKind
    | LiteralReplicaOption(optionKind=optionKind) -> optionKind
    | PrimaryRoleReplicaOption(optionKind=optionKind) -> optionKind
    | SecondaryRoleReplicaOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.AvailabilityReplicaOption) : AvailabilityReplicaOption =
    match src with
    | :? ScriptDom.AvailabilityModeReplicaOption as src ->
      AvailabilityReplicaOption.AvailabilityModeReplicaOption((src.OptionKind), (src.Value))
    | :? ScriptDom.FailoverModeReplicaOption as src ->
      AvailabilityReplicaOption.FailoverModeReplicaOption((src.OptionKind), (src.Value))
    | :? ScriptDom.LiteralReplicaOption as src ->
      AvailabilityReplicaOption.LiteralReplicaOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.PrimaryRoleReplicaOption as src ->
      AvailabilityReplicaOption.PrimaryRoleReplicaOption((src.AllowConnections), (src.OptionKind))
    | :? ScriptDom.SecondaryRoleReplicaOption as src ->
      AvailabilityReplicaOption.SecondaryRoleReplicaOption((src.AllowConnections), (src.OptionKind))
and BackupOption = (* IsAbstract = false , children = 1*)
  | Base of optionKind:ScriptDom.BackupOptionKind * value:ScalarExpression option
  | BackupEncryptionOption of algorithm:ScriptDom.EncryptionAlgorithm * encryptor:CryptoMechanism option * optionKind:ScriptDom.BackupOptionKind * value:ScalarExpression option
  member this.ToCs() : ScriptDom.BackupOption =
    match this with
    | BackupEncryptionOption(algorithm=aAlgorithm; encryptor=aEncryptor; optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.BackupEncryptionOption()
      ret.Algorithm <- aAlgorithm
      ret.Encryptor <- aEncryptor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupOption (* 404 *)
    | Base(optionKind=aOptionKind; value=aValue) ->

      let ret = ScriptDom.BackupOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props BackupOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | BackupEncryptionOption(optionKind=optionKind) -> optionKind
  member this.Value = 
    match this with
    | Base (value=value) -> value
    | BackupEncryptionOption(value=value) -> value
  static member FromCs(src:ScriptDom.BackupOption) : BackupOption =
    match src with
    | :? ScriptDom.BackupEncryptionOption as src ->
      BackupOption.BackupEncryptionOption((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | _ -> (* :? ScriptDom.BackupOption as src *)
      BackupOption.Base(((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs))))
and BooleanExpression = (* IsAbstract = true , children = 22*)
  | BooleanBinaryExpression of binaryExpressionType:ScriptDom.BooleanBinaryExpressionType * firstExpression:BooleanExpression option * secondExpression:BooleanExpression option
  | BooleanComparisonExpression of comparisonType:ScriptDom.BooleanComparisonType * firstExpression:ScalarExpression option * secondExpression:ScalarExpression option
  | BooleanExpressionSnippet of script:String
  | BooleanIsNullExpression of expression:ScalarExpression option * isNot:bool
  | BooleanNotExpression of expression:BooleanExpression option
  | BooleanParenthesisExpression of expression:BooleanExpression option
  | BooleanTernaryExpression of firstExpression:ScalarExpression option * secondExpression:ScalarExpression option * ternaryExpressionType:ScriptDom.BooleanTernaryExpressionType * thirdExpression:ScalarExpression option
  | EventDeclarationCompareFunctionParameter of eventValue:ScalarExpression option * name:EventSessionObjectName option * sourceDeclaration:SourceDeclaration option
  | ExistsPredicate of subquery:ScalarSubquery option
  | FullTextPredicate of columns:(ColumnReferenceExpression) list * fullTextFunctionType:ScriptDom.FullTextFunctionType * languageTerm:ValueExpression option * propertyName:StringLiteral option * value:ValueExpression option
  | GraphMatchCompositeExpression of arrowOnRight:bool * edge:Identifier option * leftNode:GraphMatchNodeExpression option * rightNode:GraphMatchNodeExpression option
  | GraphMatchExpression of arrowOnRight:bool * edge:Identifier option * leftNode:Identifier option * rightNode:Identifier option
  | GraphMatchLastNodePredicate of leftExpression:GraphMatchNodeExpression option * rightExpression:GraphMatchNodeExpression option
  | GraphMatchNodeExpression of node:Identifier option * usesLastNode:bool
  | GraphMatchPredicate of expression:BooleanExpression option
  | GraphMatchRecursivePredicate of anchorOnLeft:bool * expression:(BooleanExpression) list * function_:ScriptDom.GraphMatchRecursivePredicateKind * outerNodeExpression:GraphMatchNodeExpression option * recursiveQuantifier:GraphRecursiveMatchQuantifier option
  | GraphRecursiveMatchQuantifier of isPlusSign:bool * lowerLimit:Literal option * upperLimit:Literal option
  | InPredicate of expression:ScalarExpression option * notDefined:bool * subquery:ScalarSubquery option * values:(ScalarExpression) list
  | LikePredicate of escapeExpression:ScalarExpression option * firstExpression:ScalarExpression option * notDefined:bool * odbcEscape:bool * secondExpression:ScalarExpression option
  | SubqueryComparisonPredicate of comparisonType:ScriptDom.BooleanComparisonType * expression:ScalarExpression option * subquery:ScalarSubquery option * subqueryComparisonPredicateType:ScriptDom.SubqueryComparisonPredicateType
  | TSEqualCall of firstExpression:ScalarExpression option * secondExpression:ScalarExpression option
  | UpdateCall of identifier:Identifier option
  member this.ToCs() : ScriptDom.BooleanExpression =
    match this with
    | BooleanBinaryExpression(binaryExpressionType=aBinaryExpressionType; firstExpression=aFirstExpression; secondExpression=aSecondExpression) ->
      let ret = ScriptDom.BooleanBinaryExpression()
      ret.BinaryExpressionType <- aBinaryExpressionType
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | BooleanComparisonExpression(comparisonType=aComparisonType; firstExpression=aFirstExpression; secondExpression=aSecondExpression) ->
      let ret = ScriptDom.BooleanComparisonExpression()
      ret.ComparisonType <- aComparisonType
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | BooleanExpressionSnippet(script=aScript) ->
      let ret = ScriptDom.BooleanExpressionSnippet()
      ret.Script <- aScript
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | BooleanIsNullExpression(expression=aExpression; isNot=aIsNot) ->
      let ret = ScriptDom.BooleanIsNullExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsNot <- aIsNot
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | BooleanNotExpression(expression=aExpression) ->
      let ret = ScriptDom.BooleanNotExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | BooleanParenthesisExpression(expression=aExpression) ->
      let ret = ScriptDom.BooleanParenthesisExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | BooleanTernaryExpression(firstExpression=aFirstExpression; secondExpression=aSecondExpression; ternaryExpressionType=aTernaryExpressionType; thirdExpression=aThirdExpression) ->
      let ret = ScriptDom.BooleanTernaryExpression()
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TernaryExpressionType <- aTernaryExpressionType
      ret.ThirdExpression <- aThirdExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | EventDeclarationCompareFunctionParameter(eventValue=aEventValue; name=aName; sourceDeclaration=aSourceDeclaration) ->
      let ret = ScriptDom.EventDeclarationCompareFunctionParameter()
      ret.EventValue <- aEventValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceDeclaration <- aSourceDeclaration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | ExistsPredicate(subquery=aSubquery) ->
      let ret = ScriptDom.ExistsPredicate()
      ret.Subquery <- aSubquery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | FullTextPredicate(columns=aColumns; fullTextFunctionType=aFullTextFunctionType; languageTerm=aLanguageTerm; propertyName=aPropertyName; value=aValue) ->
      let ret = ScriptDom.FullTextPredicate()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FullTextFunctionType <- aFullTextFunctionType
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphMatchCompositeExpression(arrowOnRight=aArrowOnRight; edge=aEdge; leftNode=aLeftNode; rightNode=aRightNode) ->
      let ret = ScriptDom.GraphMatchCompositeExpression()
      ret.ArrowOnRight <- aArrowOnRight
      ret.Edge <- aEdge |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LeftNode <- aLeftNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RightNode <- aRightNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphMatchExpression(arrowOnRight=aArrowOnRight; edge=aEdge; leftNode=aLeftNode; rightNode=aRightNode) ->
      let ret = ScriptDom.GraphMatchExpression()
      ret.ArrowOnRight <- aArrowOnRight
      ret.Edge <- aEdge |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LeftNode <- aLeftNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RightNode <- aRightNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphMatchLastNodePredicate(leftExpression=aLeftExpression; rightExpression=aRightExpression) ->
      let ret = ScriptDom.GraphMatchLastNodePredicate()
      ret.LeftExpression <- aLeftExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RightExpression <- aRightExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphMatchNodeExpression(node=aNode; usesLastNode=aUsesLastNode) ->
      let ret = ScriptDom.GraphMatchNodeExpression()
      ret.Node <- aNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UsesLastNode <- aUsesLastNode
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphMatchPredicate(expression=aExpression) ->
      let ret = ScriptDom.GraphMatchPredicate()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphMatchRecursivePredicate(anchorOnLeft=aAnchorOnLeft; expression=aExpression; function_=aFunction; outerNodeExpression=aOuterNodeExpression; recursiveQuantifier=aRecursiveQuantifier) ->
      let ret = ScriptDom.GraphMatchRecursivePredicate()
      ret.AnchorOnLeft <- aAnchorOnLeft
      for e in aExpression do ret.Expression.Add (e.ToCs())
      ret.Function <- aFunction
      ret.OuterNodeExpression <- aOuterNodeExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RecursiveQuantifier <- aRecursiveQuantifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | GraphRecursiveMatchQuantifier(isPlusSign=aIsPlusSign; lowerLimit=aLowerLimit; upperLimit=aUpperLimit) ->
      let ret = ScriptDom.GraphRecursiveMatchQuantifier()
      ret.IsPlusSign <- aIsPlusSign
      ret.LowerLimit <- aLowerLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UpperLimit <- aUpperLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | InPredicate(expression=aExpression; notDefined=aNotDefined; subquery=aSubquery; values=aValues) ->
      let ret = ScriptDom.InPredicate()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotDefined <- aNotDefined
      ret.Subquery <- aSubquery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aValues do ret.Values.Add (e.ToCs())
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | LikePredicate(escapeExpression=aEscapeExpression; firstExpression=aFirstExpression; notDefined=aNotDefined; odbcEscape=aOdbcEscape; secondExpression=aSecondExpression) ->
      let ret = ScriptDom.LikePredicate()
      ret.EscapeExpression <- aEscapeExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotDefined <- aNotDefined
      ret.OdbcEscape <- aOdbcEscape
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | SubqueryComparisonPredicate(comparisonType=aComparisonType; expression=aExpression; subquery=aSubquery; subqueryComparisonPredicateType=aSubqueryComparisonPredicateType) ->
      let ret = ScriptDom.SubqueryComparisonPredicate()
      ret.ComparisonType <- aComparisonType
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Subquery <- aSubquery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SubqueryComparisonPredicateType <- aSubqueryComparisonPredicateType
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | TSEqualCall(firstExpression=aFirstExpression; secondExpression=aSecondExpression) ->
      let ret = ScriptDom.TSEqualCall()
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
    | UpdateCall(identifier=aIdentifier) ->
      let ret = ScriptDom.UpdateCall()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BooleanExpression (* 404 *)
  static member FromCs(src:ScriptDom.BooleanExpression) : BooleanExpression =
    match src with
    | :? ScriptDom.BooleanBinaryExpression as src ->
      BooleanExpression.BooleanBinaryExpression((src.BinaryExpressionType), (src.FirstExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.BooleanComparisonExpression as src ->
      BooleanExpression.BooleanComparisonExpression((src.ComparisonType), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.BooleanExpressionSnippet as src ->
      BooleanExpression.BooleanExpressionSnippet((src.Script))
    | :? ScriptDom.BooleanIsNullExpression as src ->
      BooleanExpression.BooleanIsNullExpression((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsNot))
    | :? ScriptDom.BooleanNotExpression as src ->
      BooleanExpression.BooleanNotExpression((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.BooleanParenthesisExpression as src ->
      BooleanExpression.BooleanParenthesisExpression((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.BooleanTernaryExpression as src ->
      BooleanExpression.BooleanTernaryExpression((src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TernaryExpressionType), (src.ThirdExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.EventDeclarationCompareFunctionParameter as src ->
      BooleanExpression.EventDeclarationCompareFunctionParameter((src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.SourceDeclaration |> Option.ofObj |> Option.map (SourceDeclaration.FromCs)))
    | :? ScriptDom.ExistsPredicate as src ->
      BooleanExpression.ExistsPredicate((src.Subquery |> Option.ofObj |> Option.map (ScalarSubquery.FromCs)))
    | :? ScriptDom.FullTextPredicate as src ->
      BooleanExpression.FullTextPredicate((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FullTextFunctionType), (src.LanguageTerm |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Value |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.GraphMatchCompositeExpression as src ->
      BooleanExpression.GraphMatchCompositeExpression((src.ArrowOnRight), (src.Edge |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LeftNode |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)), (src.RightNode |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)))
    | :? ScriptDom.GraphMatchExpression as src ->
      BooleanExpression.GraphMatchExpression((src.ArrowOnRight), (src.Edge |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LeftNode |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RightNode |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.GraphMatchLastNodePredicate as src ->
      BooleanExpression.GraphMatchLastNodePredicate((src.LeftExpression |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)), (src.RightExpression |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)))
    | :? ScriptDom.GraphMatchNodeExpression as src ->
      BooleanExpression.GraphMatchNodeExpression((src.Node |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UsesLastNode))
    | :? ScriptDom.GraphMatchPredicate as src ->
      BooleanExpression.GraphMatchPredicate((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.GraphMatchRecursivePredicate as src ->
      BooleanExpression.GraphMatchRecursivePredicate((src.AnchorOnLeft), (src.Expression |> Seq.map (BooleanExpression.FromCs) |> List.ofSeq), (src.Function), (src.OuterNodeExpression |> Option.ofObj |> Option.map (GraphMatchNodeExpression.FromCs)), (src.RecursiveQuantifier |> Option.ofObj |> Option.map (GraphRecursiveMatchQuantifier.FromCs)))
    | :? ScriptDom.GraphRecursiveMatchQuantifier as src ->
      BooleanExpression.GraphRecursiveMatchQuantifier((src.IsPlusSign), (src.LowerLimit |> Option.ofObj |> Option.map (Literal.FromCs)), (src.UpperLimit |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.InPredicate as src ->
      BooleanExpression.InPredicate((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.NotDefined), (src.Subquery |> Option.ofObj |> Option.map (ScalarSubquery.FromCs)), (src.Values |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.LikePredicate as src ->
      BooleanExpression.LikePredicate((src.EscapeExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.NotDefined), (src.OdbcEscape), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.SubqueryComparisonPredicate as src ->
      BooleanExpression.SubqueryComparisonPredicate((src.ComparisonType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Subquery |> Option.ofObj |> Option.map (ScalarSubquery.FromCs)), (src.SubqueryComparisonPredicateType))
    | :? ScriptDom.TSEqualCall as src ->
      BooleanExpression.TSEqualCall((src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.UpdateCall as src ->
      BooleanExpression.UpdateCall((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)))
and BulkInsertOption = (* IsAbstract = false , children = 2*)
  | Base of optionKind:ScriptDom.BulkInsertOptionKind
  | LiteralBulkInsertOption of optionKind:ScriptDom.BulkInsertOptionKind * value:Literal option
  | OrderBulkInsertOption of columns:(ColumnWithSortOrder) list * isUnique:bool * optionKind:ScriptDom.BulkInsertOptionKind
  member this.ToCs() : ScriptDom.BulkInsertOption =
    match this with
    | LiteralBulkInsertOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralBulkInsertOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BulkInsertOption (* 404 *)
    | OrderBulkInsertOption(columns=aColumns; isUnique=aIsUnique; optionKind=aOptionKind) ->
      let ret = ScriptDom.OrderBulkInsertOption()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsUnique <- aIsUnique
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.BulkInsertOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.BulkInsertOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props BulkInsertOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | LiteralBulkInsertOption(optionKind=optionKind) -> optionKind
    | OrderBulkInsertOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.BulkInsertOption) : BulkInsertOption =
    match src with
    | :? ScriptDom.LiteralBulkInsertOption as src ->
      BulkInsertOption.LiteralBulkInsertOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OrderBulkInsertOption as src ->
      BulkInsertOption.OrderBulkInsertOption((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.IsUnique), (src.OptionKind))
    | _ -> (* :? ScriptDom.BulkInsertOption as src *)
      BulkInsertOption.Base(((src.OptionKind)))
and CallTarget = (* IsAbstract = true , children = 3*)
  | ExpressionCallTarget of expression:ScalarExpression option
  | MultiPartIdentifierCallTarget of multiPartIdentifier:MultiPartIdentifier option
  | UserDefinedTypeCallTarget of schemaObjectName:SchemaObjectName option
  member this.ToCs() : ScriptDom.CallTarget =
    match this with
    | ExpressionCallTarget(expression=aExpression) ->
      let ret = ScriptDom.ExpressionCallTarget()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CallTarget (* 404 *)
    | MultiPartIdentifierCallTarget(multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.MultiPartIdentifierCallTarget()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CallTarget (* 404 *)
    | UserDefinedTypeCallTarget(schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.UserDefinedTypeCallTarget()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CallTarget (* 404 *)
  static member FromCs(src:ScriptDom.CallTarget) : CallTarget =
    match src with
    | :? ScriptDom.ExpressionCallTarget as src ->
      CallTarget.ExpressionCallTarget((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.MultiPartIdentifierCallTarget as src ->
      CallTarget.MultiPartIdentifierCallTarget((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
    | :? ScriptDom.UserDefinedTypeCallTarget as src ->
      CallTarget.UserDefinedTypeCallTarget((src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and ChangeTrackingOptionDetail = (* IsAbstract = true , children = 2*)
  | AutoCleanupChangeTrackingOptionDetail of isOn:bool
  | ChangeRetentionChangeTrackingOptionDetail of retentionPeriod:Literal option * unit:ScriptDom.TimeUnit
  member this.ToCs() : ScriptDom.ChangeTrackingOptionDetail =
    match this with
    | AutoCleanupChangeTrackingOptionDetail(isOn=aIsOn) ->
      let ret = ScriptDom.AutoCleanupChangeTrackingOptionDetail()
      ret.IsOn <- aIsOn
      ret :> ScriptDom.ChangeTrackingOptionDetail (* 404 *)
    | ChangeRetentionChangeTrackingOptionDetail(retentionPeriod=aRetentionPeriod; unit=aUnit) ->
      let ret = ScriptDom.ChangeRetentionChangeTrackingOptionDetail()
      ret.RetentionPeriod <- aRetentionPeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unit <- aUnit
      ret :> ScriptDom.ChangeTrackingOptionDetail (* 404 *)
  static member FromCs(src:ScriptDom.ChangeTrackingOptionDetail) : ChangeTrackingOptionDetail =
    match src with
    | :? ScriptDom.AutoCleanupChangeTrackingOptionDetail as src ->
      ChangeTrackingOptionDetail.AutoCleanupChangeTrackingOptionDetail((src.IsOn))
    | :? ScriptDom.ChangeRetentionChangeTrackingOptionDetail as src ->
      ChangeTrackingOptionDetail.ChangeRetentionChangeTrackingOptionDetail((src.RetentionPeriod |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unit))
and ColumnDefinitionBase = (* IsAbstract = false , children = 1*)
  | Base of collation:Identifier option * columnIdentifier:Identifier option * dataType:DataTypeReference option
  | ColumnDefinition of collation:Identifier option * columnIdentifier:Identifier option * computedColumnExpression:ScalarExpression option * constraints:(ConstraintDefinition) list * dataType:DataTypeReference option * defaultConstraint:DefaultConstraintDefinition option * encryption:ColumnEncryptionDefinition option * generatedAlways:(ScriptDom.GeneratedAlwaysType) option * identityOptions:IdentityOptions option * index:IndexDefinition option * isHidden:bool * isMasked:bool * isPersisted:bool * isRowGuidCol:bool * maskingFunction:StringLiteral option * storageOptions:ColumnStorageOptions option
  member this.ToCs() : ScriptDom.ColumnDefinitionBase =
    match this with
    | ColumnDefinition(collation=aCollation; columnIdentifier=aColumnIdentifier; computedColumnExpression=aComputedColumnExpression; constraints=aConstraints; dataType=aDataType; defaultConstraint=aDefaultConstraint; encryption=aEncryption; generatedAlways=aGeneratedAlways; identityOptions=aIdentityOptions; index=aIndex; isHidden=aIsHidden; isMasked=aIsMasked; isPersisted=aIsPersisted; isRowGuidCol=aIsRowGuidCol; maskingFunction=aMaskingFunction; storageOptions=aStorageOptions) ->
      let ret = ScriptDom.ColumnDefinition()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ComputedColumnExpression <- aComputedColumnExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aConstraints do ret.Constraints.Add (e.ToCs())
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DefaultConstraint <- aDefaultConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Encryption <- aEncryption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GeneratedAlways <- Option.toNullable aGeneratedAlways
      ret.IdentityOptions <- aIdentityOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsHidden <- aIsHidden
      ret.IsMasked <- aIsMasked
      ret.IsPersisted <- aIsPersisted
      ret.IsRowGuidCol <- aIsRowGuidCol
      ret.MaskingFunction <- aMaskingFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StorageOptions <- aStorageOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnDefinitionBase (* 404 *)
    | Base(collation=aCollation; columnIdentifier=aColumnIdentifier; dataType=aDataType) ->

      let ret = ScriptDom.ColumnDefinitionBase()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props ColumnDefinitionBase 
  member this.Collation = 
    match this with
    | Base (collation=collation) -> collation
    | ColumnDefinition(collation=collation) -> collation
  member this.ColumnIdentifier = 
    match this with
    | Base (columnIdentifier=columnIdentifier) -> columnIdentifier
    | ColumnDefinition(columnIdentifier=columnIdentifier) -> columnIdentifier
  member this.DataType = 
    match this with
    | Base (dataType=dataType) -> dataType
    | ColumnDefinition(dataType=dataType) -> dataType
  static member FromCs(src:ScriptDom.ColumnDefinitionBase) : ColumnDefinitionBase =
    match src with
    | :? ScriptDom.ColumnDefinition as src ->
      ColumnDefinitionBase.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Constraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DefaultConstraint |> Option.ofObj |> Option.map (DefaultConstraintDefinition.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (IdentityOptions.FromCs)), (src.Index |> Option.ofObj |> Option.map (IndexDefinition.FromCs)), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))
    | _ -> (* :? ScriptDom.ColumnDefinitionBase as src *)
      ColumnDefinitionBase.Base(((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs))))
and ColumnEncryptionDefinitionParameter = (* IsAbstract = true , children = 3*)
  | ColumnEncryptionAlgorithmParameter of encryptionAlgorithm:StringLiteral option * parameterKind:ScriptDom.ColumnEncryptionDefinitionParameterKind
  | ColumnEncryptionKeyNameParameter of name:Identifier option * parameterKind:ScriptDom.ColumnEncryptionDefinitionParameterKind
  | ColumnEncryptionTypeParameter of encryptionType:ScriptDom.ColumnEncryptionType * parameterKind:ScriptDom.ColumnEncryptionDefinitionParameterKind
  member this.ToCs() : ScriptDom.ColumnEncryptionDefinitionParameter =
    match this with
    | ColumnEncryptionAlgorithmParameter(encryptionAlgorithm=aEncryptionAlgorithm; parameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionAlgorithmParameter()
      ret.EncryptionAlgorithm <- aEncryptionAlgorithm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionDefinitionParameter (* 404 *)
    | ColumnEncryptionKeyNameParameter(name=aName; parameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionKeyNameParameter()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionDefinitionParameter (* 404 *)
    | ColumnEncryptionTypeParameter(encryptionType=aEncryptionType; parameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionTypeParameter()
      ret.EncryptionType <- aEncryptionType
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionDefinitionParameter (* 404 *)
//// shared props ColumnEncryptionDefinitionParameter 
  member this.ParameterKind = 
    match this with
    | ColumnEncryptionAlgorithmParameter(parameterKind=parameterKind) -> parameterKind
    | ColumnEncryptionKeyNameParameter(parameterKind=parameterKind) -> parameterKind
    | ColumnEncryptionTypeParameter(parameterKind=parameterKind) -> parameterKind
  static member FromCs(src:ScriptDom.ColumnEncryptionDefinitionParameter) : ColumnEncryptionDefinitionParameter =
    match src with
    | :? ScriptDom.ColumnEncryptionAlgorithmParameter as src ->
      ColumnEncryptionDefinitionParameter.ColumnEncryptionAlgorithmParameter((src.EncryptionAlgorithm |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ParameterKind))
    | :? ScriptDom.ColumnEncryptionKeyNameParameter as src ->
      ColumnEncryptionDefinitionParameter.ColumnEncryptionKeyNameParameter((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterKind))
    | :? ScriptDom.ColumnEncryptionTypeParameter as src ->
      ColumnEncryptionDefinitionParameter.ColumnEncryptionTypeParameter((src.EncryptionType), (src.ParameterKind))
and ColumnEncryptionKeyValueParameter = (* IsAbstract = true , children = 3*)
  | ColumnEncryptionAlgorithmNameParameter of algorithm:StringLiteral option * parameterKind:ScriptDom.ColumnEncryptionKeyValueParameterKind
  | ColumnMasterKeyNameParameter of name:Identifier option * parameterKind:ScriptDom.ColumnEncryptionKeyValueParameterKind
  | EncryptedValueParameter of parameterKind:ScriptDom.ColumnEncryptionKeyValueParameterKind * value:BinaryLiteral option
  member this.ToCs() : ScriptDom.ColumnEncryptionKeyValueParameter =
    match this with
    | ColumnEncryptionAlgorithmNameParameter(algorithm=aAlgorithm; parameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnEncryptionAlgorithmNameParameter()
      ret.Algorithm <- aAlgorithm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionKeyValueParameter (* 404 *)
    | ColumnMasterKeyNameParameter(name=aName; parameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnMasterKeyNameParameter()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnEncryptionKeyValueParameter (* 404 *)
    | EncryptedValueParameter(parameterKind=aParameterKind; value=aValue) ->
      let ret = ScriptDom.EncryptedValueParameter()
      ret.ParameterKind <- aParameterKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnEncryptionKeyValueParameter (* 404 *)
//// shared props ColumnEncryptionKeyValueParameter 
  member this.ParameterKind = 
    match this with
    | ColumnEncryptionAlgorithmNameParameter(parameterKind=parameterKind) -> parameterKind
    | ColumnMasterKeyNameParameter(parameterKind=parameterKind) -> parameterKind
    | EncryptedValueParameter(parameterKind=parameterKind) -> parameterKind
  static member FromCs(src:ScriptDom.ColumnEncryptionKeyValueParameter) : ColumnEncryptionKeyValueParameter =
    match src with
    | :? ScriptDom.ColumnEncryptionAlgorithmNameParameter as src ->
      ColumnEncryptionKeyValueParameter.ColumnEncryptionAlgorithmNameParameter((src.Algorithm |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ParameterKind))
    | :? ScriptDom.ColumnMasterKeyNameParameter as src ->
      ColumnEncryptionKeyValueParameter.ColumnMasterKeyNameParameter((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterKind))
    | :? ScriptDom.EncryptedValueParameter as src ->
      ColumnEncryptionKeyValueParameter.EncryptedValueParameter((src.ParameterKind), (src.Value |> Option.ofObj |> Option.map (BinaryLiteral.FromCs)))
and ColumnMasterKeyParameter = (* IsAbstract = true , children = 2*)
  | ColumnMasterKeyPathParameter of parameterKind:ScriptDom.ColumnMasterKeyParameterKind * path:StringLiteral option
  | ColumnMasterKeyStoreProviderNameParameter of name:StringLiteral option * parameterKind:ScriptDom.ColumnMasterKeyParameterKind
  member this.ToCs() : ScriptDom.ColumnMasterKeyParameter =
    match this with
    | ColumnMasterKeyPathParameter(parameterKind=aParameterKind; path=aPath) ->
      let ret = ScriptDom.ColumnMasterKeyPathParameter()
      ret.ParameterKind <- aParameterKind
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnMasterKeyParameter (* 404 *)
    | ColumnMasterKeyStoreProviderNameParameter(name=aName; parameterKind=aParameterKind) ->
      let ret = ScriptDom.ColumnMasterKeyStoreProviderNameParameter()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterKind <- aParameterKind
      ret :> ScriptDom.ColumnMasterKeyParameter (* 404 *)
//// shared props ColumnMasterKeyParameter 
  member this.ParameterKind = 
    match this with
    | ColumnMasterKeyPathParameter(parameterKind=parameterKind) -> parameterKind
    | ColumnMasterKeyStoreProviderNameParameter(parameterKind=parameterKind) -> parameterKind
  static member FromCs(src:ScriptDom.ColumnMasterKeyParameter) : ColumnMasterKeyParameter =
    match src with
    | :? ScriptDom.ColumnMasterKeyPathParameter as src ->
      ColumnMasterKeyParameter.ColumnMasterKeyPathParameter((src.ParameterKind), (src.Path |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.ColumnMasterKeyStoreProviderNameParameter as src ->
      ColumnMasterKeyParameter.ColumnMasterKeyStoreProviderNameParameter((src.Name |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ParameterKind))
and ConstraintDefinition = (* IsAbstract = true , children = 6*)
  | CheckConstraintDefinition of checkCondition:BooleanExpression option * constraintIdentifier:Identifier option * notForReplication:bool
  | DefaultConstraintDefinition of column:Identifier option * constraintIdentifier:Identifier option * expression:ScalarExpression option * withValues:bool
  | ForeignKeyConstraintDefinition of columns:(Identifier) list * constraintIdentifier:Identifier option * deleteAction:ScriptDom.DeleteUpdateAction * notForReplication:bool * referenceTableName:SchemaObjectName option * referencedTableColumns:(Identifier) list * updateAction:ScriptDom.DeleteUpdateAction
  | GraphConnectionConstraintDefinition of constraintIdentifier:Identifier option * deleteAction:ScriptDom.DeleteUpdateAction * fromNodeToNodeList:(GraphConnectionBetweenNodes) list
  | NullableConstraintDefinition of constraintIdentifier:Identifier option * nullable:bool
  | UniqueConstraintDefinition of clustered:(bool) option * columns:(ColumnWithSortOrder) list * constraintIdentifier:Identifier option * fileStreamOn:IdentifierOrValueExpression option * indexOptions:(IndexOption) list * indexType:IndexType option * isPrimaryKey:bool * onFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option
  member this.ToCs() : ScriptDom.ConstraintDefinition =
    match this with
    | CheckConstraintDefinition(checkCondition=aCheckCondition; constraintIdentifier=aConstraintIdentifier; notForReplication=aNotForReplication) ->
      let ret = ScriptDom.CheckConstraintDefinition()
      ret.CheckCondition <- aCheckCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotForReplication <- aNotForReplication
      ret :> ScriptDom.ConstraintDefinition (* 404 *)
    | DefaultConstraintDefinition(column=aColumn; constraintIdentifier=aConstraintIdentifier; expression=aExpression; withValues=aWithValues) ->
      let ret = ScriptDom.DefaultConstraintDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithValues <- aWithValues
      ret :> ScriptDom.ConstraintDefinition (* 404 *)
    | ForeignKeyConstraintDefinition(columns=aColumns; constraintIdentifier=aConstraintIdentifier; deleteAction=aDeleteAction; notForReplication=aNotForReplication; referenceTableName=aReferenceTableName; referencedTableColumns=aReferencedTableColumns; updateAction=aUpdateAction) ->
      let ret = ScriptDom.ForeignKeyConstraintDefinition()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DeleteAction <- aDeleteAction
      ret.NotForReplication <- aNotForReplication
      ret.ReferenceTableName <- aReferenceTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aReferencedTableColumns do ret.ReferencedTableColumns.Add (e.ToCs())
      ret.UpdateAction <- aUpdateAction
      ret :> ScriptDom.ConstraintDefinition (* 404 *)
    | GraphConnectionConstraintDefinition(constraintIdentifier=aConstraintIdentifier; deleteAction=aDeleteAction; fromNodeToNodeList=aFromNodeToNodeList) ->
      let ret = ScriptDom.GraphConnectionConstraintDefinition()
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DeleteAction <- aDeleteAction
      for e in aFromNodeToNodeList do ret.FromNodeToNodeList.Add (e.ToCs())
      ret :> ScriptDom.ConstraintDefinition (* 404 *)
    | NullableConstraintDefinition(constraintIdentifier=aConstraintIdentifier; nullable=aNullable) ->
      let ret = ScriptDom.NullableConstraintDefinition()
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable
      ret :> ScriptDom.ConstraintDefinition (* 404 *)
    | UniqueConstraintDefinition(clustered=aClustered; columns=aColumns; constraintIdentifier=aConstraintIdentifier; fileStreamOn=aFileStreamOn; indexOptions=aIndexOptions; indexType=aIndexType; isPrimaryKey=aIsPrimaryKey; onFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme) ->
      let ret = ScriptDom.UniqueConstraintDefinition()
      ret.Clustered <- Option.toNullable aClustered
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IndexType <- aIndexType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsPrimaryKey <- aIsPrimaryKey
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ConstraintDefinition (* 404 *)
//// shared props ConstraintDefinition 
  member this.ConstraintIdentifier = 
    match this with
    | CheckConstraintDefinition(constraintIdentifier=constraintIdentifier) -> constraintIdentifier
    | DefaultConstraintDefinition(constraintIdentifier=constraintIdentifier) -> constraintIdentifier
    | ForeignKeyConstraintDefinition(constraintIdentifier=constraintIdentifier) -> constraintIdentifier
    | GraphConnectionConstraintDefinition(constraintIdentifier=constraintIdentifier) -> constraintIdentifier
    | NullableConstraintDefinition(constraintIdentifier=constraintIdentifier) -> constraintIdentifier
    | UniqueConstraintDefinition(constraintIdentifier=constraintIdentifier) -> constraintIdentifier
  static member FromCs(src:ScriptDom.ConstraintDefinition) : ConstraintDefinition =
    match src with
    | :? ScriptDom.CheckConstraintDefinition as src ->
      ConstraintDefinition.CheckConstraintDefinition((src.CheckCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.NotForReplication))
    | :? ScriptDom.DefaultConstraintDefinition as src ->
      ConstraintDefinition.DefaultConstraintDefinition((src.Column |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WithValues))
    | :? ScriptDom.ForeignKeyConstraintDefinition as src ->
      ConstraintDefinition.ForeignKeyConstraintDefinition((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DeleteAction), (src.NotForReplication), (src.ReferenceTableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ReferencedTableColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.UpdateAction))
    | :? ScriptDom.GraphConnectionConstraintDefinition as src ->
      ConstraintDefinition.GraphConnectionConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DeleteAction), (src.FromNodeToNodeList |> Seq.map (fun src -> GraphConnectionBetweenNodes.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ToNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.NullableConstraintDefinition as src ->
      ConstraintDefinition.NullableConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Nullable))
    | :? ScriptDom.UniqueConstraintDefinition as src ->
      ConstraintDefinition.UniqueConstraintDefinition((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.IsPrimaryKey), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)))
and CreateLoginSource = (* IsAbstract = true , children = 4*)
  | AsymmetricKeyCreateLoginSource of credential:Identifier option * key:Identifier option
  | CertificateCreateLoginSource of certificate:Identifier option * credential:Identifier option
  | PasswordCreateLoginSource of hashed:bool * mustChange:bool * options:(PrincipalOption) list * password:Literal option
  | WindowsCreateLoginSource of options:(PrincipalOption) list
  member this.ToCs() : ScriptDom.CreateLoginSource =
    match this with
    | AsymmetricKeyCreateLoginSource(credential=aCredential; key=aKey) ->
      let ret = ScriptDom.AsymmetricKeyCreateLoginSource()
      ret.Credential <- aCredential |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Key <- aKey |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateLoginSource (* 404 *)
    | CertificateCreateLoginSource(certificate=aCertificate; credential=aCredential) ->
      let ret = ScriptDom.CertificateCreateLoginSource()
      ret.Certificate <- aCertificate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Credential <- aCredential |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateLoginSource (* 404 *)
    | PasswordCreateLoginSource(hashed=aHashed; mustChange=aMustChange; options=aOptions; password=aPassword) ->
      let ret = ScriptDom.PasswordCreateLoginSource()
      ret.Hashed <- aHashed
      ret.MustChange <- aMustChange
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateLoginSource (* 404 *)
    | WindowsCreateLoginSource(options=aOptions) ->
      let ret = ScriptDom.WindowsCreateLoginSource()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.CreateLoginSource (* 404 *)
  static member FromCs(src:ScriptDom.CreateLoginSource) : CreateLoginSource =
    match src with
    | :? ScriptDom.AsymmetricKeyCreateLoginSource as src ->
      CreateLoginSource.AsymmetricKeyCreateLoginSource((src.Credential |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Key |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CertificateCreateLoginSource as src ->
      CreateLoginSource.CertificateCreateLoginSource((src.Certificate |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Credential |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.PasswordCreateLoginSource as src ->
      CreateLoginSource.PasswordCreateLoginSource((src.Hashed), (src.MustChange), (src.Options |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.WindowsCreateLoginSource as src ->
      CreateLoginSource.WindowsCreateLoginSource((src.Options |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))
and DataModificationSpecification = (* IsAbstract = true , children = 3*)
  | InsertSpecification of columns:(ColumnReferenceExpression) list * insertOption:ScriptDom.InsertOption * insertSource:InsertSource option * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * target:TableReference option * topRowFilter:TopRowFilter option
  | MergeSpecification of actionClauses:(MergeActionClause) list * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * searchCondition:BooleanExpression option * tableAlias:Identifier option * tableReference:TableReference option * target:TableReference option * topRowFilter:TopRowFilter option
  | UpdateDeleteSpecificationBase of updateDeleteSpecificationBase:UpdateDeleteSpecificationBase
  member this.ToCs() : ScriptDom.DataModificationSpecification =
    match this with
    | InsertSpecification(columns=aColumns; insertOption=aInsertOption; insertSource=aInsertSource; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; target=aTarget; topRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.InsertSpecification()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.InsertOption <- aInsertOption
      ret.InsertSource <- aInsertSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationSpecification (* 404 *)
    | MergeSpecification(actionClauses=aActionClauses; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; searchCondition=aSearchCondition; tableAlias=aTableAlias; tableReference=aTableReference; target=aTarget; topRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.MergeSpecification()
      for e in aActionClauses do ret.ActionClauses.Add (e.ToCs())
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableAlias <- aTableAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationSpecification (* 404 *)
    | UpdateDeleteSpecificationBase(x) -> x.ToCs() :> ScriptDom.DataModificationSpecification (* 414 *)
//// shared props DataModificationSpecification 
  member this.OutputClause = 
    match this with
    | InsertSpecification(outputClause=outputClause) -> outputClause
    | MergeSpecification(outputClause=outputClause) -> outputClause
    | UpdateDeleteSpecificationBase _ as x -> x.OutputClause
  member this.OutputIntoClause = 
    match this with
    | InsertSpecification(outputIntoClause=outputIntoClause) -> outputIntoClause
    | MergeSpecification(outputIntoClause=outputIntoClause) -> outputIntoClause
    | UpdateDeleteSpecificationBase _ as x -> x.OutputIntoClause
  member this.Target = 
    match this with
    | InsertSpecification(target=target) -> target
    | MergeSpecification(target=target) -> target
    | UpdateDeleteSpecificationBase _ as x -> x.Target
  member this.TopRowFilter = 
    match this with
    | InsertSpecification(topRowFilter=topRowFilter) -> topRowFilter
    | MergeSpecification(topRowFilter=topRowFilter) -> topRowFilter
    | UpdateDeleteSpecificationBase _ as x -> x.TopRowFilter
  static member FromCs(src:ScriptDom.DataModificationSpecification) : DataModificationSpecification =
    match src with
    | :? ScriptDom.InsertSpecification as src ->
      DataModificationSpecification.InsertSpecification((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.InsertOption), (src.InsertSource |> Option.ofObj |> Option.map (InsertSource.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)))
    | :? ScriptDom.MergeSpecification as src ->
      DataModificationSpecification.MergeSpecification((src.ActionClauses |> Seq.map (fun src -> MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (MergeAction.FromCs)), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))) |> List.ofSeq), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.TableAlias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)))
    | :? ScriptDom.UpdateDeleteSpecificationBase as src ->
      match src with
      | :? ScriptDom.DeleteSpecification as src->
        DataModificationSpecification.UpdateDeleteSpecificationBase((UpdateDeleteSpecificationBase.DeleteSpecification((src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))))
      | :? ScriptDom.UpdateSpecification as src->
        DataModificationSpecification.UpdateDeleteSpecificationBase((UpdateDeleteSpecificationBase.UpdateSpecification((src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.SetClauses |> Seq.map (SetClause.FromCs) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))))
and DataTypeReference = (* IsAbstract = true , children = 2*)
  | ParameterizedDataTypeReference of parameterizedDataTypeReference:ParameterizedDataTypeReference
  | XmlDataTypeReference of name:SchemaObjectName option * xmlDataTypeOption:ScriptDom.XmlDataTypeOption * xmlSchemaCollection:SchemaObjectName option
  member this.ToCs() : ScriptDom.DataTypeReference =
    match this with
    | ParameterizedDataTypeReference(x) -> x.ToCs() :> ScriptDom.DataTypeReference (* 414 *)
    | XmlDataTypeReference(name=aName; xmlDataTypeOption=aXmlDataTypeOption; xmlSchemaCollection=aXmlSchemaCollection) ->
      let ret = ScriptDom.XmlDataTypeReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XmlDataTypeOption <- aXmlDataTypeOption
      ret.XmlSchemaCollection <- aXmlSchemaCollection |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataTypeReference (* 404 *)
//// shared props DataTypeReference 
  member this.Name = 
    match this with
    | ParameterizedDataTypeReference _ as x -> x.Name
    | XmlDataTypeReference(name=name) -> name
  static member FromCs(src:ScriptDom.DataTypeReference) : DataTypeReference =
    match src with
    | :? ScriptDom.ParameterizedDataTypeReference as src ->
      match src with
      | :? ScriptDom.SqlDataTypeReference as src->
        DataTypeReference.ParameterizedDataTypeReference((ParameterizedDataTypeReference.SqlDataTypeReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Parameters |> Seq.map (Literal.FromCs) |> List.ofSeq), (src.SqlDataTypeOption))))
      | :? ScriptDom.UserDataTypeReference as src->
        DataTypeReference.ParameterizedDataTypeReference((ParameterizedDataTypeReference.UserDataTypeReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Parameters |> Seq.map (Literal.FromCs) |> List.ofSeq))))
    | :? ScriptDom.XmlDataTypeReference as src ->
      DataTypeReference.XmlDataTypeReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.XmlDataTypeOption), (src.XmlSchemaCollection |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and DatabaseConfigurationSetOption = (* IsAbstract = false , children = 3*)
  | Base of genericOptionKind:Identifier option * optionKind:ScriptDom.DatabaseConfigSetOptionKind
  | GenericConfigurationOption of genericOptionKind:Identifier option * genericOptionState:IdentifierOrScalarExpression option * optionKind:ScriptDom.DatabaseConfigSetOptionKind
  | MaxDopConfigurationOption of genericOptionKind:Identifier option * optionKind:ScriptDom.DatabaseConfigSetOptionKind * primary:bool * value:Literal option
  | OnOffPrimaryConfigurationOption of genericOptionKind:Identifier option * optionKind:ScriptDom.DatabaseConfigSetOptionKind * optionState:ScriptDom.DatabaseConfigurationOptionState
  member this.ToCs() : ScriptDom.DatabaseConfigurationSetOption =
    match this with
    | GenericConfigurationOption(genericOptionKind=aGenericOptionKind; genericOptionState=aGenericOptionState; optionKind=aOptionKind) ->
      let ret = ScriptDom.GenericConfigurationOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GenericOptionState <- aGenericOptionState |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseConfigurationSetOption (* 404 *)
    | MaxDopConfigurationOption(genericOptionKind=aGenericOptionKind; optionKind=aOptionKind; primary=aPrimary; value=aValue) ->
      let ret = ScriptDom.MaxDopConfigurationOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Primary <- aPrimary
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseConfigurationSetOption (* 404 *)
    | OnOffPrimaryConfigurationOption(genericOptionKind=aGenericOptionKind; optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffPrimaryConfigurationOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DatabaseConfigurationSetOption (* 404 *)
    | Base(genericOptionKind=aGenericOptionKind; optionKind=aOptionKind) ->

      let ret = ScriptDom.DatabaseConfigurationSetOption()
      ret.GenericOptionKind <- aGenericOptionKind |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret
//// shared props DatabaseConfigurationSetOption 
  member this.GenericOptionKind = 
    match this with
    | Base (genericOptionKind=genericOptionKind) -> genericOptionKind
    | GenericConfigurationOption(genericOptionKind=genericOptionKind) -> genericOptionKind
    | MaxDopConfigurationOption(genericOptionKind=genericOptionKind) -> genericOptionKind
    | OnOffPrimaryConfigurationOption(genericOptionKind=genericOptionKind) -> genericOptionKind
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | GenericConfigurationOption(optionKind=optionKind) -> optionKind
    | MaxDopConfigurationOption(optionKind=optionKind) -> optionKind
    | OnOffPrimaryConfigurationOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.DatabaseConfigurationSetOption) : DatabaseConfigurationSetOption =
    match src with
    | :? ScriptDom.GenericConfigurationOption as src ->
      DatabaseConfigurationSetOption.GenericConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.GenericOptionState |> Option.ofObj |> Option.map (IdentifierOrScalarExpression.FromCs)), (src.OptionKind))
    | :? ScriptDom.MaxDopConfigurationOption as src ->
      DatabaseConfigurationSetOption.MaxDopConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind), (src.Primary), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OnOffPrimaryConfigurationOption as src ->
      DatabaseConfigurationSetOption.OnOffPrimaryConfigurationOption((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind), (src.OptionState))
    | _ -> (* :? ScriptDom.DatabaseConfigurationSetOption as src *)
      DatabaseConfigurationSetOption.Base(((src.GenericOptionKind |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind)))
and DatabaseOption = (* IsAbstract = false , children = 20*)
  | Base of optionKind:ScriptDom.DatabaseOptionKind
  | AutomaticTuningDatabaseOption of automaticTuningState:ScriptDom.AutomaticTuningState * optionKind:ScriptDom.DatabaseOptionKind * options:(AutomaticTuningOption) list
  | CatalogCollationOption of catalogCollation:(ScriptDom.CatalogCollation) option * optionKind:ScriptDom.DatabaseOptionKind
  | ChangeTrackingDatabaseOption of details:(ChangeTrackingOptionDetail) list * optionKind:ScriptDom.DatabaseOptionKind * optionState:ScriptDom.OptionState
  | ContainmentDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:ScriptDom.ContainmentOptionKind
  | CursorDefaultDatabaseOption of isLocal:bool * optionKind:ScriptDom.DatabaseOptionKind
  | DelayedDurabilityDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:ScriptDom.DelayedDurabilityOptionKind
  | FileStreamDatabaseOption of directoryName:Literal option * nonTransactedAccess:(ScriptDom.NonTransactedFileStreamAccess) option * optionKind:ScriptDom.DatabaseOptionKind
  | HadrDatabaseOption of hadrDatabaseOption:HadrDatabaseOption
  | IdentifierDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:Identifier option
  | LiteralDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:Literal option
  | MaxSizeDatabaseOption of maxSize:Literal option * optionKind:ScriptDom.DatabaseOptionKind * units:ScriptDom.MemoryUnit
  | OnOffDatabaseOption of onOffDatabaseOption:OnOffDatabaseOption
  | PageVerifyDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:ScriptDom.PageVerifyDatabaseOptionKind
  | ParameterizationDatabaseOption of isSimple:bool * optionKind:ScriptDom.DatabaseOptionKind
  | PartnerDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * partnerOption:ScriptDom.PartnerDatabaseOptionKind * partnerServer:Literal option * timeout:Literal option
  | QueryStoreDatabaseOption of clear:bool * clearAll:bool * optionKind:ScriptDom.DatabaseOptionKind * optionState:ScriptDom.OptionState * options:(QueryStoreOption) list
  | RecoveryDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:ScriptDom.RecoveryDatabaseOptionKind
  | RemoteDataArchiveDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * optionState:ScriptDom.OptionState * settings:(RemoteDataArchiveDatabaseSetting) list
  | TargetRecoveryTimeDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * recoveryTime:Literal option * unit:ScriptDom.TimeUnit
  | WitnessDatabaseOption of isOff:bool * optionKind:ScriptDom.DatabaseOptionKind * witnessServer:Literal option
  member this.ToCs() : ScriptDom.DatabaseOption =
    match this with
    | AutomaticTuningDatabaseOption(automaticTuningState=aAutomaticTuningState; optionKind=aOptionKind; options=aOptions) ->
      let ret = ScriptDom.AutomaticTuningDatabaseOption()
      ret.AutomaticTuningState <- aAutomaticTuningState
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | CatalogCollationOption(catalogCollation=aCatalogCollation; optionKind=aOptionKind) ->
      let ret = ScriptDom.CatalogCollationOption()
      ret.CatalogCollation <- Option.toNullable aCatalogCollation
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | ChangeTrackingDatabaseOption(details=aDetails; optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.ChangeTrackingDatabaseOption()
      for e in aDetails do ret.Details.Add (e.ToCs())
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | ContainmentDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ContainmentDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | CursorDefaultDatabaseOption(isLocal=aIsLocal; optionKind=aOptionKind) ->
      let ret = ScriptDom.CursorDefaultDatabaseOption()
      ret.IsLocal <- aIsLocal
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | DelayedDurabilityDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.DelayedDurabilityDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | FileStreamDatabaseOption(directoryName=aDirectoryName; nonTransactedAccess=aNonTransactedAccess; optionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamDatabaseOption()
      ret.DirectoryName <- aDirectoryName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NonTransactedAccess <- Option.toNullable aNonTransactedAccess
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | HadrDatabaseOption(x) -> x.ToCs() :> ScriptDom.DatabaseOption (* 414 *)
    | IdentifierDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.IdentifierDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | LiteralDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | MaxSizeDatabaseOption(maxSize=aMaxSize; optionKind=aOptionKind; units=aUnits) ->
      let ret = ScriptDom.MaxSizeDatabaseOption()
      ret.MaxSize <- aMaxSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Units <- aUnits
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | OnOffDatabaseOption(x) -> x.ToCs() :> ScriptDom.DatabaseOption (* 414 *)
    | PageVerifyDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.PageVerifyDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | ParameterizationDatabaseOption(isSimple=aIsSimple; optionKind=aOptionKind) ->
      let ret = ScriptDom.ParameterizationDatabaseOption()
      ret.IsSimple <- aIsSimple
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | PartnerDatabaseOption(optionKind=aOptionKind; partnerOption=aPartnerOption; partnerServer=aPartnerServer; timeout=aTimeout) ->
      let ret = ScriptDom.PartnerDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.PartnerOption <- aPartnerOption
      ret.PartnerServer <- aPartnerServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | QueryStoreDatabaseOption(clear=aClear; clearAll=aClearAll; optionKind=aOptionKind; optionState=aOptionState; options=aOptions) ->
      let ret = ScriptDom.QueryStoreDatabaseOption()
      ret.Clear <- aClear
      ret.ClearAll <- aClearAll
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | RecoveryDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.RecoveryDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | RemoteDataArchiveDatabaseOption(optionKind=aOptionKind; optionState=aOptionState; settings=aSettings) ->
      let ret = ScriptDom.RemoteDataArchiveDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      for e in aSettings do ret.Settings.Add (e.ToCs())
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | TargetRecoveryTimeDatabaseOption(optionKind=aOptionKind; recoveryTime=aRecoveryTime; unit=aUnit) ->
      let ret = ScriptDom.TargetRecoveryTimeDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.RecoveryTime <- aRecoveryTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unit <- aUnit
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | WitnessDatabaseOption(isOff=aIsOff; optionKind=aOptionKind; witnessServer=aWitnessServer) ->
      let ret = ScriptDom.WitnessDatabaseOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.WitnessServer <- aWitnessServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.DatabaseOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props DatabaseOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | AutomaticTuningDatabaseOption(optionKind=optionKind) -> optionKind
    | CatalogCollationOption(optionKind=optionKind) -> optionKind
    | ChangeTrackingDatabaseOption(optionKind=optionKind) -> optionKind
    | ContainmentDatabaseOption(optionKind=optionKind) -> optionKind
    | CursorDefaultDatabaseOption(optionKind=optionKind) -> optionKind
    | DelayedDurabilityDatabaseOption(optionKind=optionKind) -> optionKind
    | FileStreamDatabaseOption(optionKind=optionKind) -> optionKind
    | HadrDatabaseOption _ as x -> x.OptionKind
    | IdentifierDatabaseOption(optionKind=optionKind) -> optionKind
    | LiteralDatabaseOption(optionKind=optionKind) -> optionKind
    | MaxSizeDatabaseOption(optionKind=optionKind) -> optionKind
    | OnOffDatabaseOption _ as x -> x.OptionKind
    | PageVerifyDatabaseOption(optionKind=optionKind) -> optionKind
    | ParameterizationDatabaseOption(optionKind=optionKind) -> optionKind
    | PartnerDatabaseOption(optionKind=optionKind) -> optionKind
    | QueryStoreDatabaseOption(optionKind=optionKind) -> optionKind
    | RecoveryDatabaseOption(optionKind=optionKind) -> optionKind
    | RemoteDataArchiveDatabaseOption(optionKind=optionKind) -> optionKind
    | TargetRecoveryTimeDatabaseOption(optionKind=optionKind) -> optionKind
    | WitnessDatabaseOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.DatabaseOption) : DatabaseOption =
    match src with
    | :? ScriptDom.AutomaticTuningDatabaseOption as src ->
      DatabaseOption.AutomaticTuningDatabaseOption((src.AutomaticTuningState), (src.OptionKind), (src.Options |> Seq.map (AutomaticTuningOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CatalogCollationOption as src ->
      DatabaseOption.CatalogCollationOption((Option.ofNullable (src.CatalogCollation)), (src.OptionKind))
    | :? ScriptDom.ChangeTrackingDatabaseOption as src ->
      DatabaseOption.ChangeTrackingDatabaseOption((src.Details |> Seq.map (ChangeTrackingOptionDetail.FromCs) |> List.ofSeq), (src.OptionKind), (src.OptionState))
    | :? ScriptDom.ContainmentDatabaseOption as src ->
      DatabaseOption.ContainmentDatabaseOption((src.OptionKind), (src.Value))
    | :? ScriptDom.CursorDefaultDatabaseOption as src ->
      DatabaseOption.CursorDefaultDatabaseOption((src.IsLocal), (src.OptionKind))
    | :? ScriptDom.DelayedDurabilityDatabaseOption as src ->
      DatabaseOption.DelayedDurabilityDatabaseOption((src.OptionKind), (src.Value))
    | :? ScriptDom.FileStreamDatabaseOption as src ->
      DatabaseOption.FileStreamDatabaseOption((src.DirectoryName |> Option.ofObj |> Option.map (Literal.FromCs)), (Option.ofNullable (src.NonTransactedAccess)), (src.OptionKind))
    | :? ScriptDom.HadrDatabaseOption as src ->
      match src with
      | :? ScriptDom.HadrAvailabilityGroupDatabaseOption as src->
        DatabaseOption.HadrDatabaseOption((HadrDatabaseOption.HadrAvailabilityGroupDatabaseOption((src.GroupName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.HadrOption), (src.OptionKind))))
      | _ -> (* :? ScriptDom.HadrDatabaseOption as src *)
        DatabaseOption.HadrDatabaseOption((HadrDatabaseOption.Base((src.HadrOption), (src.OptionKind))))
    | :? ScriptDom.IdentifierDatabaseOption as src ->
      DatabaseOption.IdentifierDatabaseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.LiteralDatabaseOption as src ->
      DatabaseOption.LiteralDatabaseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.MaxSizeDatabaseOption as src ->
      DatabaseOption.MaxSizeDatabaseOption((src.MaxSize |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Units))
    | :? ScriptDom.OnOffDatabaseOption as src ->
      match src with
      | :? ScriptDom.AutoCreateStatisticsDatabaseOption as src->
        DatabaseOption.OnOffDatabaseOption((OnOffDatabaseOption.AutoCreateStatisticsDatabaseOption((src.HasIncremental), (src.IncrementalState), (src.OptionKind), (src.OptionState))))
      | _ -> (* :? ScriptDom.OnOffDatabaseOption as src *)
        DatabaseOption.OnOffDatabaseOption((OnOffDatabaseOption.Base((src.OptionKind), (src.OptionState))))
    | :? ScriptDom.PageVerifyDatabaseOption as src ->
      DatabaseOption.PageVerifyDatabaseOption((src.OptionKind), (src.Value))
    | :? ScriptDom.ParameterizationDatabaseOption as src ->
      DatabaseOption.ParameterizationDatabaseOption((src.IsSimple), (src.OptionKind))
    | :? ScriptDom.PartnerDatabaseOption as src ->
      DatabaseOption.PartnerDatabaseOption((src.OptionKind), (src.PartnerOption), (src.PartnerServer |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Timeout |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.QueryStoreDatabaseOption as src ->
      DatabaseOption.QueryStoreDatabaseOption((src.Clear), (src.ClearAll), (src.OptionKind), (src.OptionState), (src.Options |> Seq.map (QueryStoreOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.RecoveryDatabaseOption as src ->
      DatabaseOption.RecoveryDatabaseOption((src.OptionKind), (src.Value))
    | :? ScriptDom.RemoteDataArchiveDatabaseOption as src ->
      DatabaseOption.RemoteDataArchiveDatabaseOption((src.OptionKind), (src.OptionState), (src.Settings |> Seq.map (RemoteDataArchiveDatabaseSetting.FromCs) |> List.ofSeq))
    | :? ScriptDom.TargetRecoveryTimeDatabaseOption as src ->
      DatabaseOption.TargetRecoveryTimeDatabaseOption((src.OptionKind), (src.RecoveryTime |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unit))
    | :? ScriptDom.WitnessDatabaseOption as src ->
      DatabaseOption.WitnessDatabaseOption((src.IsOff), (src.OptionKind), (src.WitnessServer |> Option.ofObj |> Option.map (Literal.FromCs)))
    | _ -> (* :? ScriptDom.DatabaseOption as src *)
      DatabaseOption.Base(((src.OptionKind)))
and DeclareVariableElement = (* IsAbstract = false , children = 1*)
  | Base of dataType:DataTypeReference option * nullable:NullableConstraintDefinition option * value:ScalarExpression option * variableName:Identifier option
  | ProcedureParameter of dataType:DataTypeReference option * isVarying:bool * modifier:ScriptDom.ParameterModifier * nullable:NullableConstraintDefinition option * value:ScalarExpression option * variableName:Identifier option
  member this.ToCs() : ScriptDom.DeclareVariableElement =
    match this with
    | ProcedureParameter(dataType=aDataType; isVarying=aIsVarying; modifier=aModifier; nullable=aNullable; value=aValue; variableName=aVariableName) ->
      let ret = ScriptDom.ProcedureParameter()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsVarying <- aIsVarying
      ret.Modifier <- aModifier
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DeclareVariableElement (* 404 *)
    | Base(dataType=aDataType; nullable=aNullable; value=aValue; variableName=aVariableName) ->

      let ret = ScriptDom.DeclareVariableElement()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props DeclareVariableElement 
  member this.DataType = 
    match this with
    | Base (dataType=dataType) -> dataType
    | ProcedureParameter(dataType=dataType) -> dataType
  member this.Nullable = 
    match this with
    | Base (nullable=nullable) -> nullable
    | ProcedureParameter(nullable=nullable) -> nullable
  member this.Value = 
    match this with
    | Base (value=value) -> value
    | ProcedureParameter(value=value) -> value
  member this.VariableName = 
    match this with
    | Base (variableName=variableName) -> variableName
    | ProcedureParameter(variableName=variableName) -> variableName
  static member FromCs(src:ScriptDom.DeclareVariableElement) : DeclareVariableElement =
    match src with
    | :? ScriptDom.ProcedureParameter as src ->
      DeclareVariableElement.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | _ -> (* :? ScriptDom.DeclareVariableElement as src *)
      DeclareVariableElement.Base(((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs))))
and DialogOption = (* IsAbstract = true , children = 2*)
  | OnOffDialogOption of optionKind:ScriptDom.DialogOptionKind * optionState:ScriptDom.OptionState
  | ScalarExpressionDialogOption of optionKind:ScriptDom.DialogOptionKind * value:ScalarExpression option
  member this.ToCs() : ScriptDom.DialogOption =
    match this with
    | OnOffDialogOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffDialogOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DialogOption (* 404 *)
    | ScalarExpressionDialogOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ScalarExpressionDialogOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DialogOption (* 404 *)
//// shared props DialogOption 
  member this.OptionKind = 
    match this with
    | OnOffDialogOption(optionKind=optionKind) -> optionKind
    | ScalarExpressionDialogOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.DialogOption) : DialogOption =
    match src with
    | :? ScriptDom.OnOffDialogOption as src ->
      DialogOption.OnOffDialogOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.ScalarExpressionDialogOption as src ->
      DialogOption.ScalarExpressionDialogOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and DropClusteredConstraintOption = (* IsAbstract = true , children = 4*)
  | DropClusteredConstraintMoveOption of optionKind:ScriptDom.DropClusteredConstraintOptionKind * optionValue:FileGroupOrPartitionScheme option
  | DropClusteredConstraintStateOption of optionKind:ScriptDom.DropClusteredConstraintOptionKind * optionState:ScriptDom.OptionState
  | DropClusteredConstraintValueOption of optionKind:ScriptDom.DropClusteredConstraintOptionKind * optionValue:Literal option
  | DropClusteredConstraintWaitAtLowPriorityLockOption of optionKind:ScriptDom.DropClusteredConstraintOptionKind * options:(LowPriorityLockWaitOption) list
  member this.ToCs() : ScriptDom.DropClusteredConstraintOption =
    match this with
    | DropClusteredConstraintMoveOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.DropClusteredConstraintMoveOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropClusteredConstraintOption (* 404 *)
    | DropClusteredConstraintStateOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.DropClusteredConstraintStateOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.DropClusteredConstraintOption (* 404 *)
    | DropClusteredConstraintValueOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.DropClusteredConstraintValueOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropClusteredConstraintOption (* 404 *)
    | DropClusteredConstraintWaitAtLowPriorityLockOption(optionKind=aOptionKind; options=aOptions) ->
      let ret = ScriptDom.DropClusteredConstraintWaitAtLowPriorityLockOption()
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DropClusteredConstraintOption (* 404 *)
//// shared props DropClusteredConstraintOption 
  member this.OptionKind = 
    match this with
    | DropClusteredConstraintMoveOption(optionKind=optionKind) -> optionKind
    | DropClusteredConstraintStateOption(optionKind=optionKind) -> optionKind
    | DropClusteredConstraintValueOption(optionKind=optionKind) -> optionKind
    | DropClusteredConstraintWaitAtLowPriorityLockOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.DropClusteredConstraintOption) : DropClusteredConstraintOption =
    match src with
    | :? ScriptDom.DropClusteredConstraintMoveOption as src ->
      DropClusteredConstraintOption.DropClusteredConstraintMoveOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)))
    | :? ScriptDom.DropClusteredConstraintStateOption as src ->
      DropClusteredConstraintOption.DropClusteredConstraintStateOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.DropClusteredConstraintValueOption as src ->
      DropClusteredConstraintOption.DropClusteredConstraintValueOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.DropClusteredConstraintWaitAtLowPriorityLockOption as src ->
      DropClusteredConstraintOption.DropClusteredConstraintWaitAtLowPriorityLockOption((src.OptionKind), (src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))
and DropIndexClauseBase = (* IsAbstract = true , children = 2*)
  | BackwardsCompatibleDropIndexClause of index:ChildObjectName option
  | DropIndexClause of index:Identifier option * object:SchemaObjectName option * options:(IndexOption) list
  member this.ToCs() : ScriptDom.DropIndexClauseBase =
    match this with
    | BackwardsCompatibleDropIndexClause(index=aIndex) ->
      let ret = ScriptDom.BackwardsCompatibleDropIndexClause()
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropIndexClauseBase (* 404 *)
    | DropIndexClause(index=aIndex; object=aObject; options=aOptions) ->
      let ret = ScriptDom.DropIndexClause()
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.DropIndexClauseBase (* 404 *)
  static member FromCs(src:ScriptDom.DropIndexClauseBase) : DropIndexClauseBase =
    match src with
    | :? ScriptDom.BackwardsCompatibleDropIndexClause as src ->
      DropIndexClauseBase.BackwardsCompatibleDropIndexClause((src.Index |> Option.ofObj |> Option.map (ChildObjectName.FromCs)))
    | :? ScriptDom.DropIndexClause as src ->
      DropIndexClauseBase.DropIndexClause((src.Index |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (IndexOption.FromCs) |> List.ofSeq))
and EncryptionSource = (* IsAbstract = true , children = 3*)
  | AssemblyEncryptionSource of assembly:Identifier option
  | FileEncryptionSource of file:Literal option * isExecutable:bool
  | ProviderEncryptionSource of keyOptions:(KeyOption) list * name:Identifier option
  member this.ToCs() : ScriptDom.EncryptionSource =
    match this with
    | AssemblyEncryptionSource(assembly=aAssembly) ->
      let ret = ScriptDom.AssemblyEncryptionSource()
      ret.Assembly <- aAssembly |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.EncryptionSource (* 404 *)
    | FileEncryptionSource(file=aFile; isExecutable=aIsExecutable) ->
      let ret = ScriptDom.FileEncryptionSource()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsExecutable <- aIsExecutable
      ret :> ScriptDom.EncryptionSource (* 404 *)
    | ProviderEncryptionSource(keyOptions=aKeyOptions; name=aName) ->
      let ret = ScriptDom.ProviderEncryptionSource()
      for e in aKeyOptions do ret.KeyOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.EncryptionSource (* 404 *)
  static member FromCs(src:ScriptDom.EncryptionSource) : EncryptionSource =
    match src with
    | :? ScriptDom.AssemblyEncryptionSource as src ->
      EncryptionSource.AssemblyEncryptionSource((src.Assembly |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FileEncryptionSource as src ->
      EncryptionSource.FileEncryptionSource((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsExecutable))
    | :? ScriptDom.ProviderEncryptionSource as src ->
      EncryptionSource.ProviderEncryptionSource((src.KeyOptions |> Seq.map (KeyOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and EndpointProtocolOption = (* IsAbstract = true , children = 5*)
  | AuthenticationEndpointProtocolOption of authenticationTypes:ScriptDom.AuthenticationTypes * kind:ScriptDom.EndpointProtocolOptions
  | CompressionEndpointProtocolOption of isEnabled:bool * kind:ScriptDom.EndpointProtocolOptions
  | ListenerIPEndpointProtocolOption of iPv4PartOne:IPv4 option * iPv4PartTwo:IPv4 option * iPv6:Literal option * isAll:bool * kind:ScriptDom.EndpointProtocolOptions
  | LiteralEndpointProtocolOption of kind:ScriptDom.EndpointProtocolOptions * value:Literal option
  | PortsEndpointProtocolOption of kind:ScriptDom.EndpointProtocolOptions * portTypes:ScriptDom.PortTypes
  member this.ToCs() : ScriptDom.EndpointProtocolOption =
    match this with
    | AuthenticationEndpointProtocolOption(authenticationTypes=aAuthenticationTypes; kind=aKind) ->
      let ret = ScriptDom.AuthenticationEndpointProtocolOption()
      ret.AuthenticationTypes <- aAuthenticationTypes
      ret.Kind <- aKind
      ret :> ScriptDom.EndpointProtocolOption (* 404 *)
    | CompressionEndpointProtocolOption(isEnabled=aIsEnabled; kind=aKind) ->
      let ret = ScriptDom.CompressionEndpointProtocolOption()
      ret.IsEnabled <- aIsEnabled
      ret.Kind <- aKind
      ret :> ScriptDom.EndpointProtocolOption (* 404 *)
    | ListenerIPEndpointProtocolOption(iPv4PartOne=aIPv4PartOne; iPv4PartTwo=aIPv4PartTwo; iPv6=aIPv6; isAll=aIsAll; kind=aKind) ->
      let ret = ScriptDom.ListenerIPEndpointProtocolOption()
      ret.IPv4PartOne <- aIPv4PartOne |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IPv4PartTwo <- aIPv4PartTwo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IPv6 <- aIPv6 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsAll <- aIsAll
      ret.Kind <- aKind
      ret :> ScriptDom.EndpointProtocolOption (* 404 *)
    | LiteralEndpointProtocolOption(kind=aKind; value=aValue) ->
      let ret = ScriptDom.LiteralEndpointProtocolOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.EndpointProtocolOption (* 404 *)
    | PortsEndpointProtocolOption(kind=aKind; portTypes=aPortTypes) ->
      let ret = ScriptDom.PortsEndpointProtocolOption()
      ret.Kind <- aKind
      ret.PortTypes <- aPortTypes
      ret :> ScriptDom.EndpointProtocolOption (* 404 *)
//// shared props EndpointProtocolOption 
  member this.Kind = 
    match this with
    | AuthenticationEndpointProtocolOption(kind=kind) -> kind
    | CompressionEndpointProtocolOption(kind=kind) -> kind
    | ListenerIPEndpointProtocolOption(kind=kind) -> kind
    | LiteralEndpointProtocolOption(kind=kind) -> kind
    | PortsEndpointProtocolOption(kind=kind) -> kind
  static member FromCs(src:ScriptDom.EndpointProtocolOption) : EndpointProtocolOption =
    match src with
    | :? ScriptDom.AuthenticationEndpointProtocolOption as src ->
      EndpointProtocolOption.AuthenticationEndpointProtocolOption((src.AuthenticationTypes), (src.Kind))
    | :? ScriptDom.CompressionEndpointProtocolOption as src ->
      EndpointProtocolOption.CompressionEndpointProtocolOption((src.IsEnabled), (src.Kind))
    | :? ScriptDom.ListenerIPEndpointProtocolOption as src ->
      EndpointProtocolOption.ListenerIPEndpointProtocolOption((src.IPv4PartOne |> Option.ofObj |> Option.map (IPv4.FromCs)), (src.IPv4PartTwo |> Option.ofObj |> Option.map (IPv4.FromCs)), (src.IPv6 |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsAll), (src.Kind))
    | :? ScriptDom.LiteralEndpointProtocolOption as src ->
      EndpointProtocolOption.LiteralEndpointProtocolOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.PortsEndpointProtocolOption as src ->
      EndpointProtocolOption.PortsEndpointProtocolOption((src.Kind), (src.PortTypes))
and EventTypeGroupContainer = (* IsAbstract = true , children = 2*)
  | EventGroupContainer of eventGroup:ScriptDom.EventNotificationEventGroup
  | EventTypeContainer of eventType:ScriptDom.EventNotificationEventType
  member this.ToCs() : ScriptDom.EventTypeGroupContainer =
    match this with
    | EventGroupContainer(eventGroup=aEventGroup) ->
      let ret = ScriptDom.EventGroupContainer()
      ret.EventGroup <- aEventGroup
      ret :> ScriptDom.EventTypeGroupContainer (* 404 *)
    | EventTypeContainer(eventType=aEventType) ->
      let ret = ScriptDom.EventTypeContainer()
      ret.EventType <- aEventType
      ret :> ScriptDom.EventTypeGroupContainer (* 404 *)
  static member FromCs(src:ScriptDom.EventTypeGroupContainer) : EventTypeGroupContainer =
    match src with
    | :? ScriptDom.EventGroupContainer as src ->
      EventTypeGroupContainer.EventGroupContainer((src.EventGroup))
    | :? ScriptDom.EventTypeContainer as src ->
      EventTypeGroupContainer.EventTypeContainer((src.EventType))
and ExecutableEntity = (* IsAbstract = true , children = 2*)
  | ExecutableProcedureReference of adHocDataSource:AdHocDataSource option * parameters:(ExecuteParameter) list * procedureReference:ProcedureReferenceName option
  | ExecutableStringList of parameters:(ExecuteParameter) list * strings:(ValueExpression) list
  member this.ToCs() : ScriptDom.ExecutableEntity =
    match this with
    | ExecutableProcedureReference(adHocDataSource=aAdHocDataSource; parameters=aParameters; procedureReference=aProcedureReference) ->
      let ret = ScriptDom.ExecutableProcedureReference()
      ret.AdHocDataSource <- aAdHocDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExecutableEntity (* 404 *)
    | ExecutableStringList(parameters=aParameters; strings=aStrings) ->
      let ret = ScriptDom.ExecutableStringList()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      for e in aStrings do ret.Strings.Add (e.ToCs())
      ret :> ScriptDom.ExecutableEntity (* 404 *)
//// shared props ExecutableEntity 
  member this.Parameters = 
    match this with
    | ExecutableProcedureReference(parameters=parameters) -> parameters
    | ExecutableStringList(parameters=parameters) -> parameters
  static member FromCs(src:ScriptDom.ExecutableEntity) : ExecutableEntity =
    match src with
    | :? ScriptDom.ExecutableProcedureReference as src ->
      ExecutableEntity.ExecutableProcedureReference((src.AdHocDataSource |> Option.ofObj |> Option.map (AdHocDataSource.FromCs)), (src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReferenceName.FromCs)))
    | :? ScriptDom.ExecutableStringList as src ->
      ExecutableEntity.ExecutableStringList((src.Parameters |> Seq.map (fun src -> ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))) |> List.ofSeq), (src.Strings |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))
and ExecuteOption = (* IsAbstract = false , children = 1*)
  | Base of optionKind:ScriptDom.ExecuteOptionKind
  | ResultSetsExecuteOption of definitions:(ResultSetDefinition) list * optionKind:ScriptDom.ExecuteOptionKind * resultSetsOptionKind:ScriptDom.ResultSetsOptionKind
  member this.ToCs() : ScriptDom.ExecuteOption =
    match this with
    | ResultSetsExecuteOption(definitions=aDefinitions; optionKind=aOptionKind; resultSetsOptionKind=aResultSetsOptionKind) ->
      let ret = ScriptDom.ResultSetsExecuteOption()
      for e in aDefinitions do ret.Definitions.Add (e.ToCs())
      ret.OptionKind <- aOptionKind
      ret.ResultSetsOptionKind <- aResultSetsOptionKind
      ret :> ScriptDom.ExecuteOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.ExecuteOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props ExecuteOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | ResultSetsExecuteOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.ExecuteOption) : ExecuteOption =
    match src with
    | :? ScriptDom.ResultSetsExecuteOption as src ->
      ExecuteOption.ResultSetsExecuteOption((src.Definitions |> Seq.map (ResultSetDefinition.FromCs) |> List.ofSeq), (src.OptionKind), (src.ResultSetsOptionKind))
    | _ -> (* :? ScriptDom.ExecuteOption as src *)
      ExecuteOption.Base(((src.OptionKind)))
and ExternalDataSourceOption = (* IsAbstract = true , children = 1*)
  | ExternalDataSourceLiteralOrIdentifierOption of optionKind:ScriptDom.ExternalDataSourceOptionKind * value:IdentifierOrValueExpression option
  member this.ToCs() : ScriptDom.ExternalDataSourceOption =
    match this with
    | ExternalDataSourceLiteralOrIdentifierOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ExternalDataSourceLiteralOrIdentifierOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalDataSourceOption (* 404 *)
//// shared props ExternalDataSourceOption 
  member this.OptionKind = 
    match this with
    | ExternalDataSourceLiteralOrIdentifierOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.ExternalDataSourceOption) : ExternalDataSourceOption =
    match src with
    | :? ScriptDom.ExternalDataSourceLiteralOrIdentifierOption as src ->
      ExternalDataSourceOption.ExternalDataSourceLiteralOrIdentifierOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
and ExternalFileFormatOption = (* IsAbstract = true , children = 3*)
  | ExternalFileFormatContainerOption of optionKind:ScriptDom.ExternalFileFormatOptionKind * suboptions:(ExternalFileFormatOption) list
  | ExternalFileFormatLiteralOption of optionKind:ScriptDom.ExternalFileFormatOptionKind * value:Literal option
  | ExternalFileFormatUseDefaultTypeOption of externalFileFormatUseDefaultType:ScriptDom.ExternalFileFormatUseDefaultType * optionKind:ScriptDom.ExternalFileFormatOptionKind
  member this.ToCs() : ScriptDom.ExternalFileFormatOption =
    match this with
    | ExternalFileFormatContainerOption(optionKind=aOptionKind; suboptions=aSuboptions) ->
      let ret = ScriptDom.ExternalFileFormatContainerOption()
      ret.OptionKind <- aOptionKind
      for e in aSuboptions do ret.Suboptions.Add (e.ToCs())
      ret :> ScriptDom.ExternalFileFormatOption (* 404 *)
    | ExternalFileFormatLiteralOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ExternalFileFormatLiteralOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalFileFormatOption (* 404 *)
    | ExternalFileFormatUseDefaultTypeOption(externalFileFormatUseDefaultType=aExternalFileFormatUseDefaultType; optionKind=aOptionKind) ->
      let ret = ScriptDom.ExternalFileFormatUseDefaultTypeOption()
      ret.ExternalFileFormatUseDefaultType <- aExternalFileFormatUseDefaultType
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.ExternalFileFormatOption (* 404 *)
//// shared props ExternalFileFormatOption 
  member this.OptionKind = 
    match this with
    | ExternalFileFormatContainerOption(optionKind=optionKind) -> optionKind
    | ExternalFileFormatLiteralOption(optionKind=optionKind) -> optionKind
    | ExternalFileFormatUseDefaultTypeOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.ExternalFileFormatOption) : ExternalFileFormatOption =
    match src with
    | :? ScriptDom.ExternalFileFormatContainerOption as src ->
      ExternalFileFormatOption.ExternalFileFormatContainerOption((src.OptionKind), (src.Suboptions |> Seq.map (ExternalFileFormatOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.ExternalFileFormatLiteralOption as src ->
      ExternalFileFormatOption.ExternalFileFormatLiteralOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ExternalFileFormatUseDefaultTypeOption as src ->
      ExternalFileFormatOption.ExternalFileFormatUseDefaultTypeOption((src.ExternalFileFormatUseDefaultType), (src.OptionKind))
and ExternalTableDistributionPolicy = (* IsAbstract = true , children = 3*)
  | ExternalTableReplicatedDistributionPolicy 
  | ExternalTableRoundRobinDistributionPolicy 
  | ExternalTableShardedDistributionPolicy of shardingColumn:Identifier option
  member this.ToCs() : ScriptDom.ExternalTableDistributionPolicy =
    match this with
    | ExternalTableReplicatedDistributionPolicy -> ScriptDom.ExternalTableReplicatedDistributionPolicy() :> ScriptDom.ExternalTableDistributionPolicy (* 396 *)
    | ExternalTableRoundRobinDistributionPolicy -> ScriptDom.ExternalTableRoundRobinDistributionPolicy() :> ScriptDom.ExternalTableDistributionPolicy (* 396 *)
    | ExternalTableShardedDistributionPolicy(shardingColumn=aShardingColumn) ->
      let ret = ScriptDom.ExternalTableShardedDistributionPolicy()
      ret.ShardingColumn <- aShardingColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableDistributionPolicy (* 404 *)
  static member FromCs(src:ScriptDom.ExternalTableDistributionPolicy) : ExternalTableDistributionPolicy =
    match src with
    | :? ScriptDom.ExternalTableReplicatedDistributionPolicy as src ->
      ExternalTableDistributionPolicy.ExternalTableReplicatedDistributionPolicy
    | :? ScriptDom.ExternalTableRoundRobinDistributionPolicy as src ->
      ExternalTableDistributionPolicy.ExternalTableRoundRobinDistributionPolicy
    | :? ScriptDom.ExternalTableShardedDistributionPolicy as src ->
      ExternalTableDistributionPolicy.ExternalTableShardedDistributionPolicy((src.ShardingColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
and ExternalTableOption = (* IsAbstract = true , children = 3*)
  | ExternalTableDistributionOption of optionKind:ScriptDom.ExternalTableOptionKind * value:ExternalTableDistributionPolicy option
  | ExternalTableLiteralOrIdentifierOption of optionKind:ScriptDom.ExternalTableOptionKind * value:IdentifierOrValueExpression option
  | ExternalTableRejectTypeOption of optionKind:ScriptDom.ExternalTableOptionKind * value:ScriptDom.ExternalTableRejectType
  member this.ToCs() : ScriptDom.ExternalTableOption =
    match this with
    | ExternalTableDistributionOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ExternalTableDistributionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableOption (* 404 *)
    | ExternalTableLiteralOrIdentifierOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ExternalTableLiteralOrIdentifierOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableOption (* 404 *)
    | ExternalTableRejectTypeOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ExternalTableRejectTypeOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.ExternalTableOption (* 404 *)
//// shared props ExternalTableOption 
  member this.OptionKind = 
    match this with
    | ExternalTableDistributionOption(optionKind=optionKind) -> optionKind
    | ExternalTableLiteralOrIdentifierOption(optionKind=optionKind) -> optionKind
    | ExternalTableRejectTypeOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.ExternalTableOption) : ExternalTableOption =
    match src with
    | :? ScriptDom.ExternalTableDistributionOption as src ->
      ExternalTableOption.ExternalTableDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ExternalTableDistributionPolicy.FromCs)))
    | :? ScriptDom.ExternalTableLiteralOrIdentifierOption as src ->
      ExternalTableOption.ExternalTableLiteralOrIdentifierOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.ExternalTableRejectTypeOption as src ->
      ExternalTableOption.ExternalTableRejectTypeOption((src.OptionKind), (src.Value))
and FileDeclarationOption = (* IsAbstract = false , children = 5*)
  | Base of optionKind:ScriptDom.FileDeclarationOptionKind
  | FileGrowthFileDeclarationOption of growthIncrement:Literal option * optionKind:ScriptDom.FileDeclarationOptionKind * units:ScriptDom.MemoryUnit
  | FileNameFileDeclarationOption of oSFileName:Literal option * optionKind:ScriptDom.FileDeclarationOptionKind
  | MaxSizeFileDeclarationOption of maxSize:Literal option * optionKind:ScriptDom.FileDeclarationOptionKind * units:ScriptDom.MemoryUnit * unlimited:bool
  | NameFileDeclarationOption of isNewName:bool * logicalFileName:IdentifierOrValueExpression option * optionKind:ScriptDom.FileDeclarationOptionKind
  | SizeFileDeclarationOption of optionKind:ScriptDom.FileDeclarationOptionKind * size:Literal option * units:ScriptDom.MemoryUnit
  member this.ToCs() : ScriptDom.FileDeclarationOption =
    match this with
    | FileGrowthFileDeclarationOption(growthIncrement=aGrowthIncrement; optionKind=aOptionKind; units=aUnits) ->
      let ret = ScriptDom.FileGrowthFileDeclarationOption()
      ret.GrowthIncrement <- aGrowthIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Units <- aUnits
      ret :> ScriptDom.FileDeclarationOption (* 404 *)
    | FileNameFileDeclarationOption(oSFileName=aOSFileName; optionKind=aOptionKind) ->
      let ret = ScriptDom.FileNameFileDeclarationOption()
      ret.OSFileName <- aOSFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.FileDeclarationOption (* 404 *)
    | MaxSizeFileDeclarationOption(maxSize=aMaxSize; optionKind=aOptionKind; units=aUnits; unlimited=aUnlimited) ->
      let ret = ScriptDom.MaxSizeFileDeclarationOption()
      ret.MaxSize <- aMaxSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Units <- aUnits
      ret.Unlimited <- aUnlimited
      ret :> ScriptDom.FileDeclarationOption (* 404 *)
    | NameFileDeclarationOption(isNewName=aIsNewName; logicalFileName=aLogicalFileName; optionKind=aOptionKind) ->
      let ret = ScriptDom.NameFileDeclarationOption()
      ret.IsNewName <- aIsNewName
      ret.LogicalFileName <- aLogicalFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.FileDeclarationOption (* 404 *)
    | SizeFileDeclarationOption(optionKind=aOptionKind; size=aSize; units=aUnits) ->
      let ret = ScriptDom.SizeFileDeclarationOption()
      ret.OptionKind <- aOptionKind
      ret.Size <- aSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Units <- aUnits
      ret :> ScriptDom.FileDeclarationOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.FileDeclarationOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props FileDeclarationOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | FileGrowthFileDeclarationOption(optionKind=optionKind) -> optionKind
    | FileNameFileDeclarationOption(optionKind=optionKind) -> optionKind
    | MaxSizeFileDeclarationOption(optionKind=optionKind) -> optionKind
    | NameFileDeclarationOption(optionKind=optionKind) -> optionKind
    | SizeFileDeclarationOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.FileDeclarationOption) : FileDeclarationOption =
    match src with
    | :? ScriptDom.FileGrowthFileDeclarationOption as src ->
      FileDeclarationOption.FileGrowthFileDeclarationOption((src.GrowthIncrement |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Units))
    | :? ScriptDom.FileNameFileDeclarationOption as src ->
      FileDeclarationOption.FileNameFileDeclarationOption((src.OSFileName |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.MaxSizeFileDeclarationOption as src ->
      FileDeclarationOption.MaxSizeFileDeclarationOption((src.MaxSize |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Units), (src.Unlimited))
    | :? ScriptDom.NameFileDeclarationOption as src ->
      FileDeclarationOption.NameFileDeclarationOption((src.IsNewName), (src.LogicalFileName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.OptionKind))
    | :? ScriptDom.SizeFileDeclarationOption as src ->
      FileDeclarationOption.SizeFileDeclarationOption((src.OptionKind), (src.Size |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Units))
    | _ -> (* :? ScriptDom.FileDeclarationOption as src *)
      FileDeclarationOption.Base(((src.OptionKind)))
and ForClause = (* IsAbstract = true , children = 7*)
  | BrowseForClause 
  | JsonForClause of options:(JsonForClauseOption) list
  | JsonForClauseOption of optionKind:ScriptDom.JsonForClauseOptions * value:Literal option
  | ReadOnlyForClause 
  | UpdateForClause of columns:(ColumnReferenceExpression) list
  | XmlForClause of options:(XmlForClauseOption) list
  | XmlForClauseOption of optionKind:ScriptDom.XmlForClauseOptions * value:Literal option
  member this.ToCs() : ScriptDom.ForClause =
    match this with
    | BrowseForClause -> ScriptDom.BrowseForClause() :> ScriptDom.ForClause (* 396 *)
    | JsonForClause(options=aOptions) ->
      let ret = ScriptDom.JsonForClause()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.ForClause (* 404 *)
    | JsonForClauseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.JsonForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ForClause (* 404 *)
    | ReadOnlyForClause -> ScriptDom.ReadOnlyForClause() :> ScriptDom.ForClause (* 396 *)
    | UpdateForClause(columns=aColumns) ->
      let ret = ScriptDom.UpdateForClause()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret :> ScriptDom.ForClause (* 404 *)
    | XmlForClause(options=aOptions) ->
      let ret = ScriptDom.XmlForClause()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.ForClause (* 404 *)
    | XmlForClauseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.XmlForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ForClause (* 404 *)
  static member FromCs(src:ScriptDom.ForClause) : ForClause =
    match src with
    | :? ScriptDom.BrowseForClause as src ->
      ForClause.BrowseForClause
    | :? ScriptDom.JsonForClause as src ->
      ForClause.JsonForClause((src.Options |> Seq.map (fun src -> JsonForClauseOption.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.JsonForClauseOption as src ->
      ForClause.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ReadOnlyForClause as src ->
      ForClause.ReadOnlyForClause
    | :? ScriptDom.UpdateForClause as src ->
      ForClause.UpdateForClause((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.XmlForClause as src ->
      ForClause.XmlForClause((src.Options |> Seq.map (fun src -> XmlForClauseOption.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.XmlForClauseOption as src ->
      ForClause.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and FullTextCatalogOption = (* IsAbstract = true , children = 1*)
  | OnOffFullTextCatalogOption of optionKind:ScriptDom.FullTextCatalogOptionKind * optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.FullTextCatalogOption =
    match this with
    | OnOffFullTextCatalogOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffFullTextCatalogOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.FullTextCatalogOption (* 404 *)
//// shared props FullTextCatalogOption 
  member this.OptionKind = 
    match this with
    | OnOffFullTextCatalogOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.FullTextCatalogOption) : FullTextCatalogOption =
    match src with
    | :? ScriptDom.OnOffFullTextCatalogOption as src ->
      FullTextCatalogOption.OnOffFullTextCatalogOption((src.OptionKind), (src.OptionState))
and FullTextIndexOption = (* IsAbstract = true , children = 3*)
  | ChangeTrackingFullTextIndexOption of optionKind:ScriptDom.FullTextIndexOptionKind * value:ScriptDom.ChangeTrackingOption
  | SearchPropertyListFullTextIndexOption of isOff:bool * optionKind:ScriptDom.FullTextIndexOptionKind * propertyListName:Identifier option
  | StopListFullTextIndexOption of isOff:bool * optionKind:ScriptDom.FullTextIndexOptionKind * stopListName:Identifier option
  member this.ToCs() : ScriptDom.FullTextIndexOption =
    match this with
    | ChangeTrackingFullTextIndexOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ChangeTrackingFullTextIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.FullTextIndexOption (* 404 *)
    | SearchPropertyListFullTextIndexOption(isOff=aIsOff; optionKind=aOptionKind; propertyListName=aPropertyListName) ->
      let ret = ScriptDom.SearchPropertyListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.PropertyListName <- aPropertyListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FullTextIndexOption (* 404 *)
    | StopListFullTextIndexOption(isOff=aIsOff; optionKind=aOptionKind; stopListName=aStopListName) ->
      let ret = ScriptDom.StopListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.StopListName <- aStopListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FullTextIndexOption (* 404 *)
//// shared props FullTextIndexOption 
  member this.OptionKind = 
    match this with
    | ChangeTrackingFullTextIndexOption(optionKind=optionKind) -> optionKind
    | SearchPropertyListFullTextIndexOption(optionKind=optionKind) -> optionKind
    | StopListFullTextIndexOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.FullTextIndexOption) : FullTextIndexOption =
    match src with
    | :? ScriptDom.ChangeTrackingFullTextIndexOption as src ->
      FullTextIndexOption.ChangeTrackingFullTextIndexOption((src.OptionKind), (src.Value))
    | :? ScriptDom.SearchPropertyListFullTextIndexOption as src ->
      FullTextIndexOption.SearchPropertyListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.PropertyListName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.StopListFullTextIndexOption as src ->
      FullTextIndexOption.StopListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.StopListName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and FunctionOption = (* IsAbstract = false , children = 2*)
  | Base of optionKind:ScriptDom.FunctionOptionKind
  | ExecuteAsFunctionOption of executeAs:ExecuteAsClause option * optionKind:ScriptDom.FunctionOptionKind
  | InlineFunctionOption of optionKind:ScriptDom.FunctionOptionKind * optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.FunctionOption =
    match this with
    | ExecuteAsFunctionOption(executeAs=aExecuteAs; optionKind=aOptionKind) ->
      let ret = ScriptDom.ExecuteAsFunctionOption()
      ret.ExecuteAs <- aExecuteAs |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.FunctionOption (* 404 *)
    | InlineFunctionOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.InlineFunctionOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.FunctionOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.FunctionOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props FunctionOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | ExecuteAsFunctionOption(optionKind=optionKind) -> optionKind
    | InlineFunctionOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.FunctionOption) : FunctionOption =
    match src with
    | :? ScriptDom.ExecuteAsFunctionOption as src ->
      FunctionOption.ExecuteAsFunctionOption((src.ExecuteAs |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)), (src.OptionKind))
    | :? ScriptDom.InlineFunctionOption as src ->
      FunctionOption.InlineFunctionOption((src.OptionKind), (src.OptionState))
    | _ -> (* :? ScriptDom.FunctionOption as src *)
      FunctionOption.Base(((src.OptionKind)))
and FunctionReturnType = (* IsAbstract = true , children = 3*)
  | ScalarFunctionReturnType of dataType:DataTypeReference option
  | SelectFunctionReturnType of selectStatement:SelectStatement option
  | TableValuedFunctionReturnType of declareTableVariableBody:DeclareTableVariableBody option
  member this.ToCs() : ScriptDom.FunctionReturnType =
    match this with
    | ScalarFunctionReturnType(dataType=aDataType) ->
      let ret = ScriptDom.ScalarFunctionReturnType()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionReturnType (* 404 *)
    | SelectFunctionReturnType(selectStatement=aSelectStatement) ->
      let ret = ScriptDom.SelectFunctionReturnType()
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionReturnType (* 404 *)
    | TableValuedFunctionReturnType(declareTableVariableBody=aDeclareTableVariableBody) ->
      let ret = ScriptDom.TableValuedFunctionReturnType()
      ret.DeclareTableVariableBody <- aDeclareTableVariableBody |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionReturnType (* 404 *)
  static member FromCs(src:ScriptDom.FunctionReturnType) : FunctionReturnType =
    match src with
    | :? ScriptDom.ScalarFunctionReturnType as src ->
      FunctionReturnType.ScalarFunctionReturnType((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))
    | :? ScriptDom.SelectFunctionReturnType as src ->
      FunctionReturnType.SelectFunctionReturnType((src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)))
    | :? ScriptDom.TableValuedFunctionReturnType as src ->
      FunctionReturnType.TableValuedFunctionReturnType((src.DeclareTableVariableBody |> Option.ofObj |> Option.map (DeclareTableVariableBody.FromCs)))
and GroupingSpecification = (* IsAbstract = true , children = 6*)
  | CompositeGroupingSpecification of items:(GroupingSpecification) list
  | CubeGroupingSpecification of arguments:(GroupingSpecification) list
  | ExpressionGroupingSpecification of expression:ScalarExpression option
  | GrandTotalGroupingSpecification 
  | GroupingSetsGroupingSpecification of sets:(GroupingSpecification) list
  | RollupGroupingSpecification of arguments:(GroupingSpecification) list
  member this.ToCs() : ScriptDom.GroupingSpecification =
    match this with
    | CompositeGroupingSpecification(items=aItems) ->
      let ret = ScriptDom.CompositeGroupingSpecification()
      for e in aItems do ret.Items.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 404 *)
    | CubeGroupingSpecification(arguments=aArguments) ->
      let ret = ScriptDom.CubeGroupingSpecification()
      for e in aArguments do ret.Arguments.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 404 *)
    | ExpressionGroupingSpecification(expression=aExpression) ->
      let ret = ScriptDom.ExpressionGroupingSpecification()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.GroupingSpecification (* 404 *)
    | GrandTotalGroupingSpecification -> ScriptDom.GrandTotalGroupingSpecification() :> ScriptDom.GroupingSpecification (* 396 *)
    | GroupingSetsGroupingSpecification(sets=aSets) ->
      let ret = ScriptDom.GroupingSetsGroupingSpecification()
      for e in aSets do ret.Sets.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 404 *)
    | RollupGroupingSpecification(arguments=aArguments) ->
      let ret = ScriptDom.RollupGroupingSpecification()
      for e in aArguments do ret.Arguments.Add (e.ToCs())
      ret :> ScriptDom.GroupingSpecification (* 404 *)
  static member FromCs(src:ScriptDom.GroupingSpecification) : GroupingSpecification =
    match src with
    | :? ScriptDom.CompositeGroupingSpecification as src ->
      GroupingSpecification.CompositeGroupingSpecification((src.Items |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))
    | :? ScriptDom.CubeGroupingSpecification as src ->
      GroupingSpecification.CubeGroupingSpecification((src.Arguments |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))
    | :? ScriptDom.ExpressionGroupingSpecification as src ->
      GroupingSpecification.ExpressionGroupingSpecification((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.GrandTotalGroupingSpecification as src ->
      GroupingSpecification.GrandTotalGroupingSpecification
    | :? ScriptDom.GroupingSetsGroupingSpecification as src ->
      GroupingSpecification.GroupingSetsGroupingSpecification((src.Sets |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))
    | :? ScriptDom.RollupGroupingSpecification as src ->
      GroupingSpecification.RollupGroupingSpecification((src.Arguments |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))
and Identifier = (* IsAbstract = false , children = 2*)
  | Base of quoteType:ScriptDom.QuoteType * value:String
  | IdentifierSnippet of quoteType:ScriptDom.QuoteType * script:String * value:String
  | SqlCommandIdentifier of quoteType:ScriptDom.QuoteType * value:String
  member this.ToCs() : ScriptDom.Identifier =
    match this with
    | IdentifierSnippet(quoteType=aQuoteType; script=aScript; value=aValue) ->
      let ret = ScriptDom.IdentifierSnippet()
      ret.QuoteType <- aQuoteType
      ret.Script <- aScript
      ret.Value <- aValue
      ret :> ScriptDom.Identifier (* 404 *)
    | SqlCommandIdentifier(quoteType=aQuoteType; value=aValue) ->
      let ret = ScriptDom.SqlCommandIdentifier()
      ret.QuoteType <- aQuoteType
      ret.Value <- aValue
      ret :> ScriptDom.Identifier (* 404 *)
    | Base(quoteType=aQuoteType; value=aValue) ->

      let ret = ScriptDom.Identifier()
      ret.QuoteType <- aQuoteType
      ret.Value <- aValue
      ret
//// shared props Identifier 
  member this.QuoteType = 
    match this with
    | Base (quoteType=quoteType) -> quoteType
    | IdentifierSnippet(quoteType=quoteType) -> quoteType
    | SqlCommandIdentifier(quoteType=quoteType) -> quoteType
  member this.Value = 
    match this with
    | Base (value=value) -> value
    | IdentifierSnippet(value=value) -> value
    | SqlCommandIdentifier(value=value) -> value
  static member FromCs(src:ScriptDom.Identifier) : Identifier =
    match src with
    | :? ScriptDom.IdentifierSnippet as src ->
      Identifier.IdentifierSnippet((src.QuoteType), (src.Script), (src.Value))
    | :? ScriptDom.SqlCommandIdentifier as src ->
      Identifier.SqlCommandIdentifier((src.QuoteType), (src.Value))
    | _ -> (* :? ScriptDom.Identifier as src *)
      Identifier.Base(((src.QuoteType), (src.Value)))
and IndexOption = (* IsAbstract = true , children = 9*)
  | CompressionDelayIndexOption of expression:ScalarExpression option * optionKind:ScriptDom.IndexOptionKind * timeUnit:ScriptDom.CompressionDelayTimeUnit
  | DataCompressionOption of compressionLevel:ScriptDom.DataCompressionLevel * optionKind:ScriptDom.IndexOptionKind * partitionRanges:(CompressionPartitionRange) list
  | FileStreamOnDropIndexOption of fileStreamOn:IdentifierOrValueExpression option * optionKind:ScriptDom.IndexOptionKind
  | IndexExpressionOption of expression:ScalarExpression option * optionKind:ScriptDom.IndexOptionKind
  | IndexStateOption of indexStateOption:IndexStateOption
  | MaxDurationOption of maxDuration:Literal option * optionKind:ScriptDom.IndexOptionKind * unit:(ScriptDom.TimeUnit) option
  | MoveToDropIndexOption of moveTo:FileGroupOrPartitionScheme option * optionKind:ScriptDom.IndexOptionKind
  | OrderIndexOption of columns:(ColumnReferenceExpression) list * optionKind:ScriptDom.IndexOptionKind
  | WaitAtLowPriorityOption of optionKind:ScriptDom.IndexOptionKind * options:(LowPriorityLockWaitOption) list
  member this.ToCs() : ScriptDom.IndexOption =
    match this with
    | CompressionDelayIndexOption(expression=aExpression; optionKind=aOptionKind; timeUnit=aTimeUnit) ->
      let ret = ScriptDom.CompressionDelayIndexOption()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.TimeUnit <- aTimeUnit
      ret :> ScriptDom.IndexOption (* 404 *)
    | DataCompressionOption(compressionLevel=aCompressionLevel; optionKind=aOptionKind; partitionRanges=aPartitionRanges) ->
      let ret = ScriptDom.DataCompressionOption()
      ret.CompressionLevel <- aCompressionLevel
      ret.OptionKind <- aOptionKind
      for e in aPartitionRanges do ret.PartitionRanges.Add (e.ToCs())
      ret :> ScriptDom.IndexOption (* 404 *)
    | FileStreamOnDropIndexOption(fileStreamOn=aFileStreamOn; optionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamOnDropIndexOption()
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 404 *)
    | IndexExpressionOption(expression=aExpression; optionKind=aOptionKind) ->
      let ret = ScriptDom.IndexExpressionOption()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 404 *)
    | IndexStateOption(x) -> x.ToCs() :> ScriptDom.IndexOption (* 414 *)
    | MaxDurationOption(maxDuration=aMaxDuration; optionKind=aOptionKind; unit=aUnit) ->
      let ret = ScriptDom.MaxDurationOption()
      ret.MaxDuration <- aMaxDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Unit <- Option.toNullable aUnit
      ret :> ScriptDom.IndexOption (* 404 *)
    | MoveToDropIndexOption(moveTo=aMoveTo; optionKind=aOptionKind) ->
      let ret = ScriptDom.MoveToDropIndexOption()
      ret.MoveTo <- aMoveTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 404 *)
    | OrderIndexOption(columns=aColumns; optionKind=aOptionKind) ->
      let ret = ScriptDom.OrderIndexOption()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.IndexOption (* 404 *)
    | WaitAtLowPriorityOption(optionKind=aOptionKind; options=aOptions) ->
      let ret = ScriptDom.WaitAtLowPriorityOption()
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.IndexOption (* 404 *)
//// shared props IndexOption 
  member this.OptionKind = 
    match this with
    | CompressionDelayIndexOption(optionKind=optionKind) -> optionKind
    | DataCompressionOption(optionKind=optionKind) -> optionKind
    | FileStreamOnDropIndexOption(optionKind=optionKind) -> optionKind
    | IndexExpressionOption(optionKind=optionKind) -> optionKind
    | IndexStateOption _ as x -> x.OptionKind
    | MaxDurationOption(optionKind=optionKind) -> optionKind
    | MoveToDropIndexOption(optionKind=optionKind) -> optionKind
    | OrderIndexOption(optionKind=optionKind) -> optionKind
    | WaitAtLowPriorityOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.IndexOption) : IndexOption =
    match src with
    | :? ScriptDom.CompressionDelayIndexOption as src ->
      IndexOption.CompressionDelayIndexOption((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OptionKind), (src.TimeUnit))
    | :? ScriptDom.DataCompressionOption as src ->
      IndexOption.DataCompressionOption((src.CompressionLevel), (src.OptionKind), (src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.FileStreamOnDropIndexOption as src ->
      IndexOption.FileStreamOnDropIndexOption((src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.OptionKind))
    | :? ScriptDom.IndexExpressionOption as src ->
      IndexOption.IndexExpressionOption((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OptionKind))
    | :? ScriptDom.IndexStateOption as src ->
      match src with
      | :? ScriptDom.IgnoreDupKeyIndexOption as src->
        IndexOption.IndexStateOption((IndexStateOption.IgnoreDupKeyIndexOption((src.OptionKind), (src.OptionState), (Option.ofNullable (src.SuppressMessagesOption)))))
      | :? ScriptDom.OnlineIndexOption as src->
        IndexOption.IndexStateOption((IndexStateOption.OnlineIndexOption((src.LowPriorityLockWaitOption |> Option.ofObj |> Option.map (OnlineIndexLowPriorityLockWaitOption.FromCs)), (src.OptionKind), (src.OptionState))))
      | _ -> (* :? ScriptDom.IndexStateOption as src *)
        IndexOption.IndexStateOption((IndexStateOption.Base((src.OptionKind), (src.OptionState))))
    | :? ScriptDom.MaxDurationOption as src ->
      IndexOption.MaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (Option.ofNullable (src.Unit)))
    | :? ScriptDom.MoveToDropIndexOption as src ->
      IndexOption.MoveToDropIndexOption((src.MoveTo |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.OptionKind))
    | :? ScriptDom.OrderIndexOption as src ->
      IndexOption.OrderIndexOption((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.OptionKind))
    | :? ScriptDom.WaitAtLowPriorityOption as src ->
      IndexOption.WaitAtLowPriorityOption((src.OptionKind), (src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))
and InsertSource = (* IsAbstract = true , children = 3*)
  | ExecuteInsertSource of execute:ExecuteSpecification option
  | SelectInsertSource of select:QueryExpression option
  | ValuesInsertSource of isDefaultValues:bool * rowValues:(RowValue) list
  member this.ToCs() : ScriptDom.InsertSource =
    match this with
    | ExecuteInsertSource(execute=aExecute) ->
      let ret = ScriptDom.ExecuteInsertSource()
      ret.Execute <- aExecute |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.InsertSource (* 404 *)
    | SelectInsertSource(select=aSelect) ->
      let ret = ScriptDom.SelectInsertSource()
      ret.Select <- aSelect |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.InsertSource (* 404 *)
    | ValuesInsertSource(isDefaultValues=aIsDefaultValues; rowValues=aRowValues) ->
      let ret = ScriptDom.ValuesInsertSource()
      ret.IsDefaultValues <- aIsDefaultValues
      for e in aRowValues do ret.RowValues.Add (e.ToCs())
      ret :> ScriptDom.InsertSource (* 404 *)
  static member FromCs(src:ScriptDom.InsertSource) : InsertSource =
    match src with
    | :? ScriptDom.ExecuteInsertSource as src ->
      InsertSource.ExecuteInsertSource((src.Execute |> Option.ofObj |> Option.map (ExecuteSpecification.FromCs)))
    | :? ScriptDom.SelectInsertSource as src ->
      InsertSource.SelectInsertSource((src.Select |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
    | :? ScriptDom.ValuesInsertSource as src ->
      InsertSource.ValuesInsertSource((src.IsDefaultValues), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))) |> List.ofSeq))
and KeyOption = (* IsAbstract = true , children = 5*)
  | AlgorithmKeyOption of algorithm:ScriptDom.EncryptionAlgorithm * optionKind:ScriptDom.KeyOptionKind
  | CreationDispositionKeyOption of isCreateNew:bool * optionKind:ScriptDom.KeyOptionKind
  | IdentityValueKeyOption of identityPhrase:Literal option * optionKind:ScriptDom.KeyOptionKind
  | KeySourceKeyOption of optionKind:ScriptDom.KeyOptionKind * passPhrase:Literal option
  | ProviderKeyNameKeyOption of keyName:Literal option * optionKind:ScriptDom.KeyOptionKind
  member this.ToCs() : ScriptDom.KeyOption =
    match this with
    | AlgorithmKeyOption(algorithm=aAlgorithm; optionKind=aOptionKind) ->
      let ret = ScriptDom.AlgorithmKeyOption()
      ret.Algorithm <- aAlgorithm
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 404 *)
    | CreationDispositionKeyOption(isCreateNew=aIsCreateNew; optionKind=aOptionKind) ->
      let ret = ScriptDom.CreationDispositionKeyOption()
      ret.IsCreateNew <- aIsCreateNew
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 404 *)
    | IdentityValueKeyOption(identityPhrase=aIdentityPhrase; optionKind=aOptionKind) ->
      let ret = ScriptDom.IdentityValueKeyOption()
      ret.IdentityPhrase <- aIdentityPhrase |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 404 *)
    | KeySourceKeyOption(optionKind=aOptionKind; passPhrase=aPassPhrase) ->
      let ret = ScriptDom.KeySourceKeyOption()
      ret.OptionKind <- aOptionKind
      ret.PassPhrase <- aPassPhrase |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.KeyOption (* 404 *)
    | ProviderKeyNameKeyOption(keyName=aKeyName; optionKind=aOptionKind) ->
      let ret = ScriptDom.ProviderKeyNameKeyOption()
      ret.KeyName <- aKeyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.KeyOption (* 404 *)
//// shared props KeyOption 
  member this.OptionKind = 
    match this with
    | AlgorithmKeyOption(optionKind=optionKind) -> optionKind
    | CreationDispositionKeyOption(optionKind=optionKind) -> optionKind
    | IdentityValueKeyOption(optionKind=optionKind) -> optionKind
    | KeySourceKeyOption(optionKind=optionKind) -> optionKind
    | ProviderKeyNameKeyOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.KeyOption) : KeyOption =
    match src with
    | :? ScriptDom.AlgorithmKeyOption as src ->
      KeyOption.AlgorithmKeyOption((src.Algorithm), (src.OptionKind))
    | :? ScriptDom.CreationDispositionKeyOption as src ->
      KeyOption.CreationDispositionKeyOption((src.IsCreateNew), (src.OptionKind))
    | :? ScriptDom.IdentityValueKeyOption as src ->
      KeyOption.IdentityValueKeyOption((src.IdentityPhrase |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.KeySourceKeyOption as src ->
      KeyOption.KeySourceKeyOption((src.OptionKind), (src.PassPhrase |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.ProviderKeyNameKeyOption as src ->
      KeyOption.ProviderKeyNameKeyOption((src.KeyName |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
and LiteralRange = (* IsAbstract = false , children = 1*)
  | Base of from:Literal option * to_:Literal option
  | ProcessAffinityRange of from:Literal option * to_:Literal option
  member this.ToCs() : ScriptDom.LiteralRange =
    match this with
    | ProcessAffinityRange(from=aFrom; to_=aTo) ->
      let ret = ScriptDom.ProcessAffinityRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.LiteralRange (* 404 *)
    | Base(from=aFrom; to_=aTo) ->

      let ret = ScriptDom.LiteralRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props LiteralRange 
  member this.From = 
    match this with
    | Base (from=from) -> from
    | ProcessAffinityRange(from=from) -> from
  member this.To = 
    match this with
    | Base (to_=to_) -> to_
    | ProcessAffinityRange(to_=to_) -> to_
  static member FromCs(src:ScriptDom.LiteralRange) : LiteralRange =
    match src with
    | :? ScriptDom.ProcessAffinityRange as src ->
      LiteralRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs)))
    | _ -> (* :? ScriptDom.LiteralRange as src *)
      LiteralRange.Base(((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs))))
and LowPriorityLockWaitOption = (* IsAbstract = true , children = 2*)
  | LowPriorityLockWaitAbortAfterWaitOption of abortAfterWait:ScriptDom.AbortAfterWaitType * optionKind:ScriptDom.LowPriorityLockWaitOptionKind
  | LowPriorityLockWaitMaxDurationOption of maxDuration:Literal option * optionKind:ScriptDom.LowPriorityLockWaitOptionKind * unit:(ScriptDom.TimeUnit) option
  member this.ToCs() : ScriptDom.LowPriorityLockWaitOption =
    match this with
    | LowPriorityLockWaitAbortAfterWaitOption(abortAfterWait=aAbortAfterWait; optionKind=aOptionKind) ->
      let ret = ScriptDom.LowPriorityLockWaitAbortAfterWaitOption()
      ret.AbortAfterWait <- aAbortAfterWait
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.LowPriorityLockWaitOption (* 404 *)
    | LowPriorityLockWaitMaxDurationOption(maxDuration=aMaxDuration; optionKind=aOptionKind; unit=aUnit) ->
      let ret = ScriptDom.LowPriorityLockWaitMaxDurationOption()
      ret.MaxDuration <- aMaxDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Unit <- Option.toNullable aUnit
      ret :> ScriptDom.LowPriorityLockWaitOption (* 404 *)
//// shared props LowPriorityLockWaitOption 
  member this.OptionKind = 
    match this with
    | LowPriorityLockWaitAbortAfterWaitOption(optionKind=optionKind) -> optionKind
    | LowPriorityLockWaitMaxDurationOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.LowPriorityLockWaitOption) : LowPriorityLockWaitOption =
    match src with
    | :? ScriptDom.LowPriorityLockWaitAbortAfterWaitOption as src ->
      LowPriorityLockWaitOption.LowPriorityLockWaitAbortAfterWaitOption((src.AbortAfterWait), (src.OptionKind))
    | :? ScriptDom.LowPriorityLockWaitMaxDurationOption as src ->
      LowPriorityLockWaitOption.LowPriorityLockWaitMaxDurationOption((src.MaxDuration |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (Option.ofNullable (src.Unit)))
and MergeAction = (* IsAbstract = true , children = 3*)
  | DeleteMergeAction 
  | InsertMergeAction of columns:(ColumnReferenceExpression) list * source:ValuesInsertSource option
  | UpdateMergeAction of setClauses:(SetClause) list
  member this.ToCs() : ScriptDom.MergeAction =
    match this with
    | DeleteMergeAction -> ScriptDom.DeleteMergeAction() :> ScriptDom.MergeAction (* 396 *)
    | InsertMergeAction(columns=aColumns; source=aSource) ->
      let ret = ScriptDom.InsertMergeAction()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.Source <- aSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MergeAction (* 404 *)
    | UpdateMergeAction(setClauses=aSetClauses) ->
      let ret = ScriptDom.UpdateMergeAction()
      for e in aSetClauses do ret.SetClauses.Add (e.ToCs())
      ret :> ScriptDom.MergeAction (* 404 *)
  static member FromCs(src:ScriptDom.MergeAction) : MergeAction =
    match src with
    | :? ScriptDom.DeleteMergeAction as src ->
      MergeAction.DeleteMergeAction
    | :? ScriptDom.InsertMergeAction as src ->
      MergeAction.InsertMergeAction((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.Source |> Option.ofObj |> Option.map (ValuesInsertSource.FromCs)))
    | :? ScriptDom.UpdateMergeAction as src ->
      MergeAction.UpdateMergeAction((src.SetClauses |> Seq.map (SetClause.FromCs) |> List.ofSeq))
and MultiPartIdentifier = (* IsAbstract = false , children = 1*)
  | Base of count:Int32 * identifiers:(Identifier) list
  | SchemaObjectName of schemaObjectName:SchemaObjectName
  member this.ToCs() : ScriptDom.MultiPartIdentifier =
    match this with
    | SchemaObjectName(x) -> x.ToCs() :> ScriptDom.MultiPartIdentifier (* 414 *)
    | Base(count=aCount; identifiers=aIdentifiers) ->

      let ret = ScriptDom.MultiPartIdentifier()
       // Skipping prop Count - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
      ret
//// shared props MultiPartIdentifier 
  member this.Count = 
    match this with
    | Base (count=count) -> count
    | SchemaObjectName _ as x -> x.Count
  member this.Identifiers = 
    match this with
    | Base (identifiers=identifiers) -> identifiers
    | SchemaObjectName _ as x -> x.Identifiers
  static member FromCs(src:ScriptDom.MultiPartIdentifier) : MultiPartIdentifier =
    match src with
    | :? ScriptDom.SchemaObjectName as src ->
      match src with
      | :? ScriptDom.ChildObjectName as src->
        MultiPartIdentifier.SchemaObjectName((SchemaObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ChildIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.SchemaObjectNameSnippet as src->
        MultiPartIdentifier.SchemaObjectName((SchemaObjectName.SchemaObjectNameSnippet((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Script), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | _ -> (* :? ScriptDom.SchemaObjectName as src *)
        MultiPartIdentifier.SchemaObjectName((SchemaObjectName.Base((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | _ -> (* :? ScriptDom.MultiPartIdentifier as src *)
      MultiPartIdentifier.Base(((src.Count), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq)))
and OptimizerHint = (* IsAbstract = false , children = 4*)
  | Base of hintKind:ScriptDom.OptimizerHintKind
  | LiteralOptimizerHint of hintKind:ScriptDom.OptimizerHintKind * value:Literal option
  | OptimizeForOptimizerHint of hintKind:ScriptDom.OptimizerHintKind * isForUnknown:bool * pairs:(VariableValuePair) list
  | TableHintsOptimizerHint of hintKind:ScriptDom.OptimizerHintKind * objectName:SchemaObjectName option * tableHints:(TableHint) list
  | UseHintList of hintKind:ScriptDom.OptimizerHintKind * hints:(StringLiteral) list
  member this.ToCs() : ScriptDom.OptimizerHint =
    match this with
    | LiteralOptimizerHint(hintKind=aHintKind; value=aValue) ->
      let ret = ScriptDom.LiteralOptimizerHint()
      ret.HintKind <- aHintKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.OptimizerHint (* 404 *)
    | OptimizeForOptimizerHint(hintKind=aHintKind; isForUnknown=aIsForUnknown; pairs=aPairs) ->
      let ret = ScriptDom.OptimizeForOptimizerHint()
      ret.HintKind <- aHintKind
      ret.IsForUnknown <- aIsForUnknown
      for e in aPairs do ret.Pairs.Add (e.ToCs())
      ret :> ScriptDom.OptimizerHint (* 404 *)
    | TableHintsOptimizerHint(hintKind=aHintKind; objectName=aObjectName; tableHints=aTableHints) ->
      let ret = ScriptDom.TableHintsOptimizerHint()
      ret.HintKind <- aHintKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableHints do ret.TableHints.Add (e.ToCs())
      ret :> ScriptDom.OptimizerHint (* 404 *)
    | UseHintList(hintKind=aHintKind; hints=aHints) ->
      let ret = ScriptDom.UseHintList()
      ret.HintKind <- aHintKind
      for e in aHints do ret.Hints.Add (e.ToCs())
      ret :> ScriptDom.OptimizerHint (* 404 *)
    | Base(hintKind=aHintKind) ->

      let ret = ScriptDom.OptimizerHint()
      ret.HintKind <- aHintKind
      ret
//// shared props OptimizerHint 
  member this.HintKind = 
    match this with
    | Base (hintKind=hintKind) -> hintKind
    | LiteralOptimizerHint(hintKind=hintKind) -> hintKind
    | OptimizeForOptimizerHint(hintKind=hintKind) -> hintKind
    | TableHintsOptimizerHint(hintKind=hintKind) -> hintKind
    | UseHintList(hintKind=hintKind) -> hintKind
  static member FromCs(src:ScriptDom.OptimizerHint) : OptimizerHint =
    match src with
    | :? ScriptDom.LiteralOptimizerHint as src ->
      OptimizerHint.LiteralOptimizerHint((src.HintKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OptimizeForOptimizerHint as src ->
      OptimizerHint.OptimizeForOptimizerHint((src.HintKind), (src.IsForUnknown), (src.Pairs |> Seq.map (fun src -> VariableValuePair.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.TableHintsOptimizerHint as src ->
      OptimizerHint.TableHintsOptimizerHint((src.HintKind), (src.ObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TableHints |> Seq.map (TableHint.FromCs) |> List.ofSeq))
    | :? ScriptDom.UseHintList as src ->
      OptimizerHint.UseHintList((src.HintKind), (src.Hints |> Seq.map (fun src -> StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (src.Value))) |> List.ofSeq))
    | _ -> (* :? ScriptDom.OptimizerHint as src *)
      OptimizerHint.Base(((src.HintKind)))
and OptionValue = (* IsAbstract = true , children = 2*)
  | LiteralOptionValue of value:Literal option
  | OnOffOptionValue of optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.OptionValue =
    match this with
    | LiteralOptionValue(value=aValue) ->
      let ret = ScriptDom.LiteralOptionValue()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.OptionValue (* 404 *)
    | OnOffOptionValue(optionState=aOptionState) ->
      let ret = ScriptDom.OnOffOptionValue()
      ret.OptionState <- aOptionState
      ret :> ScriptDom.OptionValue (* 404 *)
  static member FromCs(src:ScriptDom.OptionValue) : OptionValue =
    match src with
    | :? ScriptDom.LiteralOptionValue as src ->
      OptionValue.LiteralOptionValue((src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OnOffOptionValue as src ->
      OptionValue.OnOffOptionValue((src.OptionState))
and PartitionSpecifications = (* IsAbstract = true , children = 1*)
  | TablePartitionOptionSpecifications of boundaryValues:(ScalarExpression) list * range:ScriptDom.PartitionTableOptionRange
  member this.ToCs() : ScriptDom.PartitionSpecifications =
    match this with
    | TablePartitionOptionSpecifications(boundaryValues=aBoundaryValues; range=aRange) ->
      let ret = ScriptDom.TablePartitionOptionSpecifications()
      for e in aBoundaryValues do ret.BoundaryValues.Add (e.ToCs())
      ret.Range <- aRange
      ret :> ScriptDom.PartitionSpecifications (* 404 *)
  static member FromCs(src:ScriptDom.PartitionSpecifications) : PartitionSpecifications =
    match src with
    | :? ScriptDom.TablePartitionOptionSpecifications as src ->
      PartitionSpecifications.TablePartitionOptionSpecifications((src.BoundaryValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Range))
and PayloadOption = (* IsAbstract = true , children = 11*)
  | AuthenticationPayloadOption of certificate:Identifier option * kind:ScriptDom.PayloadOptionKinds * protocol:ScriptDom.AuthenticationProtocol * tryCertificateFirst:bool
  | CharacterSetPayloadOption of isSql:bool * kind:ScriptDom.PayloadOptionKinds
  | EnabledDisabledPayloadOption of isEnabled:bool * kind:ScriptDom.PayloadOptionKinds
  | EncryptionPayloadOption of algorithmPartOne:ScriptDom.EncryptionAlgorithmPreference * algorithmPartTwo:ScriptDom.EncryptionAlgorithmPreference * encryptionSupport:ScriptDom.EndpointEncryptionSupport * kind:ScriptDom.PayloadOptionKinds
  | LiteralPayloadOption of kind:ScriptDom.PayloadOptionKinds * value:Literal option
  | LoginTypePayloadOption of isWindows:bool * kind:ScriptDom.PayloadOptionKinds
  | RolePayloadOption of kind:ScriptDom.PayloadOptionKinds * role:ScriptDom.DatabaseMirroringEndpointRole
  | SchemaPayloadOption of isStandard:bool * kind:ScriptDom.PayloadOptionKinds
  | SessionTimeoutPayloadOption of isNever:bool * kind:ScriptDom.PayloadOptionKinds * timeout:Literal option
  | SoapMethod of action:ScriptDom.SoapMethodAction * alias:Literal option * format:ScriptDom.SoapMethodFormat * kind:ScriptDom.PayloadOptionKinds * name:Literal option * namespace_:Literal option * schema:ScriptDom.SoapMethodSchemas
  | WsdlPayloadOption of isNone:bool * kind:ScriptDom.PayloadOptionKinds * value:Literal option
  member this.ToCs() : ScriptDom.PayloadOption =
    match this with
    | AuthenticationPayloadOption(certificate=aCertificate; kind=aKind; protocol=aProtocol; tryCertificateFirst=aTryCertificateFirst) ->
      let ret = ScriptDom.AuthenticationPayloadOption()
      ret.Certificate <- aCertificate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Protocol <- aProtocol
      ret.TryCertificateFirst <- aTryCertificateFirst
      ret :> ScriptDom.PayloadOption (* 404 *)
    | CharacterSetPayloadOption(isSql=aIsSql; kind=aKind) ->
      let ret = ScriptDom.CharacterSetPayloadOption()
      ret.IsSql <- aIsSql
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 404 *)
    | EnabledDisabledPayloadOption(isEnabled=aIsEnabled; kind=aKind) ->
      let ret = ScriptDom.EnabledDisabledPayloadOption()
      ret.IsEnabled <- aIsEnabled
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 404 *)
    | EncryptionPayloadOption(algorithmPartOne=aAlgorithmPartOne; algorithmPartTwo=aAlgorithmPartTwo; encryptionSupport=aEncryptionSupport; kind=aKind) ->
      let ret = ScriptDom.EncryptionPayloadOption()
      ret.AlgorithmPartOne <- aAlgorithmPartOne
      ret.AlgorithmPartTwo <- aAlgorithmPartTwo
      ret.EncryptionSupport <- aEncryptionSupport
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 404 *)
    | LiteralPayloadOption(kind=aKind; value=aValue) ->
      let ret = ScriptDom.LiteralPayloadOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PayloadOption (* 404 *)
    | LoginTypePayloadOption(isWindows=aIsWindows; kind=aKind) ->
      let ret = ScriptDom.LoginTypePayloadOption()
      ret.IsWindows <- aIsWindows
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 404 *)
    | RolePayloadOption(kind=aKind; role=aRole) ->
      let ret = ScriptDom.RolePayloadOption()
      ret.Kind <- aKind
      ret.Role <- aRole
      ret :> ScriptDom.PayloadOption (* 404 *)
    | SchemaPayloadOption(isStandard=aIsStandard; kind=aKind) ->
      let ret = ScriptDom.SchemaPayloadOption()
      ret.IsStandard <- aIsStandard
      ret.Kind <- aKind
      ret :> ScriptDom.PayloadOption (* 404 *)
    | SessionTimeoutPayloadOption(isNever=aIsNever; kind=aKind; timeout=aTimeout) ->
      let ret = ScriptDom.SessionTimeoutPayloadOption()
      ret.IsNever <- aIsNever
      ret.Kind <- aKind
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PayloadOption (* 404 *)
    | SoapMethod(action=aAction; alias=aAlias; format=aFormat; kind=aKind; name=aName; namespace_=aNamespace; schema=aSchema) ->
      let ret = ScriptDom.SoapMethod()
      ret.Action <- aAction
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Format <- aFormat
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Namespace <- aNamespace |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Schema <- aSchema
      ret :> ScriptDom.PayloadOption (* 404 *)
    | WsdlPayloadOption(isNone=aIsNone; kind=aKind; value=aValue) ->
      let ret = ScriptDom.WsdlPayloadOption()
      ret.IsNone <- aIsNone
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PayloadOption (* 404 *)
//// shared props PayloadOption 
  member this.Kind = 
    match this with
    | AuthenticationPayloadOption(kind=kind) -> kind
    | CharacterSetPayloadOption(kind=kind) -> kind
    | EnabledDisabledPayloadOption(kind=kind) -> kind
    | EncryptionPayloadOption(kind=kind) -> kind
    | LiteralPayloadOption(kind=kind) -> kind
    | LoginTypePayloadOption(kind=kind) -> kind
    | RolePayloadOption(kind=kind) -> kind
    | SchemaPayloadOption(kind=kind) -> kind
    | SessionTimeoutPayloadOption(kind=kind) -> kind
    | SoapMethod(kind=kind) -> kind
    | WsdlPayloadOption(kind=kind) -> kind
  static member FromCs(src:ScriptDom.PayloadOption) : PayloadOption =
    match src with
    | :? ScriptDom.AuthenticationPayloadOption as src ->
      PayloadOption.AuthenticationPayloadOption((src.Certificate |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Kind), (src.Protocol), (src.TryCertificateFirst))
    | :? ScriptDom.CharacterSetPayloadOption as src ->
      PayloadOption.CharacterSetPayloadOption((src.IsSql), (src.Kind))
    | :? ScriptDom.EnabledDisabledPayloadOption as src ->
      PayloadOption.EnabledDisabledPayloadOption((src.IsEnabled), (src.Kind))
    | :? ScriptDom.EncryptionPayloadOption as src ->
      PayloadOption.EncryptionPayloadOption((src.AlgorithmPartOne), (src.AlgorithmPartTwo), (src.EncryptionSupport), (src.Kind))
    | :? ScriptDom.LiteralPayloadOption as src ->
      PayloadOption.LiteralPayloadOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.LoginTypePayloadOption as src ->
      PayloadOption.LoginTypePayloadOption((src.IsWindows), (src.Kind))
    | :? ScriptDom.RolePayloadOption as src ->
      PayloadOption.RolePayloadOption((src.Kind), (src.Role))
    | :? ScriptDom.SchemaPayloadOption as src ->
      PayloadOption.SchemaPayloadOption((src.IsStandard), (src.Kind))
    | :? ScriptDom.SessionTimeoutPayloadOption as src ->
      PayloadOption.SessionTimeoutPayloadOption((src.IsNever), (src.Kind), (src.Timeout |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.SoapMethod as src ->
      PayloadOption.SoapMethod((src.Action), (src.Alias |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Format), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Namespace |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Schema))
    | :? ScriptDom.WsdlPayloadOption as src ->
      PayloadOption.WsdlPayloadOption((src.IsNone), (src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and PrincipalOption = (* IsAbstract = false , children = 4*)
  | Base of optionKind:ScriptDom.PrincipalOptionKind
  | IdentifierPrincipalOption of identifier:Identifier option * optionKind:ScriptDom.PrincipalOptionKind
  | LiteralPrincipalOption of optionKind:ScriptDom.PrincipalOptionKind * value:Literal option
  | OnOffPrincipalOption of optionKind:ScriptDom.PrincipalOptionKind * optionState:ScriptDom.OptionState
  | PasswordAlterPrincipalOption of hashed:bool * mustChange:bool * oldPassword:Literal option * optionKind:ScriptDom.PrincipalOptionKind * password:Literal option * unlock:bool
  member this.ToCs() : ScriptDom.PrincipalOption =
    match this with
    | IdentifierPrincipalOption(identifier=aIdentifier; optionKind=aOptionKind) ->
      let ret = ScriptDom.IdentifierPrincipalOption()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.PrincipalOption (* 404 *)
    | LiteralPrincipalOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LiteralPrincipalOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrincipalOption (* 404 *)
    | OnOffPrincipalOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffPrincipalOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.PrincipalOption (* 404 *)
    | PasswordAlterPrincipalOption(hashed=aHashed; mustChange=aMustChange; oldPassword=aOldPassword; optionKind=aOptionKind; password=aPassword; unlock=aUnlock) ->
      let ret = ScriptDom.PasswordAlterPrincipalOption()
      ret.Hashed <- aHashed
      ret.MustChange <- aMustChange
      ret.OldPassword <- aOldPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unlock <- aUnlock
      ret :> ScriptDom.PrincipalOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.PrincipalOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props PrincipalOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | IdentifierPrincipalOption(optionKind=optionKind) -> optionKind
    | LiteralPrincipalOption(optionKind=optionKind) -> optionKind
    | OnOffPrincipalOption(optionKind=optionKind) -> optionKind
    | PasswordAlterPrincipalOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.PrincipalOption) : PrincipalOption =
    match src with
    | :? ScriptDom.IdentifierPrincipalOption as src ->
      PrincipalOption.IdentifierPrincipalOption((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptionKind))
    | :? ScriptDom.LiteralPrincipalOption as src ->
      PrincipalOption.LiteralPrincipalOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OnOffPrincipalOption as src ->
      PrincipalOption.OnOffPrincipalOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.PasswordAlterPrincipalOption as src ->
      PrincipalOption.PasswordAlterPrincipalOption((src.Hashed), (src.MustChange), (src.OldPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Unlock))
    | _ -> (* :? ScriptDom.PrincipalOption as src *)
      PrincipalOption.Base(((src.OptionKind)))
and ProcedureOption = (* IsAbstract = false , children = 1*)
  | Base of optionKind:ScriptDom.ProcedureOptionKind
  | ExecuteAsProcedureOption of executeAs:ExecuteAsClause option * optionKind:ScriptDom.ProcedureOptionKind
  member this.ToCs() : ScriptDom.ProcedureOption =
    match this with
    | ExecuteAsProcedureOption(executeAs=aExecuteAs; optionKind=aOptionKind) ->
      let ret = ScriptDom.ExecuteAsProcedureOption()
      ret.ExecuteAs <- aExecuteAs |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.ProcedureOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.ProcedureOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props ProcedureOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | ExecuteAsProcedureOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.ProcedureOption) : ProcedureOption =
    match src with
    | :? ScriptDom.ExecuteAsProcedureOption as src ->
      ProcedureOption.ExecuteAsProcedureOption((src.ExecuteAs |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)), (src.OptionKind))
    | _ -> (* :? ScriptDom.ProcedureOption as src *)
      ProcedureOption.Base(((src.OptionKind)))
and QueryExpression = (* IsAbstract = true , children = 3*)
  | BinaryQueryExpression of all:bool * binaryQueryExpressionType:ScriptDom.BinaryQueryExpressionType * firstQueryExpression:QueryExpression option * forClause:ForClause option * offsetClause:OffsetClause option * orderByClause:OrderByClause option * secondQueryExpression:QueryExpression option
  | QueryParenthesisExpression of forClause:ForClause option * offsetClause:OffsetClause option * orderByClause:OrderByClause option * queryExpression:QueryExpression option
  | QuerySpecification of forClause:ForClause option * fromClause:FromClause option * groupByClause:GroupByClause option * havingClause:HavingClause option * offsetClause:OffsetClause option * orderByClause:OrderByClause option * selectElements:(SelectElement) list * topRowFilter:TopRowFilter option * uniqueRowFilter:ScriptDom.UniqueRowFilter * whereClause:WhereClause option
  member this.ToCs() : ScriptDom.QueryExpression =
    match this with
    | BinaryQueryExpression(all=aAll; binaryQueryExpressionType=aBinaryQueryExpressionType; firstQueryExpression=aFirstQueryExpression; forClause=aForClause; offsetClause=aOffsetClause; orderByClause=aOrderByClause; secondQueryExpression=aSecondQueryExpression) ->
      let ret = ScriptDom.BinaryQueryExpression()
      ret.All <- aAll
      ret.BinaryQueryExpressionType <- aBinaryQueryExpressionType
      ret.FirstQueryExpression <- aFirstQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ForClause <- aForClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetClause <- aOffsetClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondQueryExpression <- aSecondQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryExpression (* 404 *)
    | QueryParenthesisExpression(forClause=aForClause; offsetClause=aOffsetClause; orderByClause=aOrderByClause; queryExpression=aQueryExpression) ->
      let ret = ScriptDom.QueryParenthesisExpression()
      ret.ForClause <- aForClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetClause <- aOffsetClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryExpression (* 404 *)
    | QuerySpecification(forClause=aForClause; fromClause=aFromClause; groupByClause=aGroupByClause; havingClause=aHavingClause; offsetClause=aOffsetClause; orderByClause=aOrderByClause; selectElements=aSelectElements; topRowFilter=aTopRowFilter; uniqueRowFilter=aUniqueRowFilter; whereClause=aWhereClause) ->
      let ret = ScriptDom.QuerySpecification()
      ret.ForClause <- aForClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GroupByClause <- aGroupByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.HavingClause <- aHavingClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetClause <- aOffsetClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSelectElements do ret.SelectElements.Add (e.ToCs())
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UniqueRowFilter <- aUniqueRowFilter
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryExpression (* 404 *)
//// shared props QueryExpression 
  member this.ForClause = 
    match this with
    | BinaryQueryExpression(forClause=forClause) -> forClause
    | QueryParenthesisExpression(forClause=forClause) -> forClause
    | QuerySpecification(forClause=forClause) -> forClause
  member this.OffsetClause = 
    match this with
    | BinaryQueryExpression(offsetClause=offsetClause) -> offsetClause
    | QueryParenthesisExpression(offsetClause=offsetClause) -> offsetClause
    | QuerySpecification(offsetClause=offsetClause) -> offsetClause
  member this.OrderByClause = 
    match this with
    | BinaryQueryExpression(orderByClause=orderByClause) -> orderByClause
    | QueryParenthesisExpression(orderByClause=orderByClause) -> orderByClause
    | QuerySpecification(orderByClause=orderByClause) -> orderByClause
  static member FromCs(src:ScriptDom.QueryExpression) : QueryExpression =
    match src with
    | :? ScriptDom.BinaryQueryExpression as src ->
      QueryExpression.BinaryQueryExpression((src.All), (src.BinaryQueryExpressionType), (src.FirstQueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)), (src.ForClause |> Option.ofObj |> Option.map (ForClause.FromCs)), (src.OffsetClause |> Option.ofObj |> Option.map (OffsetClause.FromCs)), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.SecondQueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
    | :? ScriptDom.QueryParenthesisExpression as src ->
      QueryExpression.QueryParenthesisExpression((src.ForClause |> Option.ofObj |> Option.map (ForClause.FromCs)), (src.OffsetClause |> Option.ofObj |> Option.map (OffsetClause.FromCs)), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
    | :? ScriptDom.QuerySpecification as src ->
      QueryExpression.QuerySpecification((src.ForClause |> Option.ofObj |> Option.map (ForClause.FromCs)), (src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.GroupByClause |> Option.ofObj |> Option.map (GroupByClause.FromCs)), (src.HavingClause |> Option.ofObj |> Option.map (HavingClause.FromCs)), (src.OffsetClause |> Option.ofObj |> Option.map (OffsetClause.FromCs)), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.SelectElements |> Seq.map (SelectElement.FromCs) |> List.ofSeq), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.UniqueRowFilter), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))
and QueryStoreOption = (* IsAbstract = true , children = 8*)
  | QueryStoreCapturePolicyOption of optionKind:ScriptDom.QueryStoreOptionKind * value:ScriptDom.QueryStoreCapturePolicyOptionKind
  | QueryStoreDataFlushIntervalOption of flushInterval:Literal option * optionKind:ScriptDom.QueryStoreOptionKind
  | QueryStoreDesiredStateOption of operationModeSpecified:bool * optionKind:ScriptDom.QueryStoreOptionKind * value:ScriptDom.QueryStoreDesiredStateOptionKind
  | QueryStoreIntervalLengthOption of optionKind:ScriptDom.QueryStoreOptionKind * statsIntervalLength:Literal option
  | QueryStoreMaxPlansPerQueryOption of maxPlansPerQuery:Literal option * optionKind:ScriptDom.QueryStoreOptionKind
  | QueryStoreMaxStorageSizeOption of maxQdsSize:Literal option * optionKind:ScriptDom.QueryStoreOptionKind
  | QueryStoreSizeCleanupPolicyOption of optionKind:ScriptDom.QueryStoreOptionKind * value:ScriptDom.QueryStoreSizeCleanupPolicyOptionKind
  | QueryStoreTimeCleanupPolicyOption of optionKind:ScriptDom.QueryStoreOptionKind * staleQueryThreshold:Literal option
  member this.ToCs() : ScriptDom.QueryStoreOption =
    match this with
    | QueryStoreCapturePolicyOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.QueryStoreCapturePolicyOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreDataFlushIntervalOption(flushInterval=aFlushInterval; optionKind=aOptionKind) ->
      let ret = ScriptDom.QueryStoreDataFlushIntervalOption()
      ret.FlushInterval <- aFlushInterval |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreDesiredStateOption(operationModeSpecified=aOperationModeSpecified; optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.QueryStoreDesiredStateOption()
      ret.OperationModeSpecified <- aOperationModeSpecified
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreIntervalLengthOption(optionKind=aOptionKind; statsIntervalLength=aStatsIntervalLength) ->
      let ret = ScriptDom.QueryStoreIntervalLengthOption()
      ret.OptionKind <- aOptionKind
      ret.StatsIntervalLength <- aStatsIntervalLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreMaxPlansPerQueryOption(maxPlansPerQuery=aMaxPlansPerQuery; optionKind=aOptionKind) ->
      let ret = ScriptDom.QueryStoreMaxPlansPerQueryOption()
      ret.MaxPlansPerQuery <- aMaxPlansPerQuery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreMaxStorageSizeOption(maxQdsSize=aMaxQdsSize; optionKind=aOptionKind) ->
      let ret = ScriptDom.QueryStoreMaxStorageSizeOption()
      ret.MaxQdsSize <- aMaxQdsSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreSizeCleanupPolicyOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.QueryStoreSizeCleanupPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.QueryStoreOption (* 404 *)
    | QueryStoreTimeCleanupPolicyOption(optionKind=aOptionKind; staleQueryThreshold=aStaleQueryThreshold) ->
      let ret = ScriptDom.QueryStoreTimeCleanupPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.StaleQueryThreshold <- aStaleQueryThreshold |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueryStoreOption (* 404 *)
//// shared props QueryStoreOption 
  member this.OptionKind = 
    match this with
    | QueryStoreCapturePolicyOption(optionKind=optionKind) -> optionKind
    | QueryStoreDataFlushIntervalOption(optionKind=optionKind) -> optionKind
    | QueryStoreDesiredStateOption(optionKind=optionKind) -> optionKind
    | QueryStoreIntervalLengthOption(optionKind=optionKind) -> optionKind
    | QueryStoreMaxPlansPerQueryOption(optionKind=optionKind) -> optionKind
    | QueryStoreMaxStorageSizeOption(optionKind=optionKind) -> optionKind
    | QueryStoreSizeCleanupPolicyOption(optionKind=optionKind) -> optionKind
    | QueryStoreTimeCleanupPolicyOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.QueryStoreOption) : QueryStoreOption =
    match src with
    | :? ScriptDom.QueryStoreCapturePolicyOption as src ->
      QueryStoreOption.QueryStoreCapturePolicyOption((src.OptionKind), (src.Value))
    | :? ScriptDom.QueryStoreDataFlushIntervalOption as src ->
      QueryStoreOption.QueryStoreDataFlushIntervalOption((src.FlushInterval |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.QueryStoreDesiredStateOption as src ->
      QueryStoreOption.QueryStoreDesiredStateOption((src.OperationModeSpecified), (src.OptionKind), (src.Value))
    | :? ScriptDom.QueryStoreIntervalLengthOption as src ->
      QueryStoreOption.QueryStoreIntervalLengthOption((src.OptionKind), (src.StatsIntervalLength |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.QueryStoreMaxPlansPerQueryOption as src ->
      QueryStoreOption.QueryStoreMaxPlansPerQueryOption((src.MaxPlansPerQuery |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.QueryStoreMaxStorageSizeOption as src ->
      QueryStoreOption.QueryStoreMaxStorageSizeOption((src.MaxQdsSize |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.QueryStoreSizeCleanupPolicyOption as src ->
      QueryStoreOption.QueryStoreSizeCleanupPolicyOption((src.OptionKind), (src.Value))
    | :? ScriptDom.QueryStoreTimeCleanupPolicyOption as src ->
      QueryStoreOption.QueryStoreTimeCleanupPolicyOption((src.OptionKind), (src.StaleQueryThreshold |> Option.ofObj |> Option.map (Literal.FromCs)))
and QueueOption = (* IsAbstract = false , children = 4*)
  | Base of optionKind:ScriptDom.QueueOptionKind
  | QueueExecuteAsOption of optionKind:ScriptDom.QueueOptionKind * optionValue:ExecuteAsClause option
  | QueueProcedureOption of optionKind:ScriptDom.QueueOptionKind * optionValue:SchemaObjectName option
  | QueueStateOption of optionKind:ScriptDom.QueueOptionKind * optionState:ScriptDom.OptionState
  | QueueValueOption of optionKind:ScriptDom.QueueOptionKind * optionValue:ValueExpression option
  member this.ToCs() : ScriptDom.QueueOption =
    match this with
    | QueueExecuteAsOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.QueueExecuteAsOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueueOption (* 404 *)
    | QueueProcedureOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.QueueProcedureOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueueOption (* 404 *)
    | QueueStateOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.QueueStateOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.QueueOption (* 404 *)
    | QueueValueOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.QueueValueOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.QueueOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.QueueOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props QueueOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | QueueExecuteAsOption(optionKind=optionKind) -> optionKind
    | QueueProcedureOption(optionKind=optionKind) -> optionKind
    | QueueStateOption(optionKind=optionKind) -> optionKind
    | QueueValueOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.QueueOption) : QueueOption =
    match src with
    | :? ScriptDom.QueueExecuteAsOption as src ->
      QueueOption.QueueExecuteAsOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)))
    | :? ScriptDom.QueueProcedureOption as src ->
      QueueOption.QueueProcedureOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.QueueStateOption as src ->
      QueueOption.QueueStateOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.QueueValueOption as src ->
      QueueOption.QueueValueOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | _ -> (* :? ScriptDom.QueueOption as src *)
      QueueOption.Base(((src.OptionKind)))
and RemoteDataArchiveDatabaseSetting = (* IsAbstract = true , children = 3*)
  | RemoteDataArchiveDbCredentialSetting of credential:Identifier option * settingKind:ScriptDom.RemoteDataArchiveDatabaseSettingKind
  | RemoteDataArchiveDbFederatedServiceAccountSetting of isOn:bool * settingKind:ScriptDom.RemoteDataArchiveDatabaseSettingKind
  | RemoteDataArchiveDbServerSetting of server:StringLiteral option * settingKind:ScriptDom.RemoteDataArchiveDatabaseSettingKind
  member this.ToCs() : ScriptDom.RemoteDataArchiveDatabaseSetting =
    match this with
    | RemoteDataArchiveDbCredentialSetting(credential=aCredential; settingKind=aSettingKind) ->
      let ret = ScriptDom.RemoteDataArchiveDbCredentialSetting()
      ret.Credential <- aCredential |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SettingKind <- aSettingKind
      ret :> ScriptDom.RemoteDataArchiveDatabaseSetting (* 404 *)
    | RemoteDataArchiveDbFederatedServiceAccountSetting(isOn=aIsOn; settingKind=aSettingKind) ->
      let ret = ScriptDom.RemoteDataArchiveDbFederatedServiceAccountSetting()
      ret.IsOn <- aIsOn
      ret.SettingKind <- aSettingKind
      ret :> ScriptDom.RemoteDataArchiveDatabaseSetting (* 404 *)
    | RemoteDataArchiveDbServerSetting(server=aServer; settingKind=aSettingKind) ->
      let ret = ScriptDom.RemoteDataArchiveDbServerSetting()
      ret.Server <- aServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SettingKind <- aSettingKind
      ret :> ScriptDom.RemoteDataArchiveDatabaseSetting (* 404 *)
//// shared props RemoteDataArchiveDatabaseSetting 
  member this.SettingKind = 
    match this with
    | RemoteDataArchiveDbCredentialSetting(settingKind=settingKind) -> settingKind
    | RemoteDataArchiveDbFederatedServiceAccountSetting(settingKind=settingKind) -> settingKind
    | RemoteDataArchiveDbServerSetting(settingKind=settingKind) -> settingKind
  static member FromCs(src:ScriptDom.RemoteDataArchiveDatabaseSetting) : RemoteDataArchiveDatabaseSetting =
    match src with
    | :? ScriptDom.RemoteDataArchiveDbCredentialSetting as src ->
      RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbCredentialSetting((src.Credential |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SettingKind))
    | :? ScriptDom.RemoteDataArchiveDbFederatedServiceAccountSetting as src ->
      RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbFederatedServiceAccountSetting((src.IsOn), (src.SettingKind))
    | :? ScriptDom.RemoteDataArchiveDbServerSetting as src ->
      RemoteDataArchiveDatabaseSetting.RemoteDataArchiveDbServerSetting((src.Server |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.SettingKind))
and RemoteServiceBindingOption = (* IsAbstract = true , children = 2*)
  | OnOffRemoteServiceBindingOption of optionKind:ScriptDom.RemoteServiceBindingOptionKind * optionState:ScriptDom.OptionState
  | UserRemoteServiceBindingOption of optionKind:ScriptDom.RemoteServiceBindingOptionKind * user:Identifier option
  member this.ToCs() : ScriptDom.RemoteServiceBindingOption =
    match this with
    | OnOffRemoteServiceBindingOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffRemoteServiceBindingOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.RemoteServiceBindingOption (* 404 *)
    | UserRemoteServiceBindingOption(optionKind=aOptionKind; user=aUser) ->
      let ret = ScriptDom.UserRemoteServiceBindingOption()
      ret.OptionKind <- aOptionKind
      ret.User <- aUser |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.RemoteServiceBindingOption (* 404 *)
//// shared props RemoteServiceBindingOption 
  member this.OptionKind = 
    match this with
    | OnOffRemoteServiceBindingOption(optionKind=optionKind) -> optionKind
    | UserRemoteServiceBindingOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.RemoteServiceBindingOption) : RemoteServiceBindingOption =
    match src with
    | :? ScriptDom.OnOffRemoteServiceBindingOption as src ->
      RemoteServiceBindingOption.OnOffRemoteServiceBindingOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.UserRemoteServiceBindingOption as src ->
      RemoteServiceBindingOption.UserRemoteServiceBindingOption((src.OptionKind), (src.User |> Option.ofObj |> Option.map (Identifier.FromCs)))
and RestoreOption = (* IsAbstract = false , children = 4*)
  | Base of optionKind:ScriptDom.RestoreOptionKind
  | FileStreamRestoreOption of fileStreamOption:FileStreamDatabaseOption option * optionKind:ScriptDom.RestoreOptionKind
  | MoveRestoreOption of logicalFileName:ValueExpression option * oSFileName:ValueExpression option * optionKind:ScriptDom.RestoreOptionKind
  | ScalarExpressionRestoreOption of optionKind:ScriptDom.RestoreOptionKind * value:ScalarExpression option
  | StopRestoreOption of after:ValueExpression option * isStopAt:bool * mark:ValueExpression option * optionKind:ScriptDom.RestoreOptionKind
  member this.ToCs() : ScriptDom.RestoreOption =
    match this with
    | FileStreamRestoreOption(fileStreamOption=aFileStreamOption; optionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamRestoreOption()
      ret.FileStreamOption <- aFileStreamOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.RestoreOption (* 404 *)
    | MoveRestoreOption(logicalFileName=aLogicalFileName; oSFileName=aOSFileName; optionKind=aOptionKind) ->
      let ret = ScriptDom.MoveRestoreOption()
      ret.LogicalFileName <- aLogicalFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OSFileName <- aOSFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.RestoreOption (* 404 *)
    | ScalarExpressionRestoreOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ScalarExpressionRestoreOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.RestoreOption (* 404 *)
    | StopRestoreOption(after=aAfter; isStopAt=aIsStopAt; mark=aMark; optionKind=aOptionKind) ->
      let ret = ScriptDom.StopRestoreOption()
      ret.After <- aAfter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsStopAt <- aIsStopAt
      ret.Mark <- aMark |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.RestoreOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.RestoreOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props RestoreOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | FileStreamRestoreOption(optionKind=optionKind) -> optionKind
    | MoveRestoreOption(optionKind=optionKind) -> optionKind
    | ScalarExpressionRestoreOption(optionKind=optionKind) -> optionKind
    | StopRestoreOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.RestoreOption) : RestoreOption =
    match src with
    | :? ScriptDom.FileStreamRestoreOption as src ->
      RestoreOption.FileStreamRestoreOption((src.FileStreamOption |> Option.ofObj |> Option.map (FileStreamDatabaseOption.FromCs)), (src.OptionKind))
    | :? ScriptDom.MoveRestoreOption as src ->
      RestoreOption.MoveRestoreOption((src.LogicalFileName |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.OSFileName |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.OptionKind))
    | :? ScriptDom.ScalarExpressionRestoreOption as src ->
      RestoreOption.ScalarExpressionRestoreOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.StopRestoreOption as src ->
      RestoreOption.StopRestoreOption((src.After |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.IsStopAt), (src.Mark |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.OptionKind))
    | _ -> (* :? ScriptDom.RestoreOption as src *)
      RestoreOption.Base(((src.OptionKind)))
and ResultSetDefinition = (* IsAbstract = false , children = 2*)
  | Base of resultSetType:ScriptDom.ResultSetType
  | InlineResultSetDefinition of resultColumnDefinitions:(ResultColumnDefinition) list * resultSetType:ScriptDom.ResultSetType
  | SchemaObjectResultSetDefinition of name:SchemaObjectName option * resultSetType:ScriptDom.ResultSetType
  member this.ToCs() : ScriptDom.ResultSetDefinition =
    match this with
    | InlineResultSetDefinition(resultColumnDefinitions=aResultColumnDefinitions; resultSetType=aResultSetType) ->
      let ret = ScriptDom.InlineResultSetDefinition()
      for e in aResultColumnDefinitions do ret.ResultColumnDefinitions.Add (e.ToCs())
      ret.ResultSetType <- aResultSetType
      ret :> ScriptDom.ResultSetDefinition (* 404 *)
    | SchemaObjectResultSetDefinition(name=aName; resultSetType=aResultSetType) ->
      let ret = ScriptDom.SchemaObjectResultSetDefinition()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ResultSetType <- aResultSetType
      ret :> ScriptDom.ResultSetDefinition (* 404 *)
    | Base(resultSetType=aResultSetType) ->

      let ret = ScriptDom.ResultSetDefinition()
      ret.ResultSetType <- aResultSetType
      ret
//// shared props ResultSetDefinition 
  member this.ResultSetType = 
    match this with
    | Base (resultSetType=resultSetType) -> resultSetType
    | InlineResultSetDefinition(resultSetType=resultSetType) -> resultSetType
    | SchemaObjectResultSetDefinition(resultSetType=resultSetType) -> resultSetType
  static member FromCs(src:ScriptDom.ResultSetDefinition) : ResultSetDefinition =
    match src with
    | :? ScriptDom.InlineResultSetDefinition as src ->
      ResultSetDefinition.InlineResultSetDefinition((src.ResultColumnDefinitions |> Seq.map (fun src -> ResultColumnDefinition.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))) |> List.ofSeq), (src.ResultSetType))
    | :? ScriptDom.SchemaObjectResultSetDefinition as src ->
      ResultSetDefinition.SchemaObjectResultSetDefinition((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ResultSetType))
    | _ -> (* :? ScriptDom.ResultSetDefinition as src *)
      ResultSetDefinition.Base(((src.ResultSetType)))
and ScalarExpression = (* IsAbstract = true , children = 8*)
  | BinaryExpression of binaryExpressionType:ScriptDom.BinaryExpressionType * firstExpression:ScalarExpression option * secondExpression:ScalarExpression option
  | ExtractFromExpression of expression:ScalarExpression option * extractedElement:Identifier option
  | IdentityFunctionCall of dataType:DataTypeReference option * increment:ScalarExpression option * seed:ScalarExpression option
  | OdbcConvertSpecification of identifier:Identifier option
  | PrimaryExpression of primaryExpression:PrimaryExpression
  | ScalarExpressionSnippet of script:String
  | SourceDeclaration of value:EventSessionObjectName option
  | UnaryExpression of expression:ScalarExpression option * unaryExpressionType:ScriptDom.UnaryExpressionType
  member this.ToCs() : ScriptDom.ScalarExpression =
    match this with
    | BinaryExpression(binaryExpressionType=aBinaryExpressionType; firstExpression=aFirstExpression; secondExpression=aSecondExpression) ->
      let ret = ScriptDom.BinaryExpression()
      ret.BinaryExpressionType <- aBinaryExpressionType
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 404 *)
    | ExtractFromExpression(expression=aExpression; extractedElement=aExtractedElement) ->
      let ret = ScriptDom.ExtractFromExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExtractedElement <- aExtractedElement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 404 *)
    | IdentityFunctionCall(dataType=aDataType; increment=aIncrement; seed=aSeed) ->
      let ret = ScriptDom.IdentityFunctionCall()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Increment <- aIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Seed <- aSeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 404 *)
    | OdbcConvertSpecification(identifier=aIdentifier) ->
      let ret = ScriptDom.OdbcConvertSpecification()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 404 *)
    | PrimaryExpression(x) -> x.ToCs() :> ScriptDom.ScalarExpression (* 414 *)
    | ScalarExpressionSnippet(script=aScript) ->
      let ret = ScriptDom.ScalarExpressionSnippet()
      ret.Script <- aScript
      ret :> ScriptDom.ScalarExpression (* 404 *)
    | SourceDeclaration(value=aValue) ->
      let ret = ScriptDom.SourceDeclaration()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ScalarExpression (* 404 *)
    | UnaryExpression(expression=aExpression; unaryExpressionType=aUnaryExpressionType) ->
      let ret = ScriptDom.UnaryExpression()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UnaryExpressionType <- aUnaryExpressionType
      ret :> ScriptDom.ScalarExpression (* 404 *)
  static member FromCs(src:ScriptDom.ScalarExpression) : ScalarExpression =
    match src with
    | :? ScriptDom.BinaryExpression as src ->
      ScalarExpression.BinaryExpression((src.BinaryExpressionType), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ExtractFromExpression as src ->
      ScalarExpression.ExtractFromExpression((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.ExtractedElement |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.IdentityFunctionCall as src ->
      ScalarExpression.IdentityFunctionCall((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Increment |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Seed |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.OdbcConvertSpecification as src ->
      ScalarExpression.OdbcConvertSpecification((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.PrimaryExpression as src ->
      match src with
      | :? ScriptDom.AtTimeZoneCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.AtTimeZoneCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DateValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TimeZone |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.CaseExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.CaseExpression((CaseExpression.FromCs(src)))))
      | :? ScriptDom.CastCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.CastCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.CoalesceExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.CoalesceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ColumnReferenceExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))))
      | :? ScriptDom.ConvertCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ConvertCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Style |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.FunctionCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.FunctionCall((src.CallTarget |> Option.ofObj |> Option.map (CallTarget.FromCs)), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FunctionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OverClause |> Option.ofObj |> Option.map (OverClause.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.UniqueRowFilter), (src.WithinGroupClause |> Option.ofObj |> Option.map (WithinGroupClause.FromCs)))))
      | :? ScriptDom.IIfCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.IIfCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ElseExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Predicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.LeftFunctionCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.LeftFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.NextValueForExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.NextValueForExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OverClause |> Option.ofObj |> Option.map (OverClause.FromCs)), (src.SequenceName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.NullIfExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.NullIfExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.OdbcFunctionCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.OdbcFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ParametersUsed))))
      | :? ScriptDom.ParameterlessCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ParameterlessCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterlessCallType))))
      | :? ScriptDom.ParenthesisExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ParenthesisExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.ParseCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ParseCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Culture |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.StringValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.PartitionFunctionCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.PartitionFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FunctionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.RightFunctionCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.RightFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ScalarSubquery as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ScalarSubquery((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))))
      | :? ScriptDom.TryCastCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.TryCastCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.TryConvertCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.TryConvertCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Style |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.TryParseCall as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.TryParseCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Culture |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.StringValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.UserDefinedTypePropertyAccess as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.UserDefinedTypePropertyAccess((src.CallTarget |> Option.ofObj |> Option.map (CallTarget.FromCs)), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.ValueExpression as src->
        ScalarExpression.PrimaryExpression((PrimaryExpression.ValueExpression((ValueExpression.FromCs(src)))))
    | :? ScriptDom.ScalarExpressionSnippet as src ->
      ScalarExpression.ScalarExpressionSnippet((src.Script))
    | :? ScriptDom.SourceDeclaration as src ->
      ScalarExpression.SourceDeclaration((src.Value |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))
    | :? ScriptDom.UnaryExpression as src ->
      ScalarExpression.UnaryExpression((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.UnaryExpressionType))
and SchemaDeclarationItem = (* IsAbstract = false , children = 1*)
  | Base of columnDefinition:ColumnDefinitionBase option * mapping:ValueExpression option
  | SchemaDeclarationItemOpenjson of asJson:bool * columnDefinition:ColumnDefinitionBase option * mapping:ValueExpression option
  member this.ToCs() : ScriptDom.SchemaDeclarationItem =
    match this with
    | SchemaDeclarationItemOpenjson(asJson=aAsJson; columnDefinition=aColumnDefinition; mapping=aMapping) ->
      let ret = ScriptDom.SchemaDeclarationItemOpenjson()
      ret.AsJson <- aAsJson
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Mapping <- aMapping |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SchemaDeclarationItem (* 404 *)
    | Base(columnDefinition=aColumnDefinition; mapping=aMapping) ->

      let ret = ScriptDom.SchemaDeclarationItem()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Mapping <- aMapping |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props SchemaDeclarationItem 
  member this.ColumnDefinition = 
    match this with
    | Base (columnDefinition=columnDefinition) -> columnDefinition
    | SchemaDeclarationItemOpenjson(columnDefinition=columnDefinition) -> columnDefinition
  member this.Mapping = 
    match this with
    | Base (mapping=mapping) -> mapping
    | SchemaDeclarationItemOpenjson(mapping=mapping) -> mapping
  static member FromCs(src:ScriptDom.SchemaDeclarationItem) : SchemaDeclarationItem =
    match src with
    | :? ScriptDom.SchemaDeclarationItemOpenjson as src ->
      SchemaDeclarationItem.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | _ -> (* :? ScriptDom.SchemaDeclarationItem as src *)
      SchemaDeclarationItem.Base(((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs))))
and SearchPropertyListAction = (* IsAbstract = true , children = 2*)
  | AddSearchPropertyListAction of description:StringLiteral option * guid:StringLiteral option * id:IntegerLiteral option * propertyName:StringLiteral option
  | DropSearchPropertyListAction of propertyName:StringLiteral option
  member this.ToCs() : ScriptDom.SearchPropertyListAction =
    match this with
    | AddSearchPropertyListAction(description=aDescription; guid=aGuid; id=aId; propertyName=aPropertyName) ->
      let ret = ScriptDom.AddSearchPropertyListAction()
      ret.Description <- aDescription |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Guid <- aGuid |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Id <- aId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SearchPropertyListAction (* 404 *)
    | DropSearchPropertyListAction(propertyName=aPropertyName) ->
      let ret = ScriptDom.DropSearchPropertyListAction()
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SearchPropertyListAction (* 404 *)
  static member FromCs(src:ScriptDom.SearchPropertyListAction) : SearchPropertyListAction =
    match src with
    | :? ScriptDom.AddSearchPropertyListAction as src ->
      SearchPropertyListAction.AddSearchPropertyListAction((src.Description |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Guid |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Id |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.DropSearchPropertyListAction as src ->
      SearchPropertyListAction.DropSearchPropertyListAction((src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
and SecurityElement80 = (* IsAbstract = true , children = 2*)
  | CommandSecurityElement80 of all:bool * commandOptions:ScriptDom.CommandOptions
  | PrivilegeSecurityElement80 of columns:(Identifier) list * privileges:(Privilege80) list * schemaObjectName:SchemaObjectName option
  member this.ToCs() : ScriptDom.SecurityElement80 =
    match this with
    | CommandSecurityElement80(all=aAll; commandOptions=aCommandOptions) ->
      let ret = ScriptDom.CommandSecurityElement80()
      ret.All <- aAll
      ret.CommandOptions <- aCommandOptions
      ret :> ScriptDom.SecurityElement80 (* 404 *)
    | PrivilegeSecurityElement80(columns=aColumns; privileges=aPrivileges; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.PrivilegeSecurityElement80()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aPrivileges do ret.Privileges.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityElement80 (* 404 *)
  static member FromCs(src:ScriptDom.SecurityElement80) : SecurityElement80 =
    match src with
    | :? ScriptDom.CommandSecurityElement80 as src ->
      SecurityElement80.CommandSecurityElement80((src.All), (src.CommandOptions))
    | :? ScriptDom.PrivilegeSecurityElement80 as src ->
      SecurityElement80.PrivilegeSecurityElement80((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Privileges |> Seq.map (fun src -> Privilege80.Privilege80((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrivilegeType80))) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and SelectElement = (* IsAbstract = true , children = 3*)
  | SelectScalarExpression of columnName:IdentifierOrValueExpression option * expression:ScalarExpression option
  | SelectSetVariable of assignmentKind:ScriptDom.AssignmentKind * expression:ScalarExpression option * variable:VariableReference option
  | SelectStarExpression of qualifier:MultiPartIdentifier option
  member this.ToCs() : ScriptDom.SelectElement =
    match this with
    | SelectScalarExpression(columnName=aColumnName; expression=aExpression) ->
      let ret = ScriptDom.SelectScalarExpression()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectElement (* 404 *)
    | SelectSetVariable(assignmentKind=aAssignmentKind; expression=aExpression; variable=aVariable) ->
      let ret = ScriptDom.SelectSetVariable()
      ret.AssignmentKind <- aAssignmentKind
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectElement (* 404 *)
    | SelectStarExpression(qualifier=aQualifier) ->
      let ret = ScriptDom.SelectStarExpression()
      ret.Qualifier <- aQualifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectElement (* 404 *)
  static member FromCs(src:ScriptDom.SelectElement) : SelectElement =
    match src with
    | :? ScriptDom.SelectScalarExpression as src ->
      SelectElement.SelectScalarExpression((src.ColumnName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.SelectSetVariable as src ->
      SelectElement.SelectSetVariable((src.AssignmentKind), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.SelectStarExpression as src ->
      SelectElement.SelectStarExpression((src.Qualifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
and SequenceOption = (* IsAbstract = false , children = 2*)
  | Base of noValue:bool * optionKind:ScriptDom.SequenceOptionKind
  | DataTypeSequenceOption of dataType:DataTypeReference option * noValue:bool * optionKind:ScriptDom.SequenceOptionKind
  | ScalarExpressionSequenceOption of noValue:bool * optionKind:ScriptDom.SequenceOptionKind * optionValue:ScalarExpression option
  member this.ToCs() : ScriptDom.SequenceOption =
    match this with
    | DataTypeSequenceOption(dataType=aDataType; noValue=aNoValue; optionKind=aOptionKind) ->
      let ret = ScriptDom.DataTypeSequenceOption()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NoValue <- aNoValue
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.SequenceOption (* 404 *)
    | ScalarExpressionSequenceOption(noValue=aNoValue; optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.ScalarExpressionSequenceOption()
      ret.NoValue <- aNoValue
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SequenceOption (* 404 *)
    | Base(noValue=aNoValue; optionKind=aOptionKind) ->

      let ret = ScriptDom.SequenceOption()
      ret.NoValue <- aNoValue
      ret.OptionKind <- aOptionKind
      ret
//// shared props SequenceOption 
  member this.NoValue = 
    match this with
    | Base (noValue=noValue) -> noValue
    | DataTypeSequenceOption(noValue=noValue) -> noValue
    | ScalarExpressionSequenceOption(noValue=noValue) -> noValue
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | DataTypeSequenceOption(optionKind=optionKind) -> optionKind
    | ScalarExpressionSequenceOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.SequenceOption) : SequenceOption =
    match src with
    | :? ScriptDom.DataTypeSequenceOption as src ->
      SequenceOption.DataTypeSequenceOption((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.NoValue), (src.OptionKind))
    | :? ScriptDom.ScalarExpressionSequenceOption as src ->
      SequenceOption.ScalarExpressionSequenceOption((src.NoValue), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | _ -> (* :? ScriptDom.SequenceOption as src *)
      SequenceOption.Base(((src.NoValue), (src.OptionKind)))
and SessionOption = (* IsAbstract = true , children = 5*)
  | EventRetentionSessionOption of optionKind:ScriptDom.SessionOptionKind * value:ScriptDom.EventSessionEventRetentionModeType
  | LiteralSessionOption of optionKind:ScriptDom.SessionOptionKind * unit:ScriptDom.MemoryUnit * value:Literal option
  | MaxDispatchLatencySessionOption of isInfinite:bool * optionKind:ScriptDom.SessionOptionKind * value:Literal option
  | MemoryPartitionSessionOption of optionKind:ScriptDom.SessionOptionKind * value:ScriptDom.EventSessionMemoryPartitionModeType
  | OnOffSessionOption of optionKind:ScriptDom.SessionOptionKind * optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.SessionOption =
    match this with
    | EventRetentionSessionOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.EventRetentionSessionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.SessionOption (* 404 *)
    | LiteralSessionOption(optionKind=aOptionKind; unit=aUnit; value=aValue) ->
      let ret = ScriptDom.LiteralSessionOption()
      ret.OptionKind <- aOptionKind
      ret.Unit <- aUnit
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SessionOption (* 404 *)
    | MaxDispatchLatencySessionOption(isInfinite=aIsInfinite; optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.MaxDispatchLatencySessionOption()
      ret.IsInfinite <- aIsInfinite
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SessionOption (* 404 *)
    | MemoryPartitionSessionOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.MemoryPartitionSessionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.SessionOption (* 404 *)
    | OnOffSessionOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffSessionOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.SessionOption (* 404 *)
//// shared props SessionOption 
  member this.OptionKind = 
    match this with
    | EventRetentionSessionOption(optionKind=optionKind) -> optionKind
    | LiteralSessionOption(optionKind=optionKind) -> optionKind
    | MaxDispatchLatencySessionOption(optionKind=optionKind) -> optionKind
    | MemoryPartitionSessionOption(optionKind=optionKind) -> optionKind
    | OnOffSessionOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.SessionOption) : SessionOption =
    match src with
    | :? ScriptDom.EventRetentionSessionOption as src ->
      SessionOption.EventRetentionSessionOption((src.OptionKind), (src.Value))
    | :? ScriptDom.LiteralSessionOption as src ->
      SessionOption.LiteralSessionOption((src.OptionKind), (src.Unit), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.MaxDispatchLatencySessionOption as src ->
      SessionOption.MaxDispatchLatencySessionOption((src.IsInfinite), (src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.MemoryPartitionSessionOption as src ->
      SessionOption.MemoryPartitionSessionOption((src.OptionKind), (src.Value))
    | :? ScriptDom.OnOffSessionOption as src ->
      SessionOption.OnOffSessionOption((src.OptionKind), (src.OptionState))
and SetClause = (* IsAbstract = true , children = 2*)
  | AssignmentSetClause of assignmentKind:ScriptDom.AssignmentKind * column:ColumnReferenceExpression option * newValue:ScalarExpression option * variable:VariableReference option
  | FunctionCallSetClause of mutatorFunction:FunctionCall option
  member this.ToCs() : ScriptDom.SetClause =
    match this with
    | AssignmentSetClause(assignmentKind=aAssignmentKind; column=aColumn; newValue=aNewValue; variable=aVariable) ->
      let ret = ScriptDom.AssignmentSetClause()
      ret.AssignmentKind <- aAssignmentKind
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NewValue <- aNewValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetClause (* 404 *)
    | FunctionCallSetClause(mutatorFunction=aMutatorFunction) ->
      let ret = ScriptDom.FunctionCallSetClause()
      ret.MutatorFunction <- aMutatorFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetClause (* 404 *)
  static member FromCs(src:ScriptDom.SetClause) : SetClause =
    match src with
    | :? ScriptDom.AssignmentSetClause as src ->
      SetClause.AssignmentSetClause((src.AssignmentKind), (src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.NewValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.FunctionCallSetClause as src ->
      SetClause.FunctionCallSetClause((src.MutatorFunction |> Option.ofObj |> Option.map (FunctionCall.FromCs)))
and SetCommand = (* IsAbstract = true , children = 2*)
  | GeneralSetCommand of commandType:ScriptDom.GeneralSetCommandType * parameter:ScalarExpression option
  | SetFipsFlaggerCommand of complianceLevel:ScriptDom.FipsComplianceLevel
  member this.ToCs() : ScriptDom.SetCommand =
    match this with
    | GeneralSetCommand(commandType=aCommandType; parameter=aParameter) ->
      let ret = ScriptDom.GeneralSetCommand()
      ret.CommandType <- aCommandType
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetCommand (* 404 *)
    | SetFipsFlaggerCommand(complianceLevel=aComplianceLevel) ->
      let ret = ScriptDom.SetFipsFlaggerCommand()
      ret.ComplianceLevel <- aComplianceLevel
      ret :> ScriptDom.SetCommand (* 404 *)
  static member FromCs(src:ScriptDom.SetCommand) : SetCommand =
    match src with
    | :? ScriptDom.GeneralSetCommand as src ->
      SetCommand.GeneralSetCommand((src.CommandType), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.SetFipsFlaggerCommand as src ->
      SetCommand.SetFipsFlaggerCommand((src.ComplianceLevel))
and SpatialIndexOption = (* IsAbstract = true , children = 4*)
  | BoundingBoxSpatialIndexOption of boundingBoxParameters:(BoundingBoxParameter) list
  | CellsPerObjectSpatialIndexOption of value:Literal option
  | GridsSpatialIndexOption of gridParameters:(GridParameter) list
  | SpatialIndexRegularOption of option:IndexOption option
  member this.ToCs() : ScriptDom.SpatialIndexOption =
    match this with
    | BoundingBoxSpatialIndexOption(boundingBoxParameters=aBoundingBoxParameters) ->
      let ret = ScriptDom.BoundingBoxSpatialIndexOption()
      for e in aBoundingBoxParameters do ret.BoundingBoxParameters.Add (e.ToCs())
      ret :> ScriptDom.SpatialIndexOption (* 404 *)
    | CellsPerObjectSpatialIndexOption(value=aValue) ->
      let ret = ScriptDom.CellsPerObjectSpatialIndexOption()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SpatialIndexOption (* 404 *)
    | GridsSpatialIndexOption(gridParameters=aGridParameters) ->
      let ret = ScriptDom.GridsSpatialIndexOption()
      for e in aGridParameters do ret.GridParameters.Add (e.ToCs())
      ret :> ScriptDom.SpatialIndexOption (* 404 *)
    | SpatialIndexRegularOption(option=aOption) ->
      let ret = ScriptDom.SpatialIndexRegularOption()
      ret.Option <- aOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SpatialIndexOption (* 404 *)
  static member FromCs(src:ScriptDom.SpatialIndexOption) : SpatialIndexOption =
    match src with
    | :? ScriptDom.BoundingBoxSpatialIndexOption as src ->
      SpatialIndexOption.BoundingBoxSpatialIndexOption((src.BoundingBoxParameters |> Seq.map (fun src -> BoundingBoxParameter.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.CellsPerObjectSpatialIndexOption as src ->
      SpatialIndexOption.CellsPerObjectSpatialIndexOption((src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.GridsSpatialIndexOption as src ->
      SpatialIndexOption.GridsSpatialIndexOption((src.GridParameters |> Seq.map (fun src -> GridParameter.GridParameter((src.Parameter), (src.Value))) |> List.ofSeq))
    | :? ScriptDom.SpatialIndexRegularOption as src ->
      SpatialIndexOption.SpatialIndexRegularOption((src.Option |> Option.ofObj |> Option.map (IndexOption.FromCs)))
and StatementList = (* IsAbstract = false , children = 1*)
  | Base of statements:(TSqlStatement) list
  | StatementListSnippet of script:String * statements:(TSqlStatement) list
  member this.ToCs() : ScriptDom.StatementList =
    match this with
    | StatementListSnippet(script=aScript; statements=aStatements) ->
      let ret = ScriptDom.StatementListSnippet()
      ret.Script <- aScript
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret :> ScriptDom.StatementList (* 404 *)
    | Base(statements=aStatements) ->

      let ret = ScriptDom.StatementList()
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret
//// shared props StatementList 
  member this.Statements = 
    match this with
    | Base (statements=statements) -> statements
    | StatementListSnippet(statements=statements) -> statements
  static member FromCs(src:ScriptDom.StatementList) : StatementList =
    match src with
    | :? ScriptDom.StatementListSnippet as src ->
      StatementList.StatementListSnippet((src.Script), (src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq))
    | _ -> (* :? ScriptDom.StatementList as src *)
      StatementList.Base(((src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq)))
and StatisticsOption = (* IsAbstract = false , children = 3*)
  | Base of optionKind:ScriptDom.StatisticsOptionKind
  | LiteralStatisticsOption of literal:Literal option * optionKind:ScriptDom.StatisticsOptionKind
  | OnOffStatisticsOption of optionKind:ScriptDom.StatisticsOptionKind * optionState:ScriptDom.OptionState
  | ResampleStatisticsOption of optionKind:ScriptDom.StatisticsOptionKind * partitions:(StatisticsPartitionRange) list
  member this.ToCs() : ScriptDom.StatisticsOption =
    match this with
    | LiteralStatisticsOption(literal=aLiteral; optionKind=aOptionKind) ->
      let ret = ScriptDom.LiteralStatisticsOption()
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.StatisticsOption (* 404 *)
    | OnOffStatisticsOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnOffStatisticsOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.StatisticsOption (* 404 *)
    | ResampleStatisticsOption(optionKind=aOptionKind; partitions=aPartitions) ->
      let ret = ScriptDom.ResampleStatisticsOption()
      ret.OptionKind <- aOptionKind
      for e in aPartitions do ret.Partitions.Add (e.ToCs())
      ret :> ScriptDom.StatisticsOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.StatisticsOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props StatisticsOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | LiteralStatisticsOption(optionKind=optionKind) -> optionKind
    | OnOffStatisticsOption(optionKind=optionKind) -> optionKind
    | ResampleStatisticsOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.StatisticsOption) : StatisticsOption =
    match src with
    | :? ScriptDom.LiteralStatisticsOption as src ->
      StatisticsOption.LiteralStatisticsOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
    | :? ScriptDom.OnOffStatisticsOption as src ->
      StatisticsOption.OnOffStatisticsOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.ResampleStatisticsOption as src ->
      StatisticsOption.ResampleStatisticsOption((src.OptionKind), (src.Partitions |> Seq.map (fun src -> StatisticsPartitionRange.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.To |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)))) |> List.ofSeq))
    | _ -> (* :? ScriptDom.StatisticsOption as src *)
      StatisticsOption.Base(((src.OptionKind)))
and TSqlStatement = (* IsAbstract = true , children = 160*)
  | AlterAsymmetricKeyStatement of attestedBy:Literal option * decryptionPassword:Literal option * encryptionPassword:Literal option * kind:ScriptDom.AlterCertificateStatementKind * name:Identifier option
  | AlterAuthorizationStatement of principalName:Identifier option * securityTargetObject:SecurityTargetObject option * toSchemaOwner:bool
  | AlterCreateEndpointStatementBase of alterCreateEndpointStatementBase:AlterCreateEndpointStatementBase
  | AlterCreateServiceStatementBase of alterCreateServiceStatementBase:AlterCreateServiceStatementBase
  | AlterCryptographicProviderStatement of file:Literal option * name:Identifier option * option:ScriptDom.EnableDisableOptionType
  | AlterDatabaseScopedConfigurationStatement of alterDatabaseScopedConfigurationStatement:AlterDatabaseScopedConfigurationStatement
  | AlterDatabaseStatement of alterDatabaseStatement:AlterDatabaseStatement
  | AlterFederationStatement of boundary:ScalarExpression option * distributionName:Identifier option * kind:ScriptDom.AlterFederationKind * name:Identifier option
  | AlterFullTextIndexStatement of action:AlterFullTextIndexAction option * onName:SchemaObjectName option
  | AlterFullTextStopListStatement of action:FullTextStopListAction option * name:Identifier option
  | AlterLoginStatement of alterLoginStatement:AlterLoginStatement
  | AlterPartitionFunctionStatement of boundary:ScalarExpression option * isSplit:bool * name:Identifier option
  | AlterPartitionSchemeStatement of fileGroup:IdentifierOrValueExpression option * name:Identifier option
  | AlterResourceGovernorStatement of classifierFunction:SchemaObjectName option * command:ScriptDom.AlterResourceGovernorCommandType
  | AlterSchemaStatement of name:Identifier option * objectKind:ScriptDom.SecurityObjectKind * objectName:SchemaObjectName option
  | AlterSearchPropertyListStatement of action:SearchPropertyListAction option * name:Identifier option
  | AlterServerConfigurationSetBufferPoolExtensionStatement of options:(AlterServerConfigurationBufferPoolExtensionOption) list
  | AlterServerConfigurationSetDiagnosticsLogStatement of options:(AlterServerConfigurationDiagnosticsLogOption) list
  | AlterServerConfigurationSetFailoverClusterPropertyStatement of options:(AlterServerConfigurationFailoverClusterPropertyOption) list
  | AlterServerConfigurationSetHadrClusterStatement of options:(AlterServerConfigurationHadrClusterOption) list
  | AlterServerConfigurationSetSoftNumaStatement of options:(AlterServerConfigurationSoftNumaOption) list
  | AlterServerConfigurationStatement of processAffinity:ScriptDom.ProcessAffinityType * processAffinityRanges:(ProcessAffinityRange) list
  | AlterServiceMasterKeyStatement of account:Literal option * kind:ScriptDom.AlterServiceMasterKeyOption * password:Literal option
  | AlterTableStatement of alterTableStatement:AlterTableStatement
  | AlterXmlSchemaCollectionStatement of expression:ScalarExpression option * name:SchemaObjectName option
  | ApplicationRoleStatement of applicationRoleStatement:ApplicationRoleStatement
  | AssemblyStatement of assemblyStatement:AssemblyStatement
  | AuditSpecificationStatement of auditSpecificationStatement:AuditSpecificationStatement
  | AvailabilityGroupStatement of availabilityGroupStatement:AvailabilityGroupStatement
  | BackupRestoreMasterKeyStatementBase of backupRestoreMasterKeyStatementBase:BackupRestoreMasterKeyStatementBase
  | BackupStatement of backupStatement:BackupStatement
  | BeginConversationTimerStatement of handle:ScalarExpression option * timeout:ScalarExpression option
  | BeginDialogStatement of contractName:IdentifierOrValueExpression option * handle:VariableReference option * initiatorServiceName:IdentifierOrValueExpression option * instanceSpec:ValueExpression option * isConversation:bool * options:(DialogOption) list * targetServiceName:ValueExpression option
  | BeginEndBlockStatement of beginEndBlockStatement:BeginEndBlockStatement
  | BreakStatement 
  | BrokerPriorityStatement of brokerPriorityStatement:BrokerPriorityStatement
  | BulkInsertBase of bulkInsertBase:BulkInsertBase
  | CertificateStatementBase of certificateStatementBase:CertificateStatementBase
  | CheckpointStatement of duration:Literal option
  | CloseMasterKeyStatement 
  | CloseSymmetricKeyStatement of all:bool * name:Identifier option
  | ColumnEncryptionKeyStatement of columnEncryptionKeyStatement:ColumnEncryptionKeyStatement
  | ContinueStatement 
  | CreateAggregateStatement of assemblyName:AssemblyName option * name:SchemaObjectName option * parameters:(ProcedureParameter) list * returnType:DataTypeReference option
  | CreateAsymmetricKeyStatement of encryptionAlgorithm:ScriptDom.EncryptionAlgorithm * keySource:EncryptionSource option * name:Identifier option * owner:Identifier option * password:Literal option
  | CreateColumnMasterKeyStatement of name:Identifier option * parameters:(ColumnMasterKeyParameter) list
  | CreateColumnStoreIndexStatement of clustered:(bool) option * columns:(ColumnReferenceExpression) list * filterPredicate:BooleanExpression option * indexOptions:(IndexOption) list * name:Identifier option * onFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * onName:SchemaObjectName option
  | CreateContractStatement of messages:(ContractMessage) list * name:Identifier option * owner:Identifier option
  | CreateCryptographicProviderStatement of file:Literal option * name:Identifier option
  | CreateDatabaseStatement of attachMode:ScriptDom.AttachMode * collation:Identifier option * containment:ContainmentDatabaseOption option * copyOf:MultiPartIdentifier option * databaseName:Identifier option * databaseSnapshot:Identifier option * fileGroups:(FileGroupDefinition) list * logOn:(FileDeclaration) list * options:(DatabaseOption) list
  | CreateDefaultStatement of expression:ScalarExpression option * name:SchemaObjectName option
  | CreateEventNotificationStatement of brokerInstanceSpecifier:Literal option * brokerService:Literal option * eventTypeGroups:(EventTypeGroupContainer) list * name:Identifier option * scope:EventNotificationObjectScope option * withFanIn:bool
  | CreateFederationStatement of dataType:DataTypeReference option * distributionName:Identifier option * name:Identifier option
  | CreateFullTextIndexStatement of catalogAndFileGroup:FullTextCatalogAndFileGroup option * fullTextIndexColumns:(FullTextIndexColumn) list * keyIndexName:Identifier option * onName:SchemaObjectName option * options:(FullTextIndexOption) list
  | CreateFullTextStopListStatement of databaseName:Identifier option * isSystemStopList:bool * name:Identifier option * owner:Identifier option * sourceStopListName:Identifier option
  | CreateLoginStatement of name:Identifier option * source:CreateLoginSource option
  | CreatePartitionFunctionStatement of boundaryValues:(ScalarExpression) list * name:Identifier option * parameterType:PartitionParameterType option * range:ScriptDom.PartitionFunctionRange
  | CreatePartitionSchemeStatement of fileGroups:(IdentifierOrValueExpression) list * isAll:bool * name:Identifier option * partitionFunction:Identifier option
  | CreateRuleStatement of expression:BooleanExpression option * name:SchemaObjectName option
  | CreateSchemaStatement of name:Identifier option * owner:Identifier option * statementList:StatementList option
  | CreateSearchPropertyListStatement of name:Identifier option * owner:Identifier option * sourceSearchPropertyList:MultiPartIdentifier option
  | CreateSpatialIndexStatement of name:Identifier option * object:SchemaObjectName option * onFileGroup:IdentifierOrValueExpression option * spatialColumnName:Identifier option * spatialIndexOptions:(SpatialIndexOption) list * spatialIndexingScheme:ScriptDom.SpatialIndexingSchemeType
  | CreateStatisticsStatement of columns:(ColumnReferenceExpression) list * filterPredicate:BooleanExpression option * name:Identifier option * onName:SchemaObjectName option * statisticsOptions:(StatisticsOption) list
  | CreateSynonymStatement of forName:SchemaObjectName option * name:SchemaObjectName option
  | CreateTableStatement of asEdge:bool * asFileTable:bool * asNode:bool * definition:TableDefinition option * federationScheme:FederationScheme option * fileStreamOn:IdentifierOrValueExpression option * onFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * options:(TableOption) list * schemaObjectName:SchemaObjectName option * textImageOn:IdentifierOrValueExpression option
  | CreateTypeStatement of createTypeStatement:CreateTypeStatement
  | CreateXmlSchemaCollectionStatement of expression:ScalarExpression option * name:SchemaObjectName option
  | CredentialStatement of credentialStatement:CredentialStatement
  | CursorStatement of cursorStatement:CursorStatement
  | DatabaseEncryptionKeyStatement of databaseEncryptionKeyStatement:DatabaseEncryptionKeyStatement
  | DbccStatement of command:ScriptDom.DbccCommand * dllName:String * literals:(DbccNamedLiteral) list * options:(DbccOption) list * optionsUseJoin:bool * parenthesisRequired:bool
  | DeclareCursorStatement of cursorDefinition:CursorDefinition option * name:Identifier option
  | DeclareTableVariableStatement of body:DeclareTableVariableBody option
  | DeclareVariableStatement of declarations:(DeclareVariableElement) list
  | DiskStatement of diskStatementType:ScriptDom.DiskStatementType * options:(DiskStatementOption) list
  | DropChildObjectsStatement of dropChildObjectsStatement:DropChildObjectsStatement
  | DropDatabaseEncryptionKeyStatement 
  | DropDatabaseStatement of databases:(Identifier) list * isIfExists:bool
  | DropEventNotificationStatement of notifications:(Identifier) list * scope:EventNotificationObjectScope option
  | DropFullTextIndexStatement of tableName:SchemaObjectName option
  | DropIndexStatement of dropIndexClauses:(DropIndexClauseBase) list * isIfExists:bool
  | DropMasterKeyStatement 
  | DropObjectsStatement of dropObjectsStatement:DropObjectsStatement
  | DropQueueStatement of name:SchemaObjectName option
  | DropSchemaStatement of dropBehavior:ScriptDom.DropSchemaBehavior * isIfExists:bool * schema:SchemaObjectName option
  | DropTypeStatement of isIfExists:bool * name:SchemaObjectName option
  | DropUnownedObjectStatement of dropUnownedObjectStatement:DropUnownedObjectStatement
  | DropXmlSchemaCollectionStatement of name:SchemaObjectName option
  | EnableDisableTriggerStatement of all:bool * triggerEnforcement:ScriptDom.TriggerEnforcement * triggerNames:(SchemaObjectName) list * triggerObject:TriggerObject option
  | EndConversationStatement of conversation:ScalarExpression option * errorCode:ValueExpression option * errorDescription:ValueExpression option * withCleanup:bool
  | EventSessionStatement of eventSessionStatement:EventSessionStatement
  | ExecuteAsStatement of cookie:VariableReference option * executeContext:ExecuteContext option * withNoRevert:bool
  | ExecuteStatement of executeSpecification:ExecuteSpecification option * options:(ExecuteOption) list
  | ExternalDataSourceStatement of externalDataSourceStatement:ExternalDataSourceStatement
  | ExternalFileFormatStatement of externalFileFormatStatement:ExternalFileFormatStatement
  | ExternalResourcePoolStatement of externalResourcePoolStatement:ExternalResourcePoolStatement
  | ExternalTableStatement of externalTableStatement:ExternalTableStatement
  | FullTextCatalogStatement of fullTextCatalogStatement:FullTextCatalogStatement
  | GoToStatement of labelName:Identifier option
  | IfStatement of elseStatement:TSqlStatement option * predicate:BooleanExpression option * thenStatement:TSqlStatement option
  | IndexDefinition of columns:(ColumnWithSortOrder) list * fileStreamOn:IdentifierOrValueExpression option * filterPredicate:BooleanExpression option * indexOptions:(IndexOption) list * indexType:IndexType option * name:Identifier option * onFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * unique:bool
  | IndexStatement of indexStatement:IndexStatement
  | KillQueryNotificationSubscriptionStatement of all:bool * subscriptionId:Literal option
  | KillStatement of parameter:ScalarExpression option * withStatusOnly:bool
  | KillStatsJobStatement of jobId:ScalarExpression option
  | LabelStatement of value:String
  | LineNoStatement of lineNo:IntegerLiteral option
  | MasterKeyStatement of masterKeyStatement:MasterKeyStatement
  | MessageTypeStatementBase of messageTypeStatementBase:MessageTypeStatementBase
  | MoveConversationStatement of conversation:ScalarExpression option * group:ScalarExpression option
  | OpenMasterKeyStatement of password:Literal option
  | OpenSymmetricKeyStatement of decryptionMechanism:CryptoMechanism option * name:Identifier option
  | PrintStatement of expression:ScalarExpression option
  | ProcedureStatementBodyBase of procedureStatementBodyBase:ProcedureStatementBodyBase
  | QueueStatement of queueStatement:QueueStatement
  | RaiseErrorLegacyStatement of firstParameter:ScalarExpression option * secondParameter:ValueExpression option
  | RaiseErrorStatement of firstParameter:ScalarExpression option * optionalParameters:(ScalarExpression) list * raiseErrorOptions:ScriptDom.RaiseErrorOptions * secondParameter:ScalarExpression option * thirdParameter:ScalarExpression option
  | ReadTextStatement of column:ColumnReferenceExpression option * holdLock:bool * offset:ValueExpression option * size:ValueExpression option * textPointer:ValueExpression option
  | ReconfigureStatement of withOverride:bool
  | RemoteServiceBindingStatementBase of remoteServiceBindingStatementBase:RemoteServiceBindingStatementBase
  | ResourcePoolStatement of resourcePoolStatement:ResourcePoolStatement
  | RestoreStatement of databaseName:IdentifierOrValueExpression option * devices:(DeviceInfo) list * files:(BackupRestoreFileInfo) list * kind:ScriptDom.RestoreStatementKind * options:(RestoreOption) list
  | ReturnStatement of expression:ScalarExpression option
  | RevertStatement of cookie:ScalarExpression option
  | RoleStatement of roleStatement:RoleStatement
  | RouteStatement of routeStatement:RouteStatement
  | SecurityPolicyStatement of securityPolicyStatement:SecurityPolicyStatement
  | SecurityStatement of securityStatement:SecurityStatement
  | SecurityStatementBody80 of securityStatementBody80:SecurityStatementBody80
  | SendStatement of conversationHandles:(ScalarExpression) list * messageBody:ScalarExpression option * messageTypeName:IdentifierOrValueExpression option
  | SequenceStatement of sequenceStatement:SequenceStatement
  | ServerAuditStatement of serverAuditStatement:ServerAuditStatement
  | SetCommandStatement of commands:(SetCommand) list
  | SetErrorLevelStatement of level:ScalarExpression option
  | SetOnOffStatement of setOnOffStatement:SetOnOffStatement
  | SetRowCountStatement of numberRows:ValueExpression option
  | SetTextSizeStatement of textSize:ScalarExpression option
  | SetTransactionIsolationLevelStatement of level:ScriptDom.IsolationLevel
  | SetUserStatement of userName:ValueExpression option * withNoReset:bool
  | SetVariableStatement of assignmentKind:ScriptDom.AssignmentKind * cursorDefinition:CursorDefinition option * expression:ScalarExpression option * functionCallExists:bool * identifier:Identifier option * parameters:(ScalarExpression) list * separatorType:ScriptDom.SeparatorType * variable:VariableReference option
  | ShutdownStatement of withNoWait:bool
  | SignatureStatementBase of signatureStatementBase:SignatureStatementBase
  | StatementWithCtesAndXmlNamespaces of statementWithCtesAndXmlNamespaces:StatementWithCtesAndXmlNamespaces
  | SymmetricKeyStatement of symmetricKeyStatement:SymmetricKeyStatement
  | TSqlStatementSnippet of script:String
  | TextModificationStatement of textModificationStatement:TextModificationStatement
  | ThrowStatement of errorNumber:ValueExpression option * message:ValueExpression option * state:ValueExpression option
  | TransactionStatement of transactionStatement:TransactionStatement
  | TriggerStatementBody of triggerStatementBody:TriggerStatementBody
  | TruncateTableStatement of partitionRanges:(CompressionPartitionRange) list * tableName:SchemaObjectName option
  | TryCatchStatement of catchStatements:StatementList option * tryStatements:StatementList option
  | UpdateStatisticsStatement of schemaObjectName:SchemaObjectName option * statisticsOptions:(StatisticsOption) list * subElements:(Identifier) list
  | UseFederationStatement of distributionName:Identifier option * federationName:Identifier option * filtering:bool * value:ScalarExpression option
  | UseStatement of databaseName:Identifier option
  | UserStatement of userStatement:UserStatement
  | ViewStatementBody of viewStatementBody:ViewStatementBody
  | WaitForStatement of parameter:ValueExpression option * statement:WaitForSupportedStatement option * timeout:ScalarExpression option * waitForOption:ScriptDom.WaitForOption
  | WaitForSupportedStatement of waitForSupportedStatement:WaitForSupportedStatement
  | WhileStatement of predicate:BooleanExpression option * statement:TSqlStatement option
  | WorkloadGroupStatement of workloadGroupStatement:WorkloadGroupStatement
  member this.ToCs() : ScriptDom.TSqlStatement =
    match this with
    | AlterAsymmetricKeyStatement(attestedBy=aAttestedBy; decryptionPassword=aDecryptionPassword; encryptionPassword=aEncryptionPassword; kind=aKind; name=aName) ->
      let ret = ScriptDom.AlterAsymmetricKeyStatement()
      ret.AttestedBy <- aAttestedBy |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterAuthorizationStatement(principalName=aPrincipalName; securityTargetObject=aSecurityTargetObject; toSchemaOwner=aToSchemaOwner) ->
      let ret = ScriptDom.AlterAuthorizationStatement()
      ret.PrincipalName <- aPrincipalName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ToSchemaOwner <- aToSchemaOwner
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterCreateEndpointStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AlterCreateServiceStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AlterCryptographicProviderStatement(file=aFile; name=aName; option=aOption) ->
      let ret = ScriptDom.AlterCryptographicProviderStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Option <- aOption
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterDatabaseScopedConfigurationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AlterDatabaseStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AlterFederationStatement(boundary=aBoundary; distributionName=aDistributionName; kind=aKind; name=aName) ->
      let ret = ScriptDom.AlterFederationStatement()
      ret.Boundary <- aBoundary |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterFullTextIndexStatement(action=aAction; onName=aOnName) ->
      let ret = ScriptDom.AlterFullTextIndexStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterFullTextStopListStatement(action=aAction; name=aName) ->
      let ret = ScriptDom.AlterFullTextStopListStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterLoginStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AlterPartitionFunctionStatement(boundary=aBoundary; isSplit=aIsSplit; name=aName) ->
      let ret = ScriptDom.AlterPartitionFunctionStatement()
      ret.Boundary <- aBoundary |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsSplit <- aIsSplit
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterPartitionSchemeStatement(fileGroup=aFileGroup; name=aName) ->
      let ret = ScriptDom.AlterPartitionSchemeStatement()
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterResourceGovernorStatement(classifierFunction=aClassifierFunction; command=aCommand) ->
      let ret = ScriptDom.AlterResourceGovernorStatement()
      ret.ClassifierFunction <- aClassifierFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Command <- aCommand
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterSchemaStatement(name=aName; objectKind=aObjectKind; objectName=aObjectName) ->
      let ret = ScriptDom.AlterSchemaStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ObjectKind <- aObjectKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterSearchPropertyListStatement(action=aAction; name=aName) ->
      let ret = ScriptDom.AlterSearchPropertyListStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServerConfigurationSetBufferPoolExtensionStatement(options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetBufferPoolExtensionStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServerConfigurationSetDiagnosticsLogStatement(options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetDiagnosticsLogStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServerConfigurationSetFailoverClusterPropertyStatement(options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetFailoverClusterPropertyStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServerConfigurationSetHadrClusterStatement(options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetHadrClusterStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServerConfigurationSetSoftNumaStatement(options=aOptions) ->
      let ret = ScriptDom.AlterServerConfigurationSetSoftNumaStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServerConfigurationStatement(processAffinity=aProcessAffinity; processAffinityRanges=aProcessAffinityRanges) ->
      let ret = ScriptDom.AlterServerConfigurationStatement()
      ret.ProcessAffinity <- aProcessAffinity
      for e in aProcessAffinityRanges do ret.ProcessAffinityRanges.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterServiceMasterKeyStatement(account=aAccount; kind=aKind; password=aPassword) ->
      let ret = ScriptDom.AlterServiceMasterKeyStatement()
      ret.Account <- aAccount |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | AlterTableStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AlterXmlSchemaCollectionStatement(expression=aExpression; name=aName) ->
      let ret = ScriptDom.AlterXmlSchemaCollectionStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ApplicationRoleStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AssemblyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AuditSpecificationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | AvailabilityGroupStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | BackupRestoreMasterKeyStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | BackupStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | BeginConversationTimerStatement(handle=aHandle; timeout=aTimeout) ->
      let ret = ScriptDom.BeginConversationTimerStatement()
      ret.Handle <- aHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | BeginDialogStatement(contractName=aContractName; handle=aHandle; initiatorServiceName=aInitiatorServiceName; instanceSpec=aInstanceSpec; isConversation=aIsConversation; options=aOptions; targetServiceName=aTargetServiceName) ->
      let ret = ScriptDom.BeginDialogStatement()
      ret.ContractName <- aContractName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Handle <- aHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InitiatorServiceName <- aInitiatorServiceName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InstanceSpec <- aInstanceSpec |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsConversation <- aIsConversation
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.TargetServiceName <- aTargetServiceName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | BeginEndBlockStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | BreakStatement -> ScriptDom.BreakStatement() :> ScriptDom.TSqlStatement (* 396 *)
    | BrokerPriorityStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | BulkInsertBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | CertificateStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | CheckpointStatement(duration=aDuration) ->
      let ret = ScriptDom.CheckpointStatement()
      ret.Duration <- aDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CloseMasterKeyStatement -> ScriptDom.CloseMasterKeyStatement() :> ScriptDom.TSqlStatement (* 396 *)
    | CloseSymmetricKeyStatement(all=aAll; name=aName) ->
      let ret = ScriptDom.CloseSymmetricKeyStatement()
      ret.All <- aAll
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ColumnEncryptionKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ContinueStatement -> ScriptDom.ContinueStatement() :> ScriptDom.TSqlStatement (* 396 *)
    | CreateAggregateStatement(assemblyName=aAssemblyName; name=aName; parameters=aParameters; returnType=aReturnType) ->
      let ret = ScriptDom.CreateAggregateStatement()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateAsymmetricKeyStatement(encryptionAlgorithm=aEncryptionAlgorithm; keySource=aKeySource; name=aName; owner=aOwner; password=aPassword) ->
      let ret = ScriptDom.CreateAsymmetricKeyStatement()
      ret.EncryptionAlgorithm <- aEncryptionAlgorithm
      ret.KeySource <- aKeySource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateColumnMasterKeyStatement(name=aName; parameters=aParameters) ->
      let ret = ScriptDom.CreateColumnMasterKeyStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateColumnStoreIndexStatement(clustered=aClustered; columns=aColumns; filterPredicate=aFilterPredicate; indexOptions=aIndexOptions; name=aName; onFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; onName=aOnName) ->
      let ret = ScriptDom.CreateColumnStoreIndexStatement()
      ret.Clustered <- Option.toNullable aClustered
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateContractStatement(messages=aMessages; name=aName; owner=aOwner) ->
      let ret = ScriptDom.CreateContractStatement()
      for e in aMessages do ret.Messages.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateCryptographicProviderStatement(file=aFile; name=aName) ->
      let ret = ScriptDom.CreateCryptographicProviderStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateDatabaseStatement(attachMode=aAttachMode; collation=aCollation; containment=aContainment; copyOf=aCopyOf; databaseName=aDatabaseName; databaseSnapshot=aDatabaseSnapshot; fileGroups=aFileGroups; logOn=aLogOn; options=aOptions) ->
      let ret = ScriptDom.CreateDatabaseStatement()
      ret.AttachMode <- aAttachMode
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Containment <- aContainment |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CopyOf <- aCopyOf |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseSnapshot <- aDatabaseSnapshot |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aFileGroups do ret.FileGroups.Add (e.ToCs())
      for e in aLogOn do ret.LogOn.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateDefaultStatement(expression=aExpression; name=aName) ->
      let ret = ScriptDom.CreateDefaultStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateEventNotificationStatement(brokerInstanceSpecifier=aBrokerInstanceSpecifier; brokerService=aBrokerService; eventTypeGroups=aEventTypeGroups; name=aName; scope=aScope; withFanIn=aWithFanIn) ->
      let ret = ScriptDom.CreateEventNotificationStatement()
      ret.BrokerInstanceSpecifier <- aBrokerInstanceSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.BrokerService <- aBrokerService |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aEventTypeGroups do ret.EventTypeGroups.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Scope <- aScope |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithFanIn <- aWithFanIn
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateFederationStatement(dataType=aDataType; distributionName=aDistributionName; name=aName) ->
      let ret = ScriptDom.CreateFederationStatement()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateFullTextIndexStatement(catalogAndFileGroup=aCatalogAndFileGroup; fullTextIndexColumns=aFullTextIndexColumns; keyIndexName=aKeyIndexName; onName=aOnName; options=aOptions) ->
      let ret = ScriptDom.CreateFullTextIndexStatement()
      ret.CatalogAndFileGroup <- aCatalogAndFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aFullTextIndexColumns do ret.FullTextIndexColumns.Add (e.ToCs())
      ret.KeyIndexName <- aKeyIndexName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateFullTextStopListStatement(databaseName=aDatabaseName; isSystemStopList=aIsSystemStopList; name=aName; owner=aOwner; sourceStopListName=aSourceStopListName) ->
      let ret = ScriptDom.CreateFullTextStopListStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsSystemStopList <- aIsSystemStopList
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceStopListName <- aSourceStopListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateLoginStatement(name=aName; source=aSource) ->
      let ret = ScriptDom.CreateLoginStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Source <- aSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreatePartitionFunctionStatement(boundaryValues=aBoundaryValues; name=aName; parameterType=aParameterType; range=aRange) ->
      let ret = ScriptDom.CreatePartitionFunctionStatement()
      for e in aBoundaryValues do ret.BoundaryValues.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Range <- aRange
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreatePartitionSchemeStatement(fileGroups=aFileGroups; isAll=aIsAll; name=aName; partitionFunction=aPartitionFunction) ->
      let ret = ScriptDom.CreatePartitionSchemeStatement()
      for e in aFileGroups do ret.FileGroups.Add (e.ToCs())
      ret.IsAll <- aIsAll
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PartitionFunction <- aPartitionFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateRuleStatement(expression=aExpression; name=aName) ->
      let ret = ScriptDom.CreateRuleStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateSchemaStatement(name=aName; owner=aOwner; statementList=aStatementList) ->
      let ret = ScriptDom.CreateSchemaStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateSearchPropertyListStatement(name=aName; owner=aOwner; sourceSearchPropertyList=aSourceSearchPropertyList) ->
      let ret = ScriptDom.CreateSearchPropertyListStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceSearchPropertyList <- aSourceSearchPropertyList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateSpatialIndexStatement(name=aName; object=aObject; onFileGroup=aOnFileGroup; spatialColumnName=aSpatialColumnName; spatialIndexOptions=aSpatialIndexOptions; spatialIndexingScheme=aSpatialIndexingScheme) ->
      let ret = ScriptDom.CreateSpatialIndexStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroup <- aOnFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SpatialColumnName <- aSpatialColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSpatialIndexOptions do ret.SpatialIndexOptions.Add (e.ToCs())
      ret.SpatialIndexingScheme <- aSpatialIndexingScheme
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateStatisticsStatement(columns=aColumns; filterPredicate=aFilterPredicate; name=aName; onName=aOnName; statisticsOptions=aStatisticsOptions) ->
      let ret = ScriptDom.CreateStatisticsStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aStatisticsOptions do ret.StatisticsOptions.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateSynonymStatement(forName=aForName; name=aName) ->
      let ret = ScriptDom.CreateSynonymStatement()
      ret.ForName <- aForName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateTableStatement(asEdge=aAsEdge; asFileTable=aAsFileTable; asNode=aAsNode; definition=aDefinition; federationScheme=aFederationScheme; fileStreamOn=aFileStreamOn; onFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; options=aOptions; schemaObjectName=aSchemaObjectName; textImageOn=aTextImageOn) ->
      let ret = ScriptDom.CreateTableStatement()
      ret.AsEdge <- aAsEdge
      ret.AsFileTable <- aAsFileTable
      ret.AsNode <- aAsNode
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FederationScheme <- aFederationScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextImageOn <- aTextImageOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CreateTypeStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | CreateXmlSchemaCollectionStatement(expression=aExpression; name=aName) ->
      let ret = ScriptDom.CreateXmlSchemaCollectionStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | CredentialStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | CursorStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | DatabaseEncryptionKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | DbccStatement(command=aCommand; dllName=aDllName; literals=aLiterals; options=aOptions; optionsUseJoin=aOptionsUseJoin; parenthesisRequired=aParenthesisRequired) ->
      let ret = ScriptDom.DbccStatement()
      ret.Command <- aCommand
      ret.DllName <- aDllName
      for e in aLiterals do ret.Literals.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OptionsUseJoin <- aOptionsUseJoin
      ret.ParenthesisRequired <- aParenthesisRequired
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DeclareCursorStatement(cursorDefinition=aCursorDefinition; name=aName) ->
      let ret = ScriptDom.DeclareCursorStatement()
      ret.CursorDefinition <- aCursorDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DeclareTableVariableStatement(body=aBody) ->
      let ret = ScriptDom.DeclareTableVariableStatement()
      ret.Body <- aBody |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DeclareVariableStatement(declarations=aDeclarations) ->
      let ret = ScriptDom.DeclareVariableStatement()
      for e in aDeclarations do ret.Declarations.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DiskStatement(diskStatementType=aDiskStatementType; options=aOptions) ->
      let ret = ScriptDom.DiskStatement()
      ret.DiskStatementType <- aDiskStatementType
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropChildObjectsStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | DropDatabaseEncryptionKeyStatement -> ScriptDom.DropDatabaseEncryptionKeyStatement() :> ScriptDom.TSqlStatement (* 396 *)
    | DropDatabaseStatement(databases=aDatabases; isIfExists=aIsIfExists) ->
      let ret = ScriptDom.DropDatabaseStatement()
      for e in aDatabases do ret.Databases.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropEventNotificationStatement(notifications=aNotifications; scope=aScope) ->
      let ret = ScriptDom.DropEventNotificationStatement()
      for e in aNotifications do ret.Notifications.Add (e.ToCs())
      ret.Scope <- aScope |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropFullTextIndexStatement(tableName=aTableName) ->
      let ret = ScriptDom.DropFullTextIndexStatement()
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropIndexStatement(dropIndexClauses=aDropIndexClauses; isIfExists=aIsIfExists) ->
      let ret = ScriptDom.DropIndexStatement()
      for e in aDropIndexClauses do ret.DropIndexClauses.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropMasterKeyStatement -> ScriptDom.DropMasterKeyStatement() :> ScriptDom.TSqlStatement (* 396 *)
    | DropObjectsStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | DropQueueStatement(name=aName) ->
      let ret = ScriptDom.DropQueueStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropSchemaStatement(dropBehavior=aDropBehavior; isIfExists=aIsIfExists; schema=aSchema) ->
      let ret = ScriptDom.DropSchemaStatement()
      ret.DropBehavior <- aDropBehavior
      ret.IsIfExists <- aIsIfExists
      ret.Schema <- aSchema |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropTypeStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropTypeStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | DropUnownedObjectStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | DropXmlSchemaCollectionStatement(name=aName) ->
      let ret = ScriptDom.DropXmlSchemaCollectionStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | EnableDisableTriggerStatement(all=aAll; triggerEnforcement=aTriggerEnforcement; triggerNames=aTriggerNames; triggerObject=aTriggerObject) ->
      let ret = ScriptDom.EnableDisableTriggerStatement()
      ret.All <- aAll
      ret.TriggerEnforcement <- aTriggerEnforcement
      for e in aTriggerNames do ret.TriggerNames.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | EndConversationStatement(conversation=aConversation; errorCode=aErrorCode; errorDescription=aErrorDescription; withCleanup=aWithCleanup) ->
      let ret = ScriptDom.EndConversationStatement()
      ret.Conversation <- aConversation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ErrorCode <- aErrorCode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ErrorDescription <- aErrorDescription |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithCleanup <- aWithCleanup
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | EventSessionStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ExecuteAsStatement(cookie=aCookie; executeContext=aExecuteContext; withNoRevert=aWithNoRevert) ->
      let ret = ScriptDom.ExecuteAsStatement()
      ret.Cookie <- aCookie |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExecuteContext <- aExecuteContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoRevert <- aWithNoRevert
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ExecuteStatement(executeSpecification=aExecuteSpecification; options=aOptions) ->
      let ret = ScriptDom.ExecuteStatement()
      ret.ExecuteSpecification <- aExecuteSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ExternalDataSourceStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ExternalFileFormatStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ExternalResourcePoolStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ExternalTableStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | FullTextCatalogStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | GoToStatement(labelName=aLabelName) ->
      let ret = ScriptDom.GoToStatement()
      ret.LabelName <- aLabelName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | IfStatement(elseStatement=aElseStatement; predicate=aPredicate; thenStatement=aThenStatement) ->
      let ret = ScriptDom.IfStatement()
      ret.ElseStatement <- aElseStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Predicate <- aPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ThenStatement <- aThenStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | IndexDefinition(columns=aColumns; fileStreamOn=aFileStreamOn; filterPredicate=aFilterPredicate; indexOptions=aIndexOptions; indexType=aIndexType; name=aName; onFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; unique=aUnique) ->
      let ret = ScriptDom.IndexDefinition()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IndexType <- aIndexType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unique <- aUnique
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | IndexStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | KillQueryNotificationSubscriptionStatement(all=aAll; subscriptionId=aSubscriptionId) ->
      let ret = ScriptDom.KillQueryNotificationSubscriptionStatement()
      ret.All <- aAll
      ret.SubscriptionId <- aSubscriptionId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | KillStatement(parameter=aParameter; withStatusOnly=aWithStatusOnly) ->
      let ret = ScriptDom.KillStatement()
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithStatusOnly <- aWithStatusOnly
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | KillStatsJobStatement(jobId=aJobId) ->
      let ret = ScriptDom.KillStatsJobStatement()
      ret.JobId <- aJobId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | LabelStatement(value=aValue) ->
      let ret = ScriptDom.LabelStatement()
      ret.Value <- aValue
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | LineNoStatement(lineNo=aLineNo) ->
      let ret = ScriptDom.LineNoStatement()
      ret.LineNo <- aLineNo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | MasterKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | MessageTypeStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | MoveConversationStatement(conversation=aConversation; group=aGroup) ->
      let ret = ScriptDom.MoveConversationStatement()
      ret.Conversation <- aConversation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Group <- aGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | OpenMasterKeyStatement(password=aPassword) ->
      let ret = ScriptDom.OpenMasterKeyStatement()
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | OpenSymmetricKeyStatement(decryptionMechanism=aDecryptionMechanism; name=aName) ->
      let ret = ScriptDom.OpenSymmetricKeyStatement()
      ret.DecryptionMechanism <- aDecryptionMechanism |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | PrintStatement(expression=aExpression) ->
      let ret = ScriptDom.PrintStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ProcedureStatementBodyBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | QueueStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | RaiseErrorLegacyStatement(firstParameter=aFirstParameter; secondParameter=aSecondParameter) ->
      let ret = ScriptDom.RaiseErrorLegacyStatement()
      ret.FirstParameter <- aFirstParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondParameter <- aSecondParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | RaiseErrorStatement(firstParameter=aFirstParameter; optionalParameters=aOptionalParameters; raiseErrorOptions=aRaiseErrorOptions; secondParameter=aSecondParameter; thirdParameter=aThirdParameter) ->
      let ret = ScriptDom.RaiseErrorStatement()
      ret.FirstParameter <- aFirstParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptionalParameters do ret.OptionalParameters.Add (e.ToCs())
      ret.RaiseErrorOptions <- aRaiseErrorOptions
      ret.SecondParameter <- aSecondParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ThirdParameter <- aThirdParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ReadTextStatement(column=aColumn; holdLock=aHoldLock; offset=aOffset; size=aSize; textPointer=aTextPointer) ->
      let ret = ScriptDom.ReadTextStatement()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.HoldLock <- aHoldLock
      ret.Offset <- aOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Size <- aSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextPointer <- aTextPointer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ReconfigureStatement(withOverride=aWithOverride) ->
      let ret = ScriptDom.ReconfigureStatement()
      ret.WithOverride <- aWithOverride
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | RemoteServiceBindingStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ResourcePoolStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | RestoreStatement(databaseName=aDatabaseName; devices=aDevices; files=aFiles; kind=aKind; options=aOptions) ->
      let ret = ScriptDom.RestoreStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aDevices do ret.Devices.Add (e.ToCs())
      for e in aFiles do ret.Files.Add (e.ToCs())
      ret.Kind <- aKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ReturnStatement(expression=aExpression) ->
      let ret = ScriptDom.ReturnStatement()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | RevertStatement(cookie=aCookie) ->
      let ret = ScriptDom.RevertStatement()
      ret.Cookie <- aCookie |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | RoleStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | RouteStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SecurityPolicyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SecurityStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SecurityStatementBody80(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SendStatement(conversationHandles=aConversationHandles; messageBody=aMessageBody; messageTypeName=aMessageTypeName) ->
      let ret = ScriptDom.SendStatement()
      for e in aConversationHandles do ret.ConversationHandles.Add (e.ToCs())
      ret.MessageBody <- aMessageBody |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MessageTypeName <- aMessageTypeName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SequenceStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ServerAuditStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SetCommandStatement(commands=aCommands) ->
      let ret = ScriptDom.SetCommandStatement()
      for e in aCommands do ret.Commands.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SetErrorLevelStatement(level=aLevel) ->
      let ret = ScriptDom.SetErrorLevelStatement()
      ret.Level <- aLevel |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SetOnOffStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SetRowCountStatement(numberRows=aNumberRows) ->
      let ret = ScriptDom.SetRowCountStatement()
      ret.NumberRows <- aNumberRows |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SetTextSizeStatement(textSize=aTextSize) ->
      let ret = ScriptDom.SetTextSizeStatement()
      ret.TextSize <- aTextSize |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SetTransactionIsolationLevelStatement(level=aLevel) ->
      let ret = ScriptDom.SetTransactionIsolationLevelStatement()
      ret.Level <- aLevel
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SetUserStatement(userName=aUserName; withNoReset=aWithNoReset) ->
      let ret = ScriptDom.SetUserStatement()
      ret.UserName <- aUserName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithNoReset <- aWithNoReset
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SetVariableStatement(assignmentKind=aAssignmentKind; cursorDefinition=aCursorDefinition; expression=aExpression; functionCallExists=aFunctionCallExists; identifier=aIdentifier; parameters=aParameters; separatorType=aSeparatorType; variable=aVariable) ->
      let ret = ScriptDom.SetVariableStatement()
      ret.AssignmentKind <- aAssignmentKind
      ret.CursorDefinition <- aCursorDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionCallExists <- aFunctionCallExists
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.SeparatorType <- aSeparatorType
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | ShutdownStatement(withNoWait=aWithNoWait) ->
      let ret = ScriptDom.ShutdownStatement()
      ret.WithNoWait <- aWithNoWait
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | SignatureStatementBase(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | StatementWithCtesAndXmlNamespaces(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | SymmetricKeyStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | TSqlStatementSnippet(script=aScript) ->
      let ret = ScriptDom.TSqlStatementSnippet()
      ret.Script <- aScript
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | TextModificationStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ThrowStatement(errorNumber=aErrorNumber; message=aMessage; state=aState) ->
      let ret = ScriptDom.ThrowStatement()
      ret.ErrorNumber <- aErrorNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Message <- aMessage |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.State <- aState |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | TransactionStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | TriggerStatementBody(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | TruncateTableStatement(partitionRanges=aPartitionRanges; tableName=aTableName) ->
      let ret = ScriptDom.TruncateTableStatement()
      for e in aPartitionRanges do ret.PartitionRanges.Add (e.ToCs())
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | TryCatchStatement(catchStatements=aCatchStatements; tryStatements=aTryStatements) ->
      let ret = ScriptDom.TryCatchStatement()
      ret.CatchStatements <- aCatchStatements |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TryStatements <- aTryStatements |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | UpdateStatisticsStatement(schemaObjectName=aSchemaObjectName; statisticsOptions=aStatisticsOptions; subElements=aSubElements) ->
      let ret = ScriptDom.UpdateStatisticsStatement()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aStatisticsOptions do ret.StatisticsOptions.Add (e.ToCs())
      for e in aSubElements do ret.SubElements.Add (e.ToCs())
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | UseFederationStatement(distributionName=aDistributionName; federationName=aFederationName; filtering=aFiltering; value=aValue) ->
      let ret = ScriptDom.UseFederationStatement()
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FederationName <- aFederationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Filtering <- aFiltering
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | UseStatement(databaseName=aDatabaseName) ->
      let ret = ScriptDom.UseStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | UserStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | ViewStatementBody(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | WaitForStatement(parameter=aParameter; statement=aStatement; timeout=aTimeout; waitForOption=aWaitForOption) ->
      let ret = ScriptDom.WaitForStatement()
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Statement <- aStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timeout <- aTimeout |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WaitForOption <- aWaitForOption
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | WaitForSupportedStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
    | WhileStatement(predicate=aPredicate; statement=aStatement) ->
      let ret = ScriptDom.WhileStatement()
      ret.Predicate <- aPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Statement <- aStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TSqlStatement (* 404 *)
    | WorkloadGroupStatement(x) -> x.ToCs() :> ScriptDom.TSqlStatement (* 414 *)
  static member FromCs(src:ScriptDom.TSqlStatement) : TSqlStatement =
    match src with
    | :? ScriptDom.AlterAsymmetricKeyStatement as src ->
      TSqlStatement.AlterAsymmetricKeyStatement((src.AttestedBy |> Option.ofObj |> Option.map (Literal.FromCs)), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterAuthorizationStatement as src ->
      TSqlStatement.AlterAuthorizationStatement((src.PrincipalName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)), (src.ToSchemaOwner))
    | :? ScriptDom.AlterCreateEndpointStatementBase as src ->
      match src with
      | :? ScriptDom.AlterEndpointStatement as src->
        TSqlStatement.AlterCreateEndpointStatementBase((AlterCreateEndpointStatementBase.AlterEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (EndpointAffinity.FromCs)), (src.EndpointType), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PayloadOptions |> Seq.map (PayloadOption.FromCs) |> List.ofSeq), (src.Protocol), (src.ProtocolOptions |> Seq.map (EndpointProtocolOption.FromCs) |> List.ofSeq), (src.State))))
      | :? ScriptDom.CreateEndpointStatement as src->
        TSqlStatement.AlterCreateEndpointStatementBase((AlterCreateEndpointStatementBase.CreateEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (EndpointAffinity.FromCs)), (src.EndpointType), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PayloadOptions |> Seq.map (PayloadOption.FromCs) |> List.ofSeq), (src.Protocol), (src.ProtocolOptions |> Seq.map (EndpointProtocolOption.FromCs) |> List.ofSeq), (src.State))))
    | :? ScriptDom.AlterCreateServiceStatementBase as src ->
      match src with
      | :? ScriptDom.AlterServiceStatement as src->
        TSqlStatement.AlterCreateServiceStatementBase((AlterCreateServiceStatementBase.AlterServiceStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueueName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.CreateServiceStatement as src->
        TSqlStatement.AlterCreateServiceStatementBase((AlterCreateServiceStatementBase.CreateServiceStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueueName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq))))
    | :? ScriptDom.AlterCryptographicProviderStatement as src ->
      TSqlStatement.AlterCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Option))
    | :? ScriptDom.AlterDatabaseScopedConfigurationStatement as src ->
      match src with
      | :? ScriptDom.AlterDatabaseScopedConfigurationClearStatement as src->
        TSqlStatement.AlterDatabaseScopedConfigurationStatement((AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationClearStatement((src.Option |> Option.ofObj |> Option.map (DatabaseConfigurationClearOption.FromCs)), (src.Secondary))))
      | :? ScriptDom.AlterDatabaseScopedConfigurationSetStatement as src->
        TSqlStatement.AlterDatabaseScopedConfigurationStatement((AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationSetStatement((src.Option |> Option.ofObj |> Option.map (DatabaseConfigurationSetOption.FromCs)), (src.Secondary))))
    | :? ScriptDom.AlterDatabaseStatement as src ->
      match src with
      | :? ScriptDom.AlterDatabaseAddFileGroupStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseAddFileGroupStatement((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseAddFileStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseAddFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLog), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseCollateStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseCollateStatement((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseModifyFileGroupStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseModifyFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.MakeDefault), (src.NewFileGroupName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Termination |> Option.ofObj |> Option.map (AlterDatabaseTermination.FromCs)), (src.UpdatabilityOption), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseModifyFileStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseModifyFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileDeclaration |> Option.ofObj |> Option.map (FileDeclaration.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseModifyNameStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseModifyNameStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.NewDatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseRebuildLogStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseRebuildLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileDeclaration |> Option.ofObj |> Option.map (FileDeclaration.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseRemoveFileGroupStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseRemoveFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseRemoveFileStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseRemoveFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.File |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))))
      | :? ScriptDom.AlterDatabaseSetStatement as src->
        TSqlStatement.AlterDatabaseStatement((AlterDatabaseStatement.AlterDatabaseSetStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (DatabaseOption.FromCs) |> List.ofSeq), (src.Termination |> Option.ofObj |> Option.map (AlterDatabaseTermination.FromCs)), (src.UseCurrent))))
    | :? ScriptDom.AlterFederationStatement as src ->
      TSqlStatement.AlterFederationStatement((src.Boundary |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterFullTextIndexStatement as src ->
      TSqlStatement.AlterFullTextIndexStatement((src.Action |> Option.ofObj |> Option.map (AlterFullTextIndexAction.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterFullTextStopListStatement as src ->
      TSqlStatement.AlterFullTextStopListStatement((src.Action |> Option.ofObj |> Option.map (FullTextStopListAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterLoginStatement as src ->
      match src with
      | :? ScriptDom.AlterLoginAddDropCredentialStatement as src->
        TSqlStatement.AlterLoginStatement((AlterLoginStatement.AlterLoginAddDropCredentialStatement((src.CredentialName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsAdd), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterLoginEnableDisableStatement as src->
        TSqlStatement.AlterLoginStatement((AlterLoginStatement.AlterLoginEnableDisableStatement((src.IsEnable), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterLoginOptionsStatement as src->
        TSqlStatement.AlterLoginStatement((AlterLoginStatement.AlterLoginOptionsStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.AlterPartitionFunctionStatement as src ->
      TSqlStatement.AlterPartitionFunctionStatement((src.Boundary |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsSplit), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterPartitionSchemeStatement as src ->
      TSqlStatement.AlterPartitionSchemeStatement((src.FileGroup |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterResourceGovernorStatement as src ->
      TSqlStatement.AlterResourceGovernorStatement((src.ClassifierFunction |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Command))
    | :? ScriptDom.AlterSchemaStatement as src ->
      TSqlStatement.AlterSchemaStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ObjectKind), (src.ObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterSearchPropertyListStatement as src ->
      TSqlStatement.AlterSearchPropertyListStatement((src.Action |> Option.ofObj |> Option.map (SearchPropertyListAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterServerConfigurationSetBufferPoolExtensionStatement as src ->
      TSqlStatement.AlterServerConfigurationSetBufferPoolExtensionStatement((src.Options |> Seq.map (AlterServerConfigurationBufferPoolExtensionOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.AlterServerConfigurationSetDiagnosticsLogStatement as src ->
      TSqlStatement.AlterServerConfigurationSetDiagnosticsLogStatement((src.Options |> Seq.map (AlterServerConfigurationDiagnosticsLogOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.AlterServerConfigurationSetFailoverClusterPropertyStatement as src ->
      TSqlStatement.AlterServerConfigurationSetFailoverClusterPropertyStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.AlterServerConfigurationSetHadrClusterStatement as src ->
      TSqlStatement.AlterServerConfigurationSetHadrClusterStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.AlterServerConfigurationSetSoftNumaStatement as src ->
      TSqlStatement.AlterServerConfigurationSetSoftNumaStatement((src.Options |> Seq.map (fun src -> AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.AlterServerConfigurationStatement as src ->
      TSqlStatement.AlterServerConfigurationStatement((src.ProcessAffinity), (src.ProcessAffinityRanges |> Seq.map (fun src -> ProcessAffinityRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.AlterServiceMasterKeyStatement as src ->
      TSqlStatement.AlterServiceMasterKeyStatement((src.Account |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Kind), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.AlterTableStatement as src ->
      match src with
      | :? ScriptDom.AlterTableAddTableElementStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAddTableElementStatement((src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.ExistingRowsCheckEnforcement), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableAlterColumnStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAlterColumnStatement((src.AlterTableAlterColumnOption), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IsHidden), (src.IsMasked), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Options |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))))
      | :? ScriptDom.AlterTableAlterIndexStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAlterIndexStatement((src.AlterIndexType), (src.IndexIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableAlterPartitionStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableAlterPartitionStatement((src.BoundaryValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsSplit), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableChangeTrackingModificationStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableChangeTrackingModificationStatement((src.IsEnable), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TrackColumnsUpdated))))
      | :? ScriptDom.AlterTableConstraintModificationStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableConstraintModificationStatement((src.All), (src.ConstraintEnforcement), (src.ConstraintNames |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ExistingRowsCheckEnforcement), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableDropTableElementStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableDropTableElementStatement((src.AlterTableDropTableElements |> Seq.map (fun src -> AlterTableDropTableElement.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (DropClusteredConstraintOption.FromCs) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableElementType))) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableFileTableNamespaceStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableFileTableNamespaceStatement((src.IsEnable), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableRebuildStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableRebuildStatement((src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Partition |> Option.ofObj |> Option.map (PartitionSpecifier.FromCs)), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableSetStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableSetStatement((src.Options |> Seq.map (TableOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableSwitchStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableSwitchStatement((src.Options |> Seq.map (TableSwitchOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SourcePartitionNumber |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TargetPartitionNumber |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TargetTable |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.AlterTableTriggerModificationStatement as src->
        TSqlStatement.AlterTableStatement((AlterTableStatement.AlterTableTriggerModificationStatement((src.All), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TriggerEnforcement), (src.TriggerNames |> Seq.map (Identifier.FromCs) |> List.ofSeq))))
    | :? ScriptDom.AlterXmlSchemaCollectionStatement as src ->
      TSqlStatement.AlterXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.ApplicationRoleStatement as src ->
      match src with
      | :? ScriptDom.AlterApplicationRoleStatement as src->
        TSqlStatement.ApplicationRoleStatement((ApplicationRoleStatement.AlterApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateApplicationRoleStatement as src->
        TSqlStatement.ApplicationRoleStatement((ApplicationRoleStatement.CreateApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.AssemblyStatement as src ->
      match src with
      | :? ScriptDom.AlterAssemblyStatement as src->
        TSqlStatement.AssemblyStatement((AssemblyStatement.AlterAssemblyStatement((src.AddFiles |> Seq.map (fun src -> AddFileSpec.AddFileSpec((src.File |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FileName |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.DropFiles |> Seq.map (Literal.FromCs) |> List.ofSeq), (src.IsDropAll), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AssemblyOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateAssemblyStatement as src->
        TSqlStatement.AssemblyStatement((AssemblyStatement.CreateAssemblyStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AssemblyOption.FromCs) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
    | :? ScriptDom.AuditSpecificationStatement as src ->
      match src with
      | :? ScriptDom.AlterDatabaseAuditSpecificationStatement as src->
        TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.AlterDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.AlterServerAuditSpecificationStatement as src->
        TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.AlterServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateDatabaseAuditSpecificationStatement as src->
        TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.CreateDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateServerAuditSpecificationStatement as src->
        TSqlStatement.AuditSpecificationStatement((AuditSpecificationStatement.CreateServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.AvailabilityGroupStatement as src ->
      match src with
      | :? ScriptDom.AlterAvailabilityGroupStatement as src->
        TSqlStatement.AvailabilityGroupStatement((AvailabilityGroupStatement.AlterAvailabilityGroupStatement((src.Action |> Option.ofObj |> Option.map (AlterAvailabilityGroupAction.FromCs)), (src.AlterAvailabilityGroupStatementType), (src.Databases |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AvailabilityGroupOption.FromCs) |> List.ofSeq), (src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (AvailabilityReplicaOption.FromCs) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.CreateAvailabilityGroupStatement as src->
        TSqlStatement.AvailabilityGroupStatement((AvailabilityGroupStatement.CreateAvailabilityGroupStatement((src.Databases |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AvailabilityGroupOption.FromCs) |> List.ofSeq), (src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (AvailabilityReplicaOption.FromCs) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))) |> List.ofSeq))))
    | :? ScriptDom.BackupRestoreMasterKeyStatementBase as src ->
      match src with
      | :? ScriptDom.BackupMasterKeyStatement as src->
        TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.BackupMasterKeyStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.BackupServiceMasterKeyStatement as src->
        TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.BackupServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.RestoreMasterKeyStatement as src->
        TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.RestoreMasterKeyStatement((src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsForce), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.RestoreServiceMasterKeyStatement as src->
        TSqlStatement.BackupRestoreMasterKeyStatementBase((BackupRestoreMasterKeyStatementBase.RestoreServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsForce), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.BackupStatement as src ->
      match src with
      | :? ScriptDom.BackupDatabaseStatement as src->
        TSqlStatement.BackupStatement((BackupStatement.BackupDatabaseStatement((src.DatabaseName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (BackupOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.BackupTransactionLogStatement as src->
        TSqlStatement.BackupStatement((BackupStatement.BackupTransactionLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (BackupOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.BeginConversationTimerStatement as src ->
      TSqlStatement.BeginConversationTimerStatement((src.Handle |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Timeout |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.BeginDialogStatement as src ->
      TSqlStatement.BeginDialogStatement((src.ContractName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Handle |> Option.ofObj |> Option.map (VariableReference.FromCs)), (src.InitiatorServiceName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.InstanceSpec |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.IsConversation), (src.Options |> Seq.map (DialogOption.FromCs) |> List.ofSeq), (src.TargetServiceName |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.BeginEndBlockStatement as src ->
      match src with
      | :? ScriptDom.BeginEndAtomicBlockStatement as src->
        TSqlStatement.BeginEndBlockStatement((BeginEndBlockStatement.BeginEndAtomicBlockStatement((src.Options |> Seq.map (AtomicBlockOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | _ -> (* :? ScriptDom.BeginEndBlockStatement as src *)
        TSqlStatement.BeginEndBlockStatement((BeginEndBlockStatement.Base((src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
    | :? ScriptDom.BreakStatement as src ->
      TSqlStatement.BreakStatement
    | :? ScriptDom.BrokerPriorityStatement as src ->
      match src with
      | :? ScriptDom.AlterBrokerPriorityStatement as src->
        TSqlStatement.BrokerPriorityStatement((BrokerPriorityStatement.AlterBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateBrokerPriorityStatement as src->
        TSqlStatement.BrokerPriorityStatement((BrokerPriorityStatement.CreateBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.BulkInsertBase as src ->
      match src with
      | :? ScriptDom.BulkInsertStatement as src->
        TSqlStatement.BulkInsertBase((BulkInsertBase.BulkInsertStatement((src.From |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Options |> Seq.map (BulkInsertOption.FromCs) |> List.ofSeq), (src.To |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.InsertBulkStatement as src->
        TSqlStatement.BulkInsertBase((BulkInsertBase.InsertBulkStatement((src.ColumnDefinitions |> Seq.map (fun src -> InsertBulkColumnDefinition.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullNotNull))) |> List.ofSeq), (src.Options |> Seq.map (BulkInsertOption.FromCs) |> List.ofSeq), (src.To |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.CertificateStatementBase as src ->
      match src with
      | :? ScriptDom.AlterCertificateStatement as src->
        TSqlStatement.CertificateStatementBase((CertificateStatementBase.AlterCertificateStatement((src.ActiveForBeginDialog), (src.AttestedBy |> Option.ofObj |> Option.map (Literal.FromCs)), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrivateKeyPath |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.BackupCertificateStatement as src->
        TSqlStatement.CertificateStatementBase((CertificateStatementBase.BackupCertificateStatement((src.ActiveForBeginDialog), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrivateKeyPath |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.CreateCertificateStatement as src->
        TSqlStatement.CertificateStatementBase((CertificateStatementBase.CreateCertificateStatement((src.ActiveForBeginDialog), (src.CertificateOptions |> Seq.map (fun src -> CertificateOption.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.CertificateSource |> Option.ofObj |> Option.map (EncryptionSource.FromCs)), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrivateKeyPath |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.CheckpointStatement as src ->
      TSqlStatement.CheckpointStatement((src.Duration |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.CloseMasterKeyStatement as src ->
      TSqlStatement.CloseMasterKeyStatement
    | :? ScriptDom.CloseSymmetricKeyStatement as src ->
      TSqlStatement.CloseSymmetricKeyStatement((src.All), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.ColumnEncryptionKeyStatement as src ->
      match src with
      | :? ScriptDom.AlterColumnEncryptionKeyStatement as src->
        TSqlStatement.ColumnEncryptionKeyStatement((ColumnEncryptionKeyStatement.AlterColumnEncryptionKeyStatement((src.AlterType), (src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (ColumnEncryptionKeyValueParameter.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateColumnEncryptionKeyStatement as src->
        TSqlStatement.ColumnEncryptionKeyStatement((ColumnEncryptionKeyStatement.CreateColumnEncryptionKeyStatement((src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (ColumnEncryptionKeyValueParameter.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.ContinueStatement as src ->
      TSqlStatement.ContinueStatement
    | :? ScriptDom.CreateAggregateStatement as src ->
      TSqlStatement.CreateAggregateStatement((src.AssemblyName |> Option.ofObj |> Option.map (AssemblyName.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))
    | :? ScriptDom.CreateAsymmetricKeyStatement as src ->
      TSqlStatement.CreateAsymmetricKeyStatement((src.EncryptionAlgorithm), (src.KeySource |> Option.ofObj |> Option.map (EncryptionSource.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.CreateColumnMasterKeyStatement as src ->
      TSqlStatement.CreateColumnMasterKeyStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ColumnMasterKeyParameter.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateColumnStoreIndexStatement as src ->
      TSqlStatement.CreateColumnStoreIndexStatement((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.CreateContractStatement as src ->
      TSqlStatement.CreateContractStatement((src.Messages |> Seq.map (fun src -> ContractMessage.ContractMessage((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SentBy))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateCryptographicProviderStatement as src ->
      TSqlStatement.CreateCryptographicProviderStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateDatabaseStatement as src ->
      TSqlStatement.CreateDatabaseStatement((src.AttachMode), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Containment |> Option.ofObj |> Option.map (ContainmentDatabaseOption.FromCs)), (src.CopyOf |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DatabaseSnapshot |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroups |> Seq.map (fun src -> FileGroupDefinition.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.LogOn |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (DatabaseOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateDefaultStatement as src ->
      TSqlStatement.CreateDefaultStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.CreateEventNotificationStatement as src ->
      TSqlStatement.CreateEventNotificationStatement((src.BrokerInstanceSpecifier |> Option.ofObj |> Option.map (Literal.FromCs)), (src.BrokerService |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EventTypeGroups |> Seq.map (EventTypeGroupContainer.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Scope |> Option.ofObj |> Option.map (EventNotificationObjectScope.FromCs)), (src.WithFanIn))
    | :? ScriptDom.CreateFederationStatement as src ->
      TSqlStatement.CreateFederationStatement((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateFullTextIndexStatement as src ->
      TSqlStatement.CreateFullTextIndexStatement((src.CatalogAndFileGroup |> Option.ofObj |> Option.map (FullTextCatalogAndFileGroup.FromCs)), (src.FullTextIndexColumns |> Seq.map (fun src -> FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.KeyIndexName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FullTextIndexOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateFullTextStopListStatement as src ->
      TSqlStatement.CreateFullTextStopListStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsSystemStopList), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SourceStopListName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateLoginStatement as src ->
      TSqlStatement.CreateLoginStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Source |> Option.ofObj |> Option.map (CreateLoginSource.FromCs)))
    | :? ScriptDom.CreatePartitionFunctionStatement as src ->
      TSqlStatement.CreatePartitionFunctionStatement((src.BoundaryValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterType |> Option.ofObj |> Option.map (PartitionParameterType.FromCs)), (src.Range))
    | :? ScriptDom.CreatePartitionSchemeStatement as src ->
      TSqlStatement.CreatePartitionSchemeStatement((src.FileGroups |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Value), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.IsAll), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PartitionFunction |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateRuleStatement as src ->
      TSqlStatement.CreateRuleStatement((src.Expression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.CreateSchemaStatement as src ->
      TSqlStatement.CreateSchemaStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | :? ScriptDom.CreateSearchPropertyListStatement as src ->
      TSqlStatement.CreateSearchPropertyListStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SourceSearchPropertyList |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
    | :? ScriptDom.CreateSpatialIndexStatement as src ->
      TSqlStatement.CreateSpatialIndexStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.OnFileGroup |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.SpatialColumnName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SpatialIndexOptions |> Seq.map (SpatialIndexOption.FromCs) |> List.ofSeq), (src.SpatialIndexingScheme))
    | :? ScriptDom.CreateStatisticsStatement as src ->
      TSqlStatement.CreateStatisticsStatement((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.StatisticsOptions |> Seq.map (StatisticsOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateSynonymStatement as src ->
      TSqlStatement.CreateSynonymStatement((src.ForName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.CreateTableStatement as src ->
      TSqlStatement.CreateTableStatement((src.AsEdge), (src.AsFileTable), (src.AsNode), (src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.FederationScheme |> Option.ofObj |> Option.map (FederationScheme.FromCs)), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Options |> Seq.map (TableOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TextImageOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.CreateTypeStatement as src ->
      match src with
      | :? ScriptDom.CreateTypeTableStatement as src->
        TSqlStatement.CreateTypeStatement((CreateTypeStatement.CreateTypeTableStatement((src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TableOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateTypeUddtStatement as src->
        TSqlStatement.CreateTypeStatement((CreateTypeStatement.CreateTypeUddtStatement((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.NullableConstraint |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))))
      | :? ScriptDom.CreateTypeUdtStatement as src->
        TSqlStatement.CreateTypeStatement((CreateTypeStatement.CreateTypeUdtStatement((src.AssemblyName |> Option.ofObj |> Option.map (AssemblyName.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.CreateXmlSchemaCollectionStatement as src ->
      TSqlStatement.CreateXmlSchemaCollectionStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.CredentialStatement as src ->
      match src with
      | :? ScriptDom.AlterCredentialStatement as src->
        TSqlStatement.CredentialStatement((CredentialStatement.AlterCredentialStatement((src.Identity |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsDatabaseScoped), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Secret |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.CreateCredentialStatement as src->
        TSqlStatement.CredentialStatement((CredentialStatement.CreateCredentialStatement((src.CryptographicProviderName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identity |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsDatabaseScoped), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Secret |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.CursorStatement as src ->
      match src with
      | :? ScriptDom.CloseCursorStatement as src->
        TSqlStatement.CursorStatement((CursorStatement.CloseCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)))))
      | :? ScriptDom.DeallocateCursorStatement as src->
        TSqlStatement.CursorStatement((CursorStatement.DeallocateCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)))))
      | :? ScriptDom.FetchCursorStatement as src->
        TSqlStatement.CursorStatement((CursorStatement.FetchCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)), (src.FetchType |> Option.ofObj |> Option.map (FetchType.FromCs)), (src.IntoVariables |> Seq.map (fun src -> VariableReference.VariableReference((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))) |> List.ofSeq))))
      | :? ScriptDom.OpenCursorStatement as src->
        TSqlStatement.CursorStatement((CursorStatement.OpenCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)))))
    | :? ScriptDom.DatabaseEncryptionKeyStatement as src ->
      match src with
      | :? ScriptDom.AlterDatabaseEncryptionKeyStatement as src->
        TSqlStatement.DatabaseEncryptionKeyStatement((DatabaseEncryptionKeyStatement.AlterDatabaseEncryptionKeyStatement((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)), (src.Regenerate))))
      | :? ScriptDom.CreateDatabaseEncryptionKeyStatement as src->
        TSqlStatement.DatabaseEncryptionKeyStatement((DatabaseEncryptionKeyStatement.CreateDatabaseEncryptionKeyStatement((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)))))
    | :? ScriptDom.DbccStatement as src ->
      TSqlStatement.DbccStatement((src.Command), (src.DllName), (src.Literals |> Seq.map (fun src -> DbccNamedLiteral.DbccNamedLiteral((src.Name), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.Options |> Seq.map (fun src -> DbccOption.DbccOption((src.OptionKind))) |> List.ofSeq), (src.OptionsUseJoin), (src.ParenthesisRequired))
    | :? ScriptDom.DeclareCursorStatement as src ->
      TSqlStatement.DeclareCursorStatement((src.CursorDefinition |> Option.ofObj |> Option.map (CursorDefinition.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DeclareTableVariableStatement as src ->
      TSqlStatement.DeclareTableVariableStatement((src.Body |> Option.ofObj |> Option.map (DeclareTableVariableBody.FromCs)))
    | :? ScriptDom.DeclareVariableStatement as src ->
      TSqlStatement.DeclareVariableStatement((src.Declarations |> Seq.map (DeclareVariableElement.FromCs) |> List.ofSeq))
    | :? ScriptDom.DiskStatement as src ->
      TSqlStatement.DiskStatement((src.DiskStatementType), (src.Options |> Seq.map (fun src -> DiskStatementOption.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.DropChildObjectsStatement as src ->
      match src with
      | :? ScriptDom.DropStatisticsStatement as src->
        TSqlStatement.DropChildObjectsStatement((DropChildObjectsStatement.DropStatisticsStatement((src.Objects |> Seq.map (fun src -> ChildObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ChildIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq))))
    | :? ScriptDom.DropDatabaseEncryptionKeyStatement as src ->
      TSqlStatement.DropDatabaseEncryptionKeyStatement
    | :? ScriptDom.DropDatabaseStatement as src ->
      TSqlStatement.DropDatabaseStatement((src.Databases |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.IsIfExists))
    | :? ScriptDom.DropEventNotificationStatement as src ->
      TSqlStatement.DropEventNotificationStatement((src.Notifications |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Scope |> Option.ofObj |> Option.map (EventNotificationObjectScope.FromCs)))
    | :? ScriptDom.DropFullTextIndexStatement as src ->
      TSqlStatement.DropFullTextIndexStatement((src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.DropIndexStatement as src ->
      TSqlStatement.DropIndexStatement((src.DropIndexClauses |> Seq.map (DropIndexClauseBase.FromCs) |> List.ofSeq), (src.IsIfExists))
    | :? ScriptDom.DropMasterKeyStatement as src ->
      TSqlStatement.DropMasterKeyStatement
    | :? ScriptDom.DropObjectsStatement as src ->
      match src with
      | :? ScriptDom.DropAggregateStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropAggregateStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropAssemblyStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropAssemblyStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq), (src.WithNoDependents))))
      | :? ScriptDom.DropDefaultStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropDefaultStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropExternalTableStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropExternalTableStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropFunctionStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropFunctionStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropProcedureStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropProcedureStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropRuleStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropRuleStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropSecurityPolicyStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropSecurityPolicyStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropSequenceStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropSequenceStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropSynonymStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropSynonymStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropTableStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropTableStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
      | :? ScriptDom.DropTriggerStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropTriggerStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq), (src.TriggerScope))))
      | :? ScriptDom.DropViewStatement as src->
        TSqlStatement.DropObjectsStatement((DropObjectsStatement.DropViewStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))))
    | :? ScriptDom.DropQueueStatement as src ->
      TSqlStatement.DropQueueStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.DropSchemaStatement as src ->
      TSqlStatement.DropSchemaStatement((src.DropBehavior), (src.IsIfExists), (src.Schema |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.DropTypeStatement as src ->
      TSqlStatement.DropTypeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.DropUnownedObjectStatement as src ->
      match src with
      | :? ScriptDom.DropApplicationRoleStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropApplicationRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropAsymmetricKeyStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropAsymmetricKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RemoveProviderKey))))
      | :? ScriptDom.DropAvailabilityGroupStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropAvailabilityGroupStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropBrokerPriorityStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropBrokerPriorityStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropCertificateStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropCertificateStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropColumnEncryptionKeyStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropColumnEncryptionKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropColumnMasterKeyStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropColumnMasterKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropContractStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropContractStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropCredentialStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropCredentialStatement((src.IsDatabaseScoped), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropCryptographicProviderStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropCryptographicProviderStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropDatabaseAuditSpecificationStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropDatabaseAuditSpecificationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropEndpointStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropEndpointStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropEventSessionStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropEventSessionStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionScope))))
      | :? ScriptDom.DropExternalDataSourceStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropExternalDataSourceStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropExternalFileFormatStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropExternalFileFormatStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropExternalResourcePoolStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropExternalResourcePoolStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropFederationStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropFederationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropFullTextCatalogStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropFullTextCatalogStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropFullTextStopListStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropFullTextStopListStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropLoginStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropLoginStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropMessageTypeStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropMessageTypeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropPartitionFunctionStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropPartitionFunctionStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropPartitionSchemeStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropPartitionSchemeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropRemoteServiceBindingStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropRemoteServiceBindingStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropResourcePoolStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropResourcePoolStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropRoleStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropRouteStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropRouteStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropSearchPropertyListStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropSearchPropertyListStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropServerAuditSpecificationStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServerAuditSpecificationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropServerAuditStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServerAuditStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropServerRoleStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServerRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropServiceStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropServiceStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropSymmetricKeyStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropSymmetricKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RemoveProviderKey))))
      | :? ScriptDom.DropUserStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropUserStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.DropWorkloadGroupStatement as src->
        TSqlStatement.DropUnownedObjectStatement((DropUnownedObjectStatement.DropWorkloadGroupStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.DropXmlSchemaCollectionStatement as src ->
      TSqlStatement.DropXmlSchemaCollectionStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.EnableDisableTriggerStatement as src ->
      TSqlStatement.EnableDisableTriggerStatement((src.All), (src.TriggerEnforcement), (src.TriggerNames |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)))
    | :? ScriptDom.EndConversationStatement as src ->
      TSqlStatement.EndConversationStatement((src.Conversation |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.ErrorCode |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.ErrorDescription |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.WithCleanup))
    | :? ScriptDom.EventSessionStatement as src ->
      match src with
      | :? ScriptDom.AlterEventSessionStatement as src->
        TSqlStatement.EventSessionStatement((EventSessionStatement.AlterEventSessionStatement((src.DropEventDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.DropTargetDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionOptions |> Seq.map (SessionOption.FromCs) |> List.ofSeq), (src.SessionScope), (src.StatementType), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq))))
      | :? ScriptDom.CreateEventSessionStatement as src->
        TSqlStatement.EventSessionStatement((EventSessionStatement.CreateEventSessionStatement((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionOptions |> Seq.map (SessionOption.FromCs) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq))))
      | _ -> (* :? ScriptDom.EventSessionStatement as src *)
        TSqlStatement.EventSessionStatement((EventSessionStatement.Base((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionOptions |> Seq.map (SessionOption.FromCs) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq))))
    | :? ScriptDom.ExecuteAsStatement as src ->
      TSqlStatement.ExecuteAsStatement((src.Cookie |> Option.ofObj |> Option.map (VariableReference.FromCs)), (src.ExecuteContext |> Option.ofObj |> Option.map (ExecuteContext.FromCs)), (src.WithNoRevert))
    | :? ScriptDom.ExecuteStatement as src ->
      TSqlStatement.ExecuteStatement((src.ExecuteSpecification |> Option.ofObj |> Option.map (ExecuteSpecification.FromCs)), (src.Options |> Seq.map (ExecuteOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.ExternalDataSourceStatement as src ->
      match src with
      | :? ScriptDom.AlterExternalDataSourceStatement as src->
        TSqlStatement.ExternalDataSourceStatement((ExternalDataSourceStatement.AlterExternalDataSourceStatement((src.DataSourceType), (src.ExternalDataSourceOptions |> Seq.map (ExternalDataSourceOption.FromCs) |> List.ofSeq), (src.Location |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateExternalDataSourceStatement as src->
        TSqlStatement.ExternalDataSourceStatement((ExternalDataSourceStatement.CreateExternalDataSourceStatement((src.DataSourceType), (src.ExternalDataSourceOptions |> Seq.map (ExternalDataSourceOption.FromCs) |> List.ofSeq), (src.Location |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.ExternalFileFormatStatement as src ->
      match src with
      | :? ScriptDom.CreateExternalFileFormatStatement as src->
        TSqlStatement.ExternalFileFormatStatement((ExternalFileFormatStatement.CreateExternalFileFormatStatement((src.ExternalFileFormatOptions |> Seq.map (ExternalFileFormatOption.FromCs) |> List.ofSeq), (src.FormatType), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.ExternalResourcePoolStatement as src ->
      match src with
      | :? ScriptDom.AlterExternalResourcePoolStatement as src->
        TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.AlterExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateExternalResourcePoolStatement as src->
        TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.CreateExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | _ -> (* :? ScriptDom.ExternalResourcePoolStatement as src *)
        TSqlStatement.ExternalResourcePoolStatement((ExternalResourcePoolStatement.Base((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.ExternalTableStatement as src ->
      match src with
      | :? ScriptDom.CreateExternalTableStatement as src->
        TSqlStatement.ExternalTableStatement((ExternalTableStatement.CreateExternalTableStatement((src.ColumnDefinitions |> Seq.map (fun src -> ExternalTableColumnDefinition.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullableConstraint |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))) |> List.ofSeq), (src.DataSource |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ExternalTableOptions |> Seq.map (ExternalTableOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.FullTextCatalogStatement as src ->
      match src with
      | :? ScriptDom.AlterFullTextCatalogStatement as src->
        TSqlStatement.FullTextCatalogStatement((FullTextCatalogStatement.AlterFullTextCatalogStatement((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (FullTextCatalogOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateFullTextCatalogStatement as src->
        TSqlStatement.FullTextCatalogStatement((FullTextCatalogStatement.CreateFullTextCatalogStatement((src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (FullTextCatalogOption.FromCs) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.GoToStatement as src ->
      TSqlStatement.GoToStatement((src.LabelName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.IfStatement as src ->
      TSqlStatement.IfStatement((src.ElseStatement |> Option.ofObj |> Option.map (TSqlStatement.FromCs)), (src.Predicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.ThenStatement |> Option.ofObj |> Option.map (TSqlStatement.FromCs)))
    | :? ScriptDom.IndexDefinition as src ->
      TSqlStatement.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Unique))
    | :? ScriptDom.IndexStatement as src ->
      match src with
      | :? ScriptDom.AlterIndexStatement as src->
        TSqlStatement.IndexStatement((IndexStatement.AlterIndexStatement((src.All), (src.AlterIndexType), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Partition |> Option.ofObj |> Option.map (PartitionSpecifier.FromCs)), (src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)), (src.SQLDataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.XQueryDataType |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.XmlNamespaces |> Option.ofObj |> Option.map (XmlNamespaces.FromCs)))))
      | :? ScriptDom.CreateIndexStatement as src->
        TSqlStatement.IndexStatement((IndexStatement.CreateIndexStatement((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IncludeColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Translated80SyntaxTo90), (src.Unique))))
      | :? ScriptDom.CreateSelectiveXmlIndexStatement as src->
        TSqlStatement.IndexStatement((IndexStatement.CreateSelectiveXmlIndexStatement((src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IsSecondary), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.PathName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)), (src.SQLDataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.XQueryDataType |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.UsingXmlIndexName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.XmlColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.XmlNamespaces |> Option.ofObj |> Option.map (XmlNamespaces.FromCs)))))
      | :? ScriptDom.CreateXmlIndexStatement as src->
        TSqlStatement.IndexStatement((IndexStatement.CreateXmlIndexStatement((src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Primary), (src.SecondaryXmlIndexName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SecondaryXmlIndexType), (src.XmlColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.KillQueryNotificationSubscriptionStatement as src ->
      TSqlStatement.KillQueryNotificationSubscriptionStatement((src.All), (src.SubscriptionId |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.KillStatement as src ->
      TSqlStatement.KillStatement((src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WithStatusOnly))
    | :? ScriptDom.KillStatsJobStatement as src ->
      TSqlStatement.KillStatsJobStatement((src.JobId |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.LabelStatement as src ->
      TSqlStatement.LabelStatement((src.Value))
    | :? ScriptDom.LineNoStatement as src ->
      TSqlStatement.LineNoStatement((src.LineNo |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)))
    | :? ScriptDom.MasterKeyStatement as src ->
      match src with
      | :? ScriptDom.AlterMasterKeyStatement as src->
        TSqlStatement.MasterKeyStatement((MasterKeyStatement.AlterMasterKeyStatement((src.Option), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
      | :? ScriptDom.CreateMasterKeyStatement as src->
        TSqlStatement.MasterKeyStatement((MasterKeyStatement.CreateMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.MessageTypeStatementBase as src ->
      match src with
      | :? ScriptDom.AlterMessageTypeStatement as src->
        TSqlStatement.MessageTypeStatementBase((MessageTypeStatementBase.AlterMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ValidationMethod), (src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.CreateMessageTypeStatement as src->
        TSqlStatement.MessageTypeStatementBase((MessageTypeStatementBase.CreateMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ValidationMethod), (src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
    | :? ScriptDom.MoveConversationStatement as src ->
      TSqlStatement.MoveConversationStatement((src.Conversation |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Group |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.OpenMasterKeyStatement as src ->
      TSqlStatement.OpenMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.OpenSymmetricKeyStatement as src ->
      TSqlStatement.OpenSymmetricKeyStatement((src.DecryptionMechanism |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.PrintStatement as src ->
      TSqlStatement.PrintStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ProcedureStatementBodyBase as src ->
      match src with
      | :? ScriptDom.FunctionStatementBody as src->
        TSqlStatement.ProcedureStatementBodyBase((ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.FromCs(src)))))
      | :? ScriptDom.ProcedureStatementBody as src->
        TSqlStatement.ProcedureStatementBodyBase((ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.FromCs(src)))))
    | :? ScriptDom.QueueStatement as src ->
      match src with
      | :? ScriptDom.AlterQueueStatement as src->
        TSqlStatement.QueueStatement((QueueStatement.AlterQueueStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.QueueOptions |> Seq.map (QueueOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateQueueStatement as src->
        TSqlStatement.QueueStatement((QueueStatement.CreateQueueStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.OnFileGroup |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.QueueOptions |> Seq.map (QueueOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.RaiseErrorLegacyStatement as src ->
      TSqlStatement.RaiseErrorLegacyStatement((src.FirstParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondParameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.RaiseErrorStatement as src ->
      TSqlStatement.RaiseErrorStatement((src.FirstParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OptionalParameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.RaiseErrorOptions), (src.SecondParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.ThirdParameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ReadTextStatement as src ->
      TSqlStatement.ReadTextStatement((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.HoldLock), (src.Offset |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Size |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TextPointer |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.ReconfigureStatement as src ->
      TSqlStatement.ReconfigureStatement((src.WithOverride))
    | :? ScriptDom.RemoteServiceBindingStatementBase as src ->
      match src with
      | :? ScriptDom.AlterRemoteServiceBindingStatement as src->
        TSqlStatement.RemoteServiceBindingStatementBase((RemoteServiceBindingStatementBase.AlterRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (RemoteServiceBindingOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateRemoteServiceBindingStatement as src->
        TSqlStatement.RemoteServiceBindingStatementBase((RemoteServiceBindingStatementBase.CreateRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (RemoteServiceBindingOption.FromCs) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Service |> Option.ofObj |> Option.map (Literal.FromCs)))))
    | :? ScriptDom.ResourcePoolStatement as src ->
      match src with
      | :? ScriptDom.AlterResourcePoolStatement as src->
        TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.AlterResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.CreateResourcePoolStatement as src->
        TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.CreateResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
      | _ -> (* :? ScriptDom.ResourcePoolStatement as src *)
        TSqlStatement.ResourcePoolStatement((ResourcePoolStatement.Base((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))))
    | :? ScriptDom.RestoreStatement as src ->
      TSqlStatement.RestoreStatement((src.DatabaseName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Kind), (src.Options |> Seq.map (RestoreOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.ReturnStatement as src ->
      TSqlStatement.ReturnStatement((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.RevertStatement as src ->
      TSqlStatement.RevertStatement((src.Cookie |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.RoleStatement as src ->
      match src with
      | :? ScriptDom.AlterRoleStatement as src->
        TSqlStatement.RoleStatement((RoleStatement.AlterRoleStatement((AlterRoleStatement.FromCs(src)))))
      | :? ScriptDom.CreateRoleStatement as src->
        TSqlStatement.RoleStatement((RoleStatement.CreateRoleStatement((CreateRoleStatement.FromCs(src)))))
    | :? ScriptDom.RouteStatement as src ->
      match src with
      | :? ScriptDom.AlterRouteStatement as src->
        TSqlStatement.RouteStatement((RouteStatement.AlterRouteStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))) |> List.ofSeq))))
      | :? ScriptDom.CreateRouteStatement as src->
        TSqlStatement.RouteStatement((RouteStatement.CreateRouteStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))) |> List.ofSeq))))
    | :? ScriptDom.SecurityPolicyStatement as src ->
      match src with
      | :? ScriptDom.AlterSecurityPolicyStatement as src->
        TSqlStatement.SecurityPolicyStatement((SecurityPolicyStatement.AlterSecurityPolicyStatement((src.ActionType), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.NotForReplication), (src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq), (src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.CreateSecurityPolicyStatement as src->
        TSqlStatement.SecurityPolicyStatement((SecurityPolicyStatement.CreateSecurityPolicyStatement((src.ActionType), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.NotForReplication), (src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq), (src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))) |> List.ofSeq))))
    | :? ScriptDom.SecurityStatement as src ->
      match src with
      | :? ScriptDom.DenyStatement as src->
        TSqlStatement.SecurityStatement((SecurityStatement.DenyStatement((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.CascadeOption), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)))))
      | :? ScriptDom.GrantStatement as src->
        TSqlStatement.SecurityStatement((SecurityStatement.GrantStatement((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)), (src.WithGrantOption))))
      | :? ScriptDom.RevokeStatement as src->
        TSqlStatement.SecurityStatement((SecurityStatement.RevokeStatement((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.CascadeOption), (src.GrantOptionFor), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)))))
    | :? ScriptDom.SecurityStatementBody80 as src ->
      match src with
      | :? ScriptDom.DenyStatement80 as src->
        TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.DenyStatement80((src.CascadeOption), (src.SecurityElement80 |> Option.ofObj |> Option.map (SecurityElement80.FromCs)), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (SecurityUserClause80.FromCs)))))
      | :? ScriptDom.GrantStatement80 as src->
        TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.GrantStatement80((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SecurityElement80 |> Option.ofObj |> Option.map (SecurityElement80.FromCs)), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (SecurityUserClause80.FromCs)), (src.WithGrantOption))))
      | :? ScriptDom.RevokeStatement80 as src->
        TSqlStatement.SecurityStatementBody80((SecurityStatementBody80.RevokeStatement80((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.CascadeOption), (src.GrantOptionFor), (src.SecurityElement80 |> Option.ofObj |> Option.map (SecurityElement80.FromCs)), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (SecurityUserClause80.FromCs)))))
    | :? ScriptDom.SendStatement as src ->
      TSqlStatement.SendStatement((src.ConversationHandles |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.MessageBody |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.MessageTypeName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.SequenceStatement as src ->
      match src with
      | :? ScriptDom.AlterSequenceStatement as src->
        TSqlStatement.SequenceStatement((SequenceStatement.AlterSequenceStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SequenceOptions |> Seq.map (SequenceOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateSequenceStatement as src->
        TSqlStatement.SequenceStatement((SequenceStatement.CreateSequenceStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SequenceOptions |> Seq.map (SequenceOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.ServerAuditStatement as src ->
      match src with
      | :? ScriptDom.AlterServerAuditStatement as src->
        TSqlStatement.ServerAuditStatement((ServerAuditStatement.AlterServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditTarget |> Option.ofObj |> Option.map (AuditTarget.FromCs)), (src.NewName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AuditOption.FromCs) |> List.ofSeq), (src.PredicateExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.RemoveWhere))))
      | :? ScriptDom.CreateServerAuditStatement as src->
        TSqlStatement.ServerAuditStatement((ServerAuditStatement.CreateServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditTarget |> Option.ofObj |> Option.map (AuditTarget.FromCs)), (src.Options |> Seq.map (AuditOption.FromCs) |> List.ofSeq), (src.PredicateExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))))
    | :? ScriptDom.SetCommandStatement as src ->
      TSqlStatement.SetCommandStatement((src.Commands |> Seq.map (SetCommand.FromCs) |> List.ofSeq))
    | :? ScriptDom.SetErrorLevelStatement as src ->
      TSqlStatement.SetErrorLevelStatement((src.Level |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.SetOnOffStatement as src ->
      match src with
      | :? ScriptDom.PredicateSetStatement as src->
        TSqlStatement.SetOnOffStatement((SetOnOffStatement.PredicateSetStatement((src.IsOn), (src.Options))))
      | :? ScriptDom.SetIdentityInsertStatement as src->
        TSqlStatement.SetOnOffStatement((SetOnOffStatement.SetIdentityInsertStatement((src.IsOn), (src.Table |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.SetOffsetsStatement as src->
        TSqlStatement.SetOnOffStatement((SetOnOffStatement.SetOffsetsStatement((src.IsOn), (src.Options))))
      | :? ScriptDom.SetStatisticsStatement as src->
        TSqlStatement.SetOnOffStatement((SetOnOffStatement.SetStatisticsStatement((src.IsOn), (src.Options))))
    | :? ScriptDom.SetRowCountStatement as src ->
      TSqlStatement.SetRowCountStatement((src.NumberRows |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.SetTextSizeStatement as src ->
      TSqlStatement.SetTextSizeStatement((src.TextSize |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.SetTransactionIsolationLevelStatement as src ->
      TSqlStatement.SetTransactionIsolationLevelStatement((src.Level))
    | :? ScriptDom.SetUserStatement as src ->
      TSqlStatement.SetUserStatement((src.UserName |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.WithNoReset))
    | :? ScriptDom.SetVariableStatement as src ->
      TSqlStatement.SetVariableStatement((src.AssignmentKind), (src.CursorDefinition |> Option.ofObj |> Option.map (CursorDefinition.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FunctionCallExists), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.SeparatorType), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.ShutdownStatement as src ->
      TSqlStatement.ShutdownStatement((src.WithNoWait))
    | :? ScriptDom.SignatureStatementBase as src ->
      match src with
      | :? ScriptDom.AddSignatureStatement as src->
        TSqlStatement.SignatureStatementBase((SignatureStatementBase.AddSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Element |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ElementKind), (src.IsCounter))))
      | :? ScriptDom.DropSignatureStatement as src->
        TSqlStatement.SignatureStatementBase((SignatureStatementBase.DropSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Element |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ElementKind), (src.IsCounter))))
    | :? ScriptDom.StatementWithCtesAndXmlNamespaces as src ->
      match src with
      | :? ScriptDom.DataModificationStatement as src->
        TSqlStatement.StatementWithCtesAndXmlNamespaces((StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.FromCs(src)))))
      | :? ScriptDom.SelectStatement as src->
        TSqlStatement.StatementWithCtesAndXmlNamespaces((StatementWithCtesAndXmlNamespaces.SelectStatement((SelectStatement.FromCs(src)))))
    | :? ScriptDom.SymmetricKeyStatement as src ->
      match src with
      | :? ScriptDom.AlterSymmetricKeyStatement as src->
        TSqlStatement.SymmetricKeyStatement((SymmetricKeyStatement.AlterSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.IsAdd), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.CreateSymmetricKeyStatement as src->
        TSqlStatement.SymmetricKeyStatement((SymmetricKeyStatement.CreateSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.KeyOptions |> Seq.map (KeyOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Provider |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.TSqlStatementSnippet as src ->
      TSqlStatement.TSqlStatementSnippet((src.Script))
    | :? ScriptDom.TextModificationStatement as src ->
      match src with
      | :? ScriptDom.UpdateTextStatement as src->
        TSqlStatement.TextModificationStatement((TextModificationStatement.UpdateTextStatement((src.Bulk), (src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.DeleteLength |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.InsertOffset |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SourceColumn |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SourceParameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TextId |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Timestamp |> Option.ofObj |> Option.map (Literal.FromCs)), (src.WithLog))))
      | :? ScriptDom.WriteTextStatement as src->
        TSqlStatement.TextModificationStatement((TextModificationStatement.WriteTextStatement((src.Bulk), (src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SourceParameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TextId |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Timestamp |> Option.ofObj |> Option.map (Literal.FromCs)), (src.WithLog))))
    | :? ScriptDom.ThrowStatement as src ->
      TSqlStatement.ThrowStatement((src.ErrorNumber |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Message |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.State |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.TransactionStatement as src ->
      match src with
      | :? ScriptDom.BeginTransactionStatement as src->
        TSqlStatement.TransactionStatement((TransactionStatement.BeginTransactionStatement((src.Distributed), (src.MarkDefined), (src.MarkDescription |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.CommitTransactionStatement as src->
        TSqlStatement.TransactionStatement((TransactionStatement.CommitTransactionStatement((src.DelayedDurabilityOption), (src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.RollbackTransactionStatement as src->
        TSqlStatement.TransactionStatement((TransactionStatement.RollbackTransactionStatement((src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
      | :? ScriptDom.SaveTransactionStatement as src->
        TSqlStatement.TransactionStatement((TransactionStatement.SaveTransactionStatement((src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))))
    | :? ScriptDom.TriggerStatementBody as src ->
      match src with
      | :? ScriptDom.AlterTriggerStatement as src->
        TSqlStatement.TriggerStatementBody((TriggerStatementBody.AlterTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TriggerOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)), (src.TriggerType), (src.WithAppend))))
      | :? ScriptDom.CreateOrAlterTriggerStatement as src->
        TSqlStatement.TriggerStatementBody((TriggerStatementBody.CreateOrAlterTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TriggerOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)), (src.TriggerType), (src.WithAppend))))
      | :? ScriptDom.CreateTriggerStatement as src->
        TSqlStatement.TriggerStatementBody((TriggerStatementBody.CreateTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TriggerOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)), (src.TriggerType), (src.WithAppend))))
    | :? ScriptDom.TruncateTableStatement as src ->
      TSqlStatement.TruncateTableStatement((src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.TryCatchStatement as src ->
      TSqlStatement.TryCatchStatement((src.CatchStatements |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TryStatements |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | :? ScriptDom.UpdateStatisticsStatement as src ->
      TSqlStatement.UpdateStatisticsStatement((src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.StatisticsOptions |> Seq.map (StatisticsOption.FromCs) |> List.ofSeq), (src.SubElements |> Seq.map (Identifier.FromCs) |> List.ofSeq))
    | :? ScriptDom.UseFederationStatement as src ->
      TSqlStatement.UseFederationStatement((src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FederationName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Filtering), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.UseStatement as src ->
      TSqlStatement.UseStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.UserStatement as src ->
      match src with
      | :? ScriptDom.AlterUserStatement as src->
        TSqlStatement.UserStatement((UserStatement.AlterUserStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UserOptions |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateUserStatement as src->
        TSqlStatement.UserStatement((UserStatement.CreateUserStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UserLoginOption |> Option.ofObj |> Option.map (UserLoginOption.FromCs)), (src.UserOptions |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))))
    | :? ScriptDom.ViewStatementBody as src ->
      match src with
      | :? ScriptDom.AlterViewStatement as src->
        TSqlStatement.ViewStatementBody((ViewStatementBody.AlterViewStatement((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)), (src.ViewOptions |> Seq.map (fun src -> ViewOption.ViewOption((src.OptionKind))) |> List.ofSeq), (src.WithCheckOption))))
      | :? ScriptDom.CreateOrAlterViewStatement as src->
        TSqlStatement.ViewStatementBody((ViewStatementBody.CreateOrAlterViewStatement((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)), (src.ViewOptions |> Seq.map (fun src -> ViewOption.ViewOption((src.OptionKind))) |> List.ofSeq), (src.WithCheckOption))))
      | :? ScriptDom.CreateViewStatement as src->
        TSqlStatement.ViewStatementBody((ViewStatementBody.CreateViewStatement((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)), (src.ViewOptions |> Seq.map (fun src -> ViewOption.ViewOption((src.OptionKind))) |> List.ofSeq), (src.WithCheckOption))))
    | :? ScriptDom.WaitForStatement as src ->
      TSqlStatement.WaitForStatement((src.Parameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Statement |> Option.ofObj |> Option.map (WaitForSupportedStatement.FromCs)), (src.Timeout |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WaitForOption))
    | :? ScriptDom.WaitForSupportedStatement as src ->
      match src with
      | :? ScriptDom.GetConversationGroupStatement as src->
        TSqlStatement.WaitForSupportedStatement((WaitForSupportedStatement.GetConversationGroupStatement((src.GroupId |> Option.ofObj |> Option.map (VariableReference.FromCs)), (src.Queue |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.ReceiveStatement as src->
        TSqlStatement.WaitForSupportedStatement((WaitForSupportedStatement.ReceiveStatement((src.Into |> Option.ofObj |> Option.map (VariableTableReference.FromCs)), (src.IsConversationGroupIdWhere), (src.Queue |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectElements |> Seq.map (SelectElement.FromCs) |> List.ofSeq), (src.Top |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Where |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
    | :? ScriptDom.WhileStatement as src ->
      TSqlStatement.WhileStatement((src.Predicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.Statement |> Option.ofObj |> Option.map (TSqlStatement.FromCs)))
    | :? ScriptDom.WorkloadGroupStatement as src ->
      match src with
      | :? ScriptDom.AlterWorkloadGroupStatement as src->
        TSqlStatement.WorkloadGroupStatement((WorkloadGroupStatement.AlterWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.WorkloadGroupParameters |> Seq.map (WorkloadGroupParameter.FromCs) |> List.ofSeq))))
      | :? ScriptDom.CreateWorkloadGroupStatement as src->
        TSqlStatement.WorkloadGroupStatement((WorkloadGroupStatement.CreateWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.WorkloadGroupParameters |> Seq.map (WorkloadGroupParameter.FromCs) |> List.ofSeq))))
and TableDistributionPolicy = (* IsAbstract = true , children = 3*)
  | TableHashDistributionPolicy of distributionColumn:Identifier option
  | TableReplicateDistributionPolicy 
  | TableRoundRobinDistributionPolicy 
  member this.ToCs() : ScriptDom.TableDistributionPolicy =
    match this with
    | TableHashDistributionPolicy(distributionColumn=aDistributionColumn) ->
      let ret = ScriptDom.TableHashDistributionPolicy()
      ret.DistributionColumn <- aDistributionColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableDistributionPolicy (* 404 *)
    | TableReplicateDistributionPolicy -> ScriptDom.TableReplicateDistributionPolicy() :> ScriptDom.TableDistributionPolicy (* 396 *)
    | TableRoundRobinDistributionPolicy -> ScriptDom.TableRoundRobinDistributionPolicy() :> ScriptDom.TableDistributionPolicy (* 396 *)
  static member FromCs(src:ScriptDom.TableDistributionPolicy) : TableDistributionPolicy =
    match src with
    | :? ScriptDom.TableHashDistributionPolicy as src ->
      TableDistributionPolicy.TableHashDistributionPolicy((src.DistributionColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.TableReplicateDistributionPolicy as src ->
      TableDistributionPolicy.TableReplicateDistributionPolicy
    | :? ScriptDom.TableRoundRobinDistributionPolicy as src ->
      TableDistributionPolicy.TableRoundRobinDistributionPolicy
and TableHint = (* IsAbstract = false , children = 3*)
  | Base of hintKind:ScriptDom.TableHintKind
  | ForceSeekTableHint of columnValues:(ColumnReferenceExpression) list * hintKind:ScriptDom.TableHintKind * indexValue:IdentifierOrValueExpression option
  | IndexTableHint of hintKind:ScriptDom.TableHintKind * indexValues:(IdentifierOrValueExpression) list
  | LiteralTableHint of hintKind:ScriptDom.TableHintKind * value:Literal option
  member this.ToCs() : ScriptDom.TableHint =
    match this with
    | ForceSeekTableHint(columnValues=aColumnValues; hintKind=aHintKind; indexValue=aIndexValue) ->
      let ret = ScriptDom.ForceSeekTableHint()
      for e in aColumnValues do ret.ColumnValues.Add (e.ToCs())
      ret.HintKind <- aHintKind
      ret.IndexValue <- aIndexValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableHint (* 404 *)
    | IndexTableHint(hintKind=aHintKind; indexValues=aIndexValues) ->
      let ret = ScriptDom.IndexTableHint()
      ret.HintKind <- aHintKind
      for e in aIndexValues do ret.IndexValues.Add (e.ToCs())
      ret :> ScriptDom.TableHint (* 404 *)
    | LiteralTableHint(hintKind=aHintKind; value=aValue) ->
      let ret = ScriptDom.LiteralTableHint()
      ret.HintKind <- aHintKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableHint (* 404 *)
    | Base(hintKind=aHintKind) ->

      let ret = ScriptDom.TableHint()
      ret.HintKind <- aHintKind
      ret
//// shared props TableHint 
  member this.HintKind = 
    match this with
    | Base (hintKind=hintKind) -> hintKind
    | ForceSeekTableHint(hintKind=hintKind) -> hintKind
    | IndexTableHint(hintKind=hintKind) -> hintKind
    | LiteralTableHint(hintKind=hintKind) -> hintKind
  static member FromCs(src:ScriptDom.TableHint) : TableHint =
    match src with
    | :? ScriptDom.ForceSeekTableHint as src ->
      TableHint.ForceSeekTableHint((src.ColumnValues |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.HintKind), (src.IndexValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.IndexTableHint as src ->
      TableHint.IndexTableHint((src.HintKind), (src.IndexValues |> Seq.map (fun src -> IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Value), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.LiteralTableHint as src ->
      TableHint.LiteralTableHint((src.HintKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | _ -> (* :? ScriptDom.TableHint as src *)
      TableHint.Base(((src.HintKind)))
and TableIndexType = (* IsAbstract = true , children = 2*)
  | TableClusteredIndexType of columnStore:bool * columns:(ColumnWithSortOrder) list
  | TableNonClusteredIndexType 
  member this.ToCs() : ScriptDom.TableIndexType =
    match this with
    | TableClusteredIndexType(columnStore=aColumnStore; columns=aColumns) ->
      let ret = ScriptDom.TableClusteredIndexType()
      ret.ColumnStore <- aColumnStore
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret :> ScriptDom.TableIndexType (* 404 *)
    | TableNonClusteredIndexType -> ScriptDom.TableNonClusteredIndexType() :> ScriptDom.TableIndexType (* 396 *)
  static member FromCs(src:ScriptDom.TableIndexType) : TableIndexType =
    match src with
    | :? ScriptDom.TableClusteredIndexType as src ->
      TableIndexType.TableClusteredIndexType((src.ColumnStore), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq))
    | :? ScriptDom.TableNonClusteredIndexType as src ->
      TableIndexType.TableNonClusteredIndexType
and TableOption = (* IsAbstract = true , children = 14*)
  | DurabilityTableOption of durabilityTableOptionKind:ScriptDom.DurabilityTableOptionKind * optionKind:ScriptDom.TableOptionKind
  | FileStreamOnTableOption of optionKind:ScriptDom.TableOptionKind * value:IdentifierOrValueExpression option
  | FileTableCollateFileNameTableOption of optionKind:ScriptDom.TableOptionKind * value:Identifier option
  | FileTableConstraintNameTableOption of optionKind:ScriptDom.TableOptionKind * value:Identifier option
  | FileTableDirectoryTableOption of optionKind:ScriptDom.TableOptionKind * value:Literal option
  | LockEscalationTableOption of optionKind:ScriptDom.TableOptionKind * value:ScriptDom.LockEscalationMethod
  | MemoryOptimizedTableOption of optionKind:ScriptDom.TableOptionKind * optionState:ScriptDom.OptionState
  | RemoteDataArchiveAlterTableOption of filterPredicate:FunctionCall option * isFilterPredicateSpecified:bool * isMigrationStateSpecified:bool * migrationState:ScriptDom.MigrationState * optionKind:ScriptDom.TableOptionKind * rdaTableOption:ScriptDom.RdaTableOption
  | RemoteDataArchiveTableOption of migrationState:ScriptDom.MigrationState * optionKind:ScriptDom.TableOptionKind * rdaTableOption:ScriptDom.RdaTableOption
  | SystemVersioningTableOption of consistencyCheckEnabled:ScriptDom.OptionState * historyTable:SchemaObjectName option * optionKind:ScriptDom.TableOptionKind * optionState:ScriptDom.OptionState * retentionPeriod:RetentionPeriodDefinition option
  | TableDataCompressionOption of dataCompressionOption:DataCompressionOption option * optionKind:ScriptDom.TableOptionKind
  | TableDistributionOption of optionKind:ScriptDom.TableOptionKind * value:TableDistributionPolicy option
  | TableIndexOption of optionKind:ScriptDom.TableOptionKind * value:TableIndexType option
  | TablePartitionOption of optionKind:ScriptDom.TableOptionKind * partitionColumn:Identifier option * partitionOptionSpecs:TablePartitionOptionSpecifications option
  member this.ToCs() : ScriptDom.TableOption =
    match this with
    | DurabilityTableOption(durabilityTableOptionKind=aDurabilityTableOptionKind; optionKind=aOptionKind) ->
      let ret = ScriptDom.DurabilityTableOption()
      ret.DurabilityTableOptionKind <- aDurabilityTableOptionKind
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TableOption (* 404 *)
    | FileStreamOnTableOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.FileStreamOnTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | FileTableCollateFileNameTableOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.FileTableCollateFileNameTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | FileTableConstraintNameTableOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.FileTableConstraintNameTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | FileTableDirectoryTableOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.FileTableDirectoryTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | LockEscalationTableOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.LockEscalationTableOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret :> ScriptDom.TableOption (* 404 *)
    | MemoryOptimizedTableOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.MemoryOptimizedTableOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.TableOption (* 404 *)
    | RemoteDataArchiveAlterTableOption(filterPredicate=aFilterPredicate; isFilterPredicateSpecified=aIsFilterPredicateSpecified; isMigrationStateSpecified=aIsMigrationStateSpecified; migrationState=aMigrationState; optionKind=aOptionKind; rdaTableOption=aRdaTableOption) ->
      let ret = ScriptDom.RemoteDataArchiveAlterTableOption()
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsFilterPredicateSpecified <- aIsFilterPredicateSpecified
      ret.IsMigrationStateSpecified <- aIsMigrationStateSpecified
      ret.MigrationState <- aMigrationState
      ret.OptionKind <- aOptionKind
      ret.RdaTableOption <- aRdaTableOption
      ret :> ScriptDom.TableOption (* 404 *)
    | RemoteDataArchiveTableOption(migrationState=aMigrationState; optionKind=aOptionKind; rdaTableOption=aRdaTableOption) ->
      let ret = ScriptDom.RemoteDataArchiveTableOption()
      ret.MigrationState <- aMigrationState
      ret.OptionKind <- aOptionKind
      ret.RdaTableOption <- aRdaTableOption
      ret :> ScriptDom.TableOption (* 404 *)
    | SystemVersioningTableOption(consistencyCheckEnabled=aConsistencyCheckEnabled; historyTable=aHistoryTable; optionKind=aOptionKind; optionState=aOptionState; retentionPeriod=aRetentionPeriod) ->
      let ret = ScriptDom.SystemVersioningTableOption()
      ret.ConsistencyCheckEnabled <- aConsistencyCheckEnabled
      ret.HistoryTable <- aHistoryTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret.RetentionPeriod <- aRetentionPeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | TableDataCompressionOption(dataCompressionOption=aDataCompressionOption; optionKind=aOptionKind) ->
      let ret = ScriptDom.TableDataCompressionOption()
      ret.DataCompressionOption <- aDataCompressionOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TableOption (* 404 *)
    | TableDistributionOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.TableDistributionOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | TableIndexOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.TableIndexOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
    | TablePartitionOption(optionKind=aOptionKind; partitionColumn=aPartitionColumn; partitionOptionSpecs=aPartitionOptionSpecs) ->
      let ret = ScriptDom.TablePartitionOption()
      ret.OptionKind <- aOptionKind
      ret.PartitionColumn <- aPartitionColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PartitionOptionSpecs <- aPartitionOptionSpecs |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableOption (* 404 *)
//// shared props TableOption 
  member this.OptionKind = 
    match this with
    | DurabilityTableOption(optionKind=optionKind) -> optionKind
    | FileStreamOnTableOption(optionKind=optionKind) -> optionKind
    | FileTableCollateFileNameTableOption(optionKind=optionKind) -> optionKind
    | FileTableConstraintNameTableOption(optionKind=optionKind) -> optionKind
    | FileTableDirectoryTableOption(optionKind=optionKind) -> optionKind
    | LockEscalationTableOption(optionKind=optionKind) -> optionKind
    | MemoryOptimizedTableOption(optionKind=optionKind) -> optionKind
    | RemoteDataArchiveAlterTableOption(optionKind=optionKind) -> optionKind
    | RemoteDataArchiveTableOption(optionKind=optionKind) -> optionKind
    | SystemVersioningTableOption(optionKind=optionKind) -> optionKind
    | TableDataCompressionOption(optionKind=optionKind) -> optionKind
    | TableDistributionOption(optionKind=optionKind) -> optionKind
    | TableIndexOption(optionKind=optionKind) -> optionKind
    | TablePartitionOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.TableOption) : TableOption =
    match src with
    | :? ScriptDom.DurabilityTableOption as src ->
      TableOption.DurabilityTableOption((src.DurabilityTableOptionKind), (src.OptionKind))
    | :? ScriptDom.FileStreamOnTableOption as src ->
      TableOption.FileStreamOnTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.FileTableCollateFileNameTableOption as src ->
      TableOption.FileTableCollateFileNameTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FileTableConstraintNameTableOption as src ->
      TableOption.FileTableConstraintNameTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.FileTableDirectoryTableOption as src ->
      TableOption.FileTableDirectoryTableOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.LockEscalationTableOption as src ->
      TableOption.LockEscalationTableOption((src.OptionKind), (src.Value))
    | :? ScriptDom.MemoryOptimizedTableOption as src ->
      TableOption.MemoryOptimizedTableOption((src.OptionKind), (src.OptionState))
    | :? ScriptDom.RemoteDataArchiveAlterTableOption as src ->
      TableOption.RemoteDataArchiveAlterTableOption((src.FilterPredicate |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.IsFilterPredicateSpecified), (src.IsMigrationStateSpecified), (src.MigrationState), (src.OptionKind), (src.RdaTableOption))
    | :? ScriptDom.RemoteDataArchiveTableOption as src ->
      TableOption.RemoteDataArchiveTableOption((src.MigrationState), (src.OptionKind), (src.RdaTableOption))
    | :? ScriptDom.SystemVersioningTableOption as src ->
      TableOption.SystemVersioningTableOption((src.ConsistencyCheckEnabled), (src.HistoryTable |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.OptionKind), (src.OptionState), (src.RetentionPeriod |> Option.ofObj |> Option.map (RetentionPeriodDefinition.FromCs)))
    | :? ScriptDom.TableDataCompressionOption as src ->
      TableOption.TableDataCompressionOption((src.DataCompressionOption |> Option.ofObj |> Option.map (DataCompressionOption.FromCs)), (src.OptionKind))
    | :? ScriptDom.TableDistributionOption as src ->
      TableOption.TableDistributionOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (TableDistributionPolicy.FromCs)))
    | :? ScriptDom.TableIndexOption as src ->
      TableOption.TableIndexOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (TableIndexType.FromCs)))
    | :? ScriptDom.TablePartitionOption as src ->
      TableOption.TablePartitionOption((src.OptionKind), (src.PartitionColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PartitionOptionSpecs |> Option.ofObj |> Option.map (TablePartitionOptionSpecifications.FromCs)))
and TableReference = (* IsAbstract = true , children = 4*)
  | JoinParenthesisTableReference of join:TableReference option
  | JoinTableReference of joinTableReference:JoinTableReference
  | OdbcQualifiedJoinTableReference of tableReference:TableReference option
  | TableReferenceWithAlias of tableReferenceWithAlias:TableReferenceWithAlias
  member this.ToCs() : ScriptDom.TableReference =
    match this with
    | JoinParenthesisTableReference(join=aJoin) ->
      let ret = ScriptDom.JoinParenthesisTableReference()
      ret.Join <- aJoin |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReference (* 404 *)
    | JoinTableReference(x) -> x.ToCs() :> ScriptDom.TableReference (* 414 *)
    | OdbcQualifiedJoinTableReference(tableReference=aTableReference) ->
      let ret = ScriptDom.OdbcQualifiedJoinTableReference()
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReference (* 404 *)
    | TableReferenceWithAlias(x) -> x.ToCs() :> ScriptDom.TableReference (* 414 *)
  static member FromCs(src:ScriptDom.TableReference) : TableReference =
    match src with
    | :? ScriptDom.JoinParenthesisTableReference as src ->
      TableReference.JoinParenthesisTableReference((src.Join |> Option.ofObj |> Option.map (TableReference.FromCs)))
    | :? ScriptDom.JoinTableReference as src ->
      match src with
      | :? ScriptDom.QualifiedJoin as src->
        TableReference.JoinTableReference((JoinTableReference.QualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.JoinHint), (src.QualifiedJoinType), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.SecondTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)))))
      | :? ScriptDom.UnqualifiedJoin as src->
        TableReference.JoinTableReference((JoinTableReference.UnqualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.SecondTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.UnqualifiedJoinType))))
    | :? ScriptDom.OdbcQualifiedJoinTableReference as src ->
      TableReference.OdbcQualifiedJoinTableReference((src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)))
    | :? ScriptDom.TableReferenceWithAlias as src ->
      match src with
      | :? ScriptDom.AdHocTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.AdHocTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataSource |> Option.ofObj |> Option.map (AdHocDataSource.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectNameOrValueExpression.FromCs)))))
      | :? ScriptDom.BuiltInFunctionTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.BuiltInFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.FullTextTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.FullTextTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FullTextFunctionType), (src.Language |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TopN |> Option.ofObj |> Option.map (ValueExpression.FromCs)))))
      | :? ScriptDom.GlobalFunctionTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.GlobalFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.InternalOpenRowset as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.InternalOpenRowset((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.VarArgs |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))))
      | :? ScriptDom.NamedTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.NamedTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ForPath), (src.SchemaObject |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TableHints |> Seq.map (TableHint.FromCs) |> List.ofSeq), (src.TableSampleClause |> Option.ofObj |> Option.map (TableSampleClause.FromCs)), (src.TemporalClause |> Option.ofObj |> Option.map (TemporalClause.FromCs)))))
      | :? ScriptDom.OpenJsonTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenJsonTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RowPattern |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.SchemaDeclarationItems |> Seq.map (fun src -> SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.Variable |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))))
      | :? ScriptDom.OpenQueryTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenQueryTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LinkedServer |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Query |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
      | :? ScriptDom.OpenRowsetTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenRowsetTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataSource |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Password |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ProviderName |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ProviderString |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Query |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.UserId |> Option.ofObj |> Option.map (StringLiteral.FromCs)))))
      | :? ScriptDom.OpenXmlTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.OpenXmlTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Flags |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.RowPattern |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.SchemaDeclarationItems |> Seq.map (SchemaDeclarationItem.FromCs) |> List.ofSeq), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))))
      | :? ScriptDom.PivotedTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.PivotedTableReference((src.AggregateFunctionIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)), (src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.InColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PivotColumn |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.ValueColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.SemanticTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.SemanticTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.MatchedColumn |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.MatchedKey |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SemanticFunctionType), (src.SourceKey |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.TableReferenceWithAliasAndColumns as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.FromCs(src)))))
      | :? ScriptDom.UnpivotedTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.UnpivotedTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.InColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.PivotColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.ValueColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | :? ScriptDom.VariableTableReference as src->
        TableReference.TableReferenceWithAlias((TableReferenceWithAlias.VariableTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))))
and TableSwitchOption = (* IsAbstract = true , children = 1*)
  | LowPriorityLockWaitTableSwitchOption of optionKind:ScriptDom.TableSwitchOptionKind * options:(LowPriorityLockWaitOption) list
  member this.ToCs() : ScriptDom.TableSwitchOption =
    match this with
    | LowPriorityLockWaitTableSwitchOption(optionKind=aOptionKind; options=aOptions) ->
      let ret = ScriptDom.LowPriorityLockWaitTableSwitchOption()
      ret.OptionKind <- aOptionKind
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TableSwitchOption (* 404 *)
//// shared props TableSwitchOption 
  member this.OptionKind = 
    match this with
    | LowPriorityLockWaitTableSwitchOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.TableSwitchOption) : TableSwitchOption =
    match src with
    | :? ScriptDom.LowPriorityLockWaitTableSwitchOption as src ->
      TableSwitchOption.LowPriorityLockWaitTableSwitchOption((src.OptionKind), (src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))
and TriggerOption = (* IsAbstract = false , children = 1*)
  | Base of optionKind:ScriptDom.TriggerOptionKind
  | ExecuteAsTriggerOption of executeAsClause:ExecuteAsClause option * optionKind:ScriptDom.TriggerOptionKind
  member this.ToCs() : ScriptDom.TriggerOption =
    match this with
    | ExecuteAsTriggerOption(executeAsClause=aExecuteAsClause; optionKind=aOptionKind) ->
      let ret = ScriptDom.ExecuteAsTriggerOption()
      ret.ExecuteAsClause <- aExecuteAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.TriggerOption (* 404 *)
    | Base(optionKind=aOptionKind) ->

      let ret = ScriptDom.TriggerOption()
      ret.OptionKind <- aOptionKind
      ret
//// shared props TriggerOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | ExecuteAsTriggerOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.TriggerOption) : TriggerOption =
    match src with
    | :? ScriptDom.ExecuteAsTriggerOption as src ->
      TriggerOption.ExecuteAsTriggerOption((src.ExecuteAsClause |> Option.ofObj |> Option.map (ExecuteAsClause.FromCs)), (src.OptionKind))
    | _ -> (* :? ScriptDom.TriggerOption as src *)
      TriggerOption.Base(((src.OptionKind)))
and WhenClause = (* IsAbstract = true , children = 2*)
  | SearchedWhenClause of thenExpression:ScalarExpression option * whenExpression:BooleanExpression option
  | SimpleWhenClause of thenExpression:ScalarExpression option * whenExpression:ScalarExpression option
  member this.ToCs() : ScriptDom.WhenClause =
    match this with
    | SearchedWhenClause(thenExpression=aThenExpression; whenExpression=aWhenExpression) ->
      let ret = ScriptDom.SearchedWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WhenClause (* 404 *)
    | SimpleWhenClause(thenExpression=aThenExpression; whenExpression=aWhenExpression) ->
      let ret = ScriptDom.SimpleWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WhenClause (* 404 *)
//// shared props WhenClause 
  member this.ThenExpression = 
    match this with
    | SearchedWhenClause(thenExpression=thenExpression) -> thenExpression
    | SimpleWhenClause(thenExpression=thenExpression) -> thenExpression
  static member FromCs(src:ScriptDom.WhenClause) : WhenClause =
    match src with
    | :? ScriptDom.SearchedWhenClause as src ->
      WhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
    | :? ScriptDom.SimpleWhenClause as src ->
      WhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and WorkloadGroupParameter = (* IsAbstract = true , children = 2*)
  | WorkloadGroupImportanceParameter of parameterType:ScriptDom.WorkloadGroupParameterType * parameterValue:ScriptDom.ImportanceParameterType
  | WorkloadGroupResourceParameter of parameterType:ScriptDom.WorkloadGroupParameterType * parameterValue:Literal option
  member this.ToCs() : ScriptDom.WorkloadGroupParameter =
    match this with
    | WorkloadGroupImportanceParameter(parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.WorkloadGroupImportanceParameter()
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue
      ret :> ScriptDom.WorkloadGroupParameter (* 404 *)
    | WorkloadGroupResourceParameter(parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.WorkloadGroupResourceParameter()
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WorkloadGroupParameter (* 404 *)
//// shared props WorkloadGroupParameter 
  member this.ParameterType = 
    match this with
    | WorkloadGroupImportanceParameter(parameterType=parameterType) -> parameterType
    | WorkloadGroupResourceParameter(parameterType=parameterType) -> parameterType
  static member FromCs(src:ScriptDom.WorkloadGroupParameter) : WorkloadGroupParameter =
    match src with
    | :? ScriptDom.WorkloadGroupImportanceParameter as src ->
      WorkloadGroupParameter.WorkloadGroupImportanceParameter((src.ParameterType), (src.ParameterValue))
    | :? ScriptDom.WorkloadGroupResourceParameter as src ->
      WorkloadGroupParameter.WorkloadGroupResourceParameter((src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))
and XmlNamespacesElement = (* IsAbstract = true , children = 2*)
  | XmlNamespacesAliasElement of identifier:Identifier option * string:StringLiteral option
  | XmlNamespacesDefaultElement of string:StringLiteral option
  member this.ToCs() : ScriptDom.XmlNamespacesElement =
    match this with
    | XmlNamespacesAliasElement(identifier=aIdentifier; string=aString) ->
      let ret = ScriptDom.XmlNamespacesAliasElement()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.String <- aString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.XmlNamespacesElement (* 404 *)
    | XmlNamespacesDefaultElement(string=aString) ->
      let ret = ScriptDom.XmlNamespacesDefaultElement()
      ret.String <- aString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.XmlNamespacesElement (* 404 *)
//// shared props XmlNamespacesElement 
  member this.String = 
    match this with
    | XmlNamespacesAliasElement(string=string) -> string
    | XmlNamespacesDefaultElement(string=string) -> string
  static member FromCs(src:ScriptDom.XmlNamespacesElement) : XmlNamespacesElement =
    match src with
    | :? ScriptDom.XmlNamespacesAliasElement as src ->
      XmlNamespacesElement.XmlNamespacesAliasElement((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.String |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.XmlNamespacesDefaultElement as src ->
      XmlNamespacesElement.XmlNamespacesDefaultElement((src.String |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
and UpdateDeleteSpecificationBase = (* IsAbstract = true , children = 2*)
  | DeleteSpecification of fromClause:FromClause option * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * target:TableReference option * topRowFilter:TopRowFilter option * whereClause:WhereClause option
  | UpdateSpecification of fromClause:FromClause option * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * setClauses:(SetClause) list * target:TableReference option * topRowFilter:TopRowFilter option * whereClause:WhereClause option
  member this.ToCs() : ScriptDom.UpdateDeleteSpecificationBase =
    match this with
    | DeleteSpecification(fromClause=aFromClause; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; target=aTarget; topRowFilter=aTopRowFilter; whereClause=aWhereClause) ->
      let ret = ScriptDom.DeleteSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.UpdateDeleteSpecificationBase (* 404 *)
    | UpdateSpecification(fromClause=aFromClause; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; setClauses=aSetClauses; target=aTarget; topRowFilter=aTopRowFilter; whereClause=aWhereClause) ->
      let ret = ScriptDom.UpdateSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSetClauses do ret.SetClauses.Add (e.ToCs())
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.UpdateDeleteSpecificationBase (* 404 *)
//// shared props UpdateDeleteSpecificationBase 
  member this.FromClause = 
    match this with
    | DeleteSpecification(fromClause=fromClause) -> fromClause
    | UpdateSpecification(fromClause=fromClause) -> fromClause
  member this.OutputClause = 
    match this with
    | DeleteSpecification(outputClause=outputClause) -> outputClause
    | UpdateSpecification(outputClause=outputClause) -> outputClause
  member this.OutputIntoClause = 
    match this with
    | DeleteSpecification(outputIntoClause=outputIntoClause) -> outputIntoClause
    | UpdateSpecification(outputIntoClause=outputIntoClause) -> outputIntoClause
  member this.Target = 
    match this with
    | DeleteSpecification(target=target) -> target
    | UpdateSpecification(target=target) -> target
  member this.TopRowFilter = 
    match this with
    | DeleteSpecification(topRowFilter=topRowFilter) -> topRowFilter
    | UpdateSpecification(topRowFilter=topRowFilter) -> topRowFilter
  member this.WhereClause = 
    match this with
    | DeleteSpecification(whereClause=whereClause) -> whereClause
    | UpdateSpecification(whereClause=whereClause) -> whereClause
  static member FromCs(src:ScriptDom.UpdateDeleteSpecificationBase) : UpdateDeleteSpecificationBase =
    match src with
    | :? ScriptDom.DeleteSpecification as src ->
      UpdateDeleteSpecificationBase.DeleteSpecification((src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))
    | :? ScriptDom.UpdateSpecification as src ->
      UpdateDeleteSpecificationBase.UpdateSpecification((src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.SetClauses |> Seq.map (SetClause.FromCs) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))
and ParameterizedDataTypeReference = (* IsAbstract = true , children = 2*)
  | SqlDataTypeReference of name:SchemaObjectName option * parameters:(Literal) list * sqlDataTypeOption:ScriptDom.SqlDataTypeOption
  | UserDataTypeReference of name:SchemaObjectName option * parameters:(Literal) list
  member this.ToCs() : ScriptDom.ParameterizedDataTypeReference =
    match this with
    | SqlDataTypeReference(name=aName; parameters=aParameters; sqlDataTypeOption=aSqlDataTypeOption) ->
      let ret = ScriptDom.SqlDataTypeReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.SqlDataTypeOption <- aSqlDataTypeOption
      ret :> ScriptDom.ParameterizedDataTypeReference (* 404 *)
    | UserDataTypeReference(name=aName; parameters=aParameters) ->
      let ret = ScriptDom.UserDataTypeReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.ParameterizedDataTypeReference (* 404 *)
//// shared props ParameterizedDataTypeReference 
  member this.Name = 
    match this with
    | SqlDataTypeReference(name=name) -> name
    | UserDataTypeReference(name=name) -> name
  member this.Parameters = 
    match this with
    | SqlDataTypeReference(parameters=parameters) -> parameters
    | UserDataTypeReference(parameters=parameters) -> parameters
  static member FromCs(src:ScriptDom.ParameterizedDataTypeReference) : ParameterizedDataTypeReference =
    match src with
    | :? ScriptDom.SqlDataTypeReference as src ->
      ParameterizedDataTypeReference.SqlDataTypeReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Parameters |> Seq.map (Literal.FromCs) |> List.ofSeq), (src.SqlDataTypeOption))
    | :? ScriptDom.UserDataTypeReference as src ->
      ParameterizedDataTypeReference.UserDataTypeReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Parameters |> Seq.map (Literal.FromCs) |> List.ofSeq))
and HadrDatabaseOption = (* IsAbstract = false , children = 1*)
  | Base of hadrOption:ScriptDom.HadrDatabaseOptionKind * optionKind:ScriptDom.DatabaseOptionKind
  | HadrAvailabilityGroupDatabaseOption of groupName:Identifier option * hadrOption:ScriptDom.HadrDatabaseOptionKind * optionKind:ScriptDom.DatabaseOptionKind
  member this.ToCs() : ScriptDom.HadrDatabaseOption =
    match this with
    | HadrAvailabilityGroupDatabaseOption(groupName=aGroupName; hadrOption=aHadrOption; optionKind=aOptionKind) ->
      let ret = ScriptDom.HadrAvailabilityGroupDatabaseOption()
      ret.GroupName <- aGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.HadrOption <- aHadrOption
      ret.OptionKind <- aOptionKind
      ret :> ScriptDom.HadrDatabaseOption (* 404 *)
    | Base(hadrOption=aHadrOption; optionKind=aOptionKind) ->

      let ret = ScriptDom.HadrDatabaseOption()
      ret.HadrOption <- aHadrOption
      ret.OptionKind <- aOptionKind
      ret
//// shared props HadrDatabaseOption 
  member this.HadrOption = 
    match this with
    | Base (hadrOption=hadrOption) -> hadrOption
    | HadrAvailabilityGroupDatabaseOption(hadrOption=hadrOption) -> hadrOption
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | HadrAvailabilityGroupDatabaseOption(optionKind=optionKind) -> optionKind
  static member FromCs(src:ScriptDom.HadrDatabaseOption) : HadrDatabaseOption =
    match src with
    | :? ScriptDom.HadrAvailabilityGroupDatabaseOption as src ->
      HadrDatabaseOption.HadrAvailabilityGroupDatabaseOption((src.GroupName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.HadrOption), (src.OptionKind))
    | _ -> (* :? ScriptDom.HadrDatabaseOption as src *)
      HadrDatabaseOption.Base(((src.HadrOption), (src.OptionKind)))
and OnOffDatabaseOption = (* IsAbstract = false , children = 1*)
  | Base of optionKind:ScriptDom.DatabaseOptionKind * optionState:ScriptDom.OptionState
  | AutoCreateStatisticsDatabaseOption of hasIncremental:bool * incrementalState:ScriptDom.OptionState * optionKind:ScriptDom.DatabaseOptionKind * optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.OnOffDatabaseOption =
    match this with
    | AutoCreateStatisticsDatabaseOption(hasIncremental=aHasIncremental; incrementalState=aIncrementalState; optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.AutoCreateStatisticsDatabaseOption()
      ret.HasIncremental <- aHasIncremental
      ret.IncrementalState <- aIncrementalState
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.OnOffDatabaseOption (* 404 *)
    | Base(optionKind=aOptionKind; optionState=aOptionState) ->

      let ret = ScriptDom.OnOffDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret
//// shared props OnOffDatabaseOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | AutoCreateStatisticsDatabaseOption(optionKind=optionKind) -> optionKind
  member this.OptionState = 
    match this with
    | Base (optionState=optionState) -> optionState
    | AutoCreateStatisticsDatabaseOption(optionState=optionState) -> optionState
  static member FromCs(src:ScriptDom.OnOffDatabaseOption) : OnOffDatabaseOption =
    match src with
    | :? ScriptDom.AutoCreateStatisticsDatabaseOption as src ->
      OnOffDatabaseOption.AutoCreateStatisticsDatabaseOption((src.HasIncremental), (src.IncrementalState), (src.OptionKind), (src.OptionState))
    | _ -> (* :? ScriptDom.OnOffDatabaseOption as src *)
      OnOffDatabaseOption.Base(((src.OptionKind), (src.OptionState)))
and IndexStateOption = (* IsAbstract = false , children = 2*)
  | Base of optionKind:ScriptDom.IndexOptionKind * optionState:ScriptDom.OptionState
  | IgnoreDupKeyIndexOption of optionKind:ScriptDom.IndexOptionKind * optionState:ScriptDom.OptionState * suppressMessagesOption:(bool) option
  | OnlineIndexOption of lowPriorityLockWaitOption:OnlineIndexLowPriorityLockWaitOption option * optionKind:ScriptDom.IndexOptionKind * optionState:ScriptDom.OptionState
  member this.ToCs() : ScriptDom.IndexStateOption =
    match this with
    | IgnoreDupKeyIndexOption(optionKind=aOptionKind; optionState=aOptionState; suppressMessagesOption=aSuppressMessagesOption) ->
      let ret = ScriptDom.IgnoreDupKeyIndexOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret.SuppressMessagesOption <- Option.toNullable aSuppressMessagesOption
      ret :> ScriptDom.IndexStateOption (* 404 *)
    | OnlineIndexOption(lowPriorityLockWaitOption=aLowPriorityLockWaitOption; optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.OnlineIndexOption()
      ret.LowPriorityLockWaitOption <- aLowPriorityLockWaitOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret :> ScriptDom.IndexStateOption (* 404 *)
    | Base(optionKind=aOptionKind; optionState=aOptionState) ->

      let ret = ScriptDom.IndexStateOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret
//// shared props IndexStateOption 
  member this.OptionKind = 
    match this with
    | Base (optionKind=optionKind) -> optionKind
    | IgnoreDupKeyIndexOption(optionKind=optionKind) -> optionKind
    | OnlineIndexOption(optionKind=optionKind) -> optionKind
  member this.OptionState = 
    match this with
    | Base (optionState=optionState) -> optionState
    | IgnoreDupKeyIndexOption(optionState=optionState) -> optionState
    | OnlineIndexOption(optionState=optionState) -> optionState
  static member FromCs(src:ScriptDom.IndexStateOption) : IndexStateOption =
    match src with
    | :? ScriptDom.IgnoreDupKeyIndexOption as src ->
      IndexStateOption.IgnoreDupKeyIndexOption((src.OptionKind), (src.OptionState), (Option.ofNullable (src.SuppressMessagesOption)))
    | :? ScriptDom.OnlineIndexOption as src ->
      IndexStateOption.OnlineIndexOption((src.LowPriorityLockWaitOption |> Option.ofObj |> Option.map (OnlineIndexLowPriorityLockWaitOption.FromCs)), (src.OptionKind), (src.OptionState))
    | _ -> (* :? ScriptDom.IndexStateOption as src *)
      IndexStateOption.Base(((src.OptionKind), (src.OptionState)))
and SchemaObjectName = (* IsAbstract = false , children = 2*)
  | Base of baseIdentifier:Identifier option * count:Int32 * databaseIdentifier:Identifier option * identifiers:(Identifier) list * schemaIdentifier:Identifier option * serverIdentifier:Identifier option
  | ChildObjectName of baseIdentifier:Identifier option * childIdentifier:Identifier option * count:Int32 * databaseIdentifier:Identifier option * identifiers:(Identifier) list * schemaIdentifier:Identifier option * serverIdentifier:Identifier option
  | SchemaObjectNameSnippet of baseIdentifier:Identifier option * count:Int32 * databaseIdentifier:Identifier option * identifiers:(Identifier) list * schemaIdentifier:Identifier option * script:String * serverIdentifier:Identifier option
  member this.ToCs() : ScriptDom.SchemaObjectName =
    match this with
    | ChildObjectName(baseIdentifier=aBaseIdentifier; childIdentifier=aChildIdentifier; count=aCount; databaseIdentifier=aDatabaseIdentifier; identifiers=aIdentifiers; schemaIdentifier=aSchemaIdentifier; serverIdentifier=aServerIdentifier) ->
      let ret = ScriptDom.ChildObjectName()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop ChildIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
       // Skipping prop ServerIdentifier - it is Readonly
      ret :> ScriptDom.SchemaObjectName (* 404 *)
    | SchemaObjectNameSnippet(baseIdentifier=aBaseIdentifier; count=aCount; databaseIdentifier=aDatabaseIdentifier; identifiers=aIdentifiers; schemaIdentifier=aSchemaIdentifier; script=aScript; serverIdentifier=aServerIdentifier) ->
      let ret = ScriptDom.SchemaObjectNameSnippet()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
      ret.Script <- aScript
       // Skipping prop ServerIdentifier - it is Readonly
      ret :> ScriptDom.SchemaObjectName (* 404 *)
    | Base(baseIdentifier=aBaseIdentifier; count=aCount; databaseIdentifier=aDatabaseIdentifier; identifiers=aIdentifiers; schemaIdentifier=aSchemaIdentifier; serverIdentifier=aServerIdentifier) ->

      let ret = ScriptDom.SchemaObjectName()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
       // Skipping prop ServerIdentifier - it is Readonly
      ret
//// shared props SchemaObjectName 
  member this.BaseIdentifier = 
    match this with
    | Base (baseIdentifier=baseIdentifier) -> baseIdentifier
    | ChildObjectName(baseIdentifier=baseIdentifier) -> baseIdentifier
    | SchemaObjectNameSnippet(baseIdentifier=baseIdentifier) -> baseIdentifier
  member this.Count = 
    match this with
    | Base (count=count) -> count
    | ChildObjectName(count=count) -> count
    | SchemaObjectNameSnippet(count=count) -> count
  member this.DatabaseIdentifier = 
    match this with
    | Base (databaseIdentifier=databaseIdentifier) -> databaseIdentifier
    | ChildObjectName(databaseIdentifier=databaseIdentifier) -> databaseIdentifier
    | SchemaObjectNameSnippet(databaseIdentifier=databaseIdentifier) -> databaseIdentifier
  member this.Identifiers = 
    match this with
    | Base (identifiers=identifiers) -> identifiers
    | ChildObjectName(identifiers=identifiers) -> identifiers
    | SchemaObjectNameSnippet(identifiers=identifiers) -> identifiers
  member this.SchemaIdentifier = 
    match this with
    | Base (schemaIdentifier=schemaIdentifier) -> schemaIdentifier
    | ChildObjectName(schemaIdentifier=schemaIdentifier) -> schemaIdentifier
    | SchemaObjectNameSnippet(schemaIdentifier=schemaIdentifier) -> schemaIdentifier
  member this.ServerIdentifier = 
    match this with
    | Base (serverIdentifier=serverIdentifier) -> serverIdentifier
    | ChildObjectName(serverIdentifier=serverIdentifier) -> serverIdentifier
    | SchemaObjectNameSnippet(serverIdentifier=serverIdentifier) -> serverIdentifier
  static member FromCs(src:ScriptDom.SchemaObjectName) : SchemaObjectName =
    match src with
    | :? ScriptDom.ChildObjectName as src ->
      SchemaObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ChildIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.SchemaObjectNameSnippet as src ->
      SchemaObjectName.SchemaObjectNameSnippet((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Script), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | _ -> (* :? ScriptDom.SchemaObjectName as src *)
      SchemaObjectName.Base(((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs))))
and PrimaryExpression = (* IsAbstract = true , children = 23*)
  | AtTimeZoneCall of collation:Identifier option * dateValue:ScalarExpression option * timeZone:ScalarExpression option
  | CaseExpression of caseExpression:CaseExpression
  | CastCall of collation:Identifier option * dataType:DataTypeReference option * parameter:ScalarExpression option
  | CoalesceExpression of collation:Identifier option * expressions:(ScalarExpression) list
  | ColumnReferenceExpression of collation:Identifier option * columnType:ScriptDom.ColumnType * multiPartIdentifier:MultiPartIdentifier option
  | ConvertCall of collation:Identifier option * dataType:DataTypeReference option * parameter:ScalarExpression option * style:ScalarExpression option
  | FunctionCall of callTarget:CallTarget option * collation:Identifier option * functionName:Identifier option * overClause:OverClause option * parameters:(ScalarExpression) list * uniqueRowFilter:ScriptDom.UniqueRowFilter * withinGroupClause:WithinGroupClause option
  | IIfCall of collation:Identifier option * elseExpression:ScalarExpression option * predicate:BooleanExpression option * thenExpression:ScalarExpression option
  | LeftFunctionCall of collation:Identifier option * parameters:(ScalarExpression) list
  | NextValueForExpression of collation:Identifier option * overClause:OverClause option * sequenceName:SchemaObjectName option
  | NullIfExpression of collation:Identifier option * firstExpression:ScalarExpression option * secondExpression:ScalarExpression option
  | OdbcFunctionCall of collation:Identifier option * name:Identifier option * parameters:(ScalarExpression) list * parametersUsed:bool
  | ParameterlessCall of collation:Identifier option * parameterlessCallType:ScriptDom.ParameterlessCallType
  | ParenthesisExpression of collation:Identifier option * expression:ScalarExpression option
  | ParseCall of collation:Identifier option * culture:ScalarExpression option * dataType:DataTypeReference option * stringValue:ScalarExpression option
  | PartitionFunctionCall of collation:Identifier option * databaseName:Identifier option * functionName:Identifier option * parameters:(ScalarExpression) list
  | RightFunctionCall of collation:Identifier option * parameters:(ScalarExpression) list
  | ScalarSubquery of collation:Identifier option * queryExpression:QueryExpression option
  | TryCastCall of collation:Identifier option * dataType:DataTypeReference option * parameter:ScalarExpression option
  | TryConvertCall of collation:Identifier option * dataType:DataTypeReference option * parameter:ScalarExpression option * style:ScalarExpression option
  | TryParseCall of collation:Identifier option * culture:ScalarExpression option * dataType:DataTypeReference option * stringValue:ScalarExpression option
  | UserDefinedTypePropertyAccess of callTarget:CallTarget option * collation:Identifier option * propertyName:Identifier option
  | ValueExpression of valueExpression:ValueExpression
  member this.ToCs() : ScriptDom.PrimaryExpression =
    match this with
    | AtTimeZoneCall(collation=aCollation; dateValue=aDateValue; timeZone=aTimeZone) ->
      let ret = ScriptDom.AtTimeZoneCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DateValue <- aDateValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TimeZone <- aTimeZone |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | CaseExpression(x) -> x.ToCs() :> ScriptDom.PrimaryExpression (* 414 *)
    | CastCall(collation=aCollation; dataType=aDataType; parameter=aParameter) ->
      let ret = ScriptDom.CastCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | CoalesceExpression(collation=aCollation; expressions=aExpressions) ->
      let ret = ScriptDom.CoalesceExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aExpressions do ret.Expressions.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ColumnReferenceExpression(collation=aCollation; columnType=aColumnType; multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.ColumnReferenceExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnType <- aColumnType
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ConvertCall(collation=aCollation; dataType=aDataType; parameter=aParameter; style=aStyle) ->
      let ret = ScriptDom.ConvertCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Style <- aStyle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | FunctionCall(callTarget=aCallTarget; collation=aCollation; functionName=aFunctionName; overClause=aOverClause; parameters=aParameters; uniqueRowFilter=aUniqueRowFilter; withinGroupClause=aWithinGroupClause) ->
      let ret = ScriptDom.FunctionCall()
      ret.CallTarget <- aCallTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionName <- aFunctionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OverClause <- aOverClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.UniqueRowFilter <- aUniqueRowFilter
      ret.WithinGroupClause <- aWithinGroupClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | IIfCall(collation=aCollation; elseExpression=aElseExpression; predicate=aPredicate; thenExpression=aThenExpression) ->
      let ret = ScriptDom.IIfCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElseExpression <- aElseExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Predicate <- aPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | LeftFunctionCall(collation=aCollation; parameters=aParameters) ->
      let ret = ScriptDom.LeftFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | NextValueForExpression(collation=aCollation; overClause=aOverClause; sequenceName=aSequenceName) ->
      let ret = ScriptDom.NextValueForExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OverClause <- aOverClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SequenceName <- aSequenceName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | NullIfExpression(collation=aCollation; firstExpression=aFirstExpression; secondExpression=aSecondExpression) ->
      let ret = ScriptDom.NullIfExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FirstExpression <- aFirstExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondExpression <- aSecondExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | OdbcFunctionCall(collation=aCollation; name=aName; parameters=aParameters; parametersUsed=aParametersUsed) ->
      let ret = ScriptDom.OdbcFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ParametersUsed <- aParametersUsed
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ParameterlessCall(collation=aCollation; parameterlessCallType=aParameterlessCallType) ->
      let ret = ScriptDom.ParameterlessCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterlessCallType <- aParameterlessCallType
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ParenthesisExpression(collation=aCollation; expression=aExpression) ->
      let ret = ScriptDom.ParenthesisExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ParseCall(collation=aCollation; culture=aCulture; dataType=aDataType; stringValue=aStringValue) ->
      let ret = ScriptDom.ParseCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Culture <- aCulture |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StringValue <- aStringValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | PartitionFunctionCall(collation=aCollation; databaseName=aDatabaseName; functionName=aFunctionName; parameters=aParameters) ->
      let ret = ScriptDom.PartitionFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionName <- aFunctionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | RightFunctionCall(collation=aCollation; parameters=aParameters) ->
      let ret = ScriptDom.RightFunctionCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ScalarSubquery(collation=aCollation; queryExpression=aQueryExpression) ->
      let ret = ScriptDom.ScalarSubquery()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | TryCastCall(collation=aCollation; dataType=aDataType; parameter=aParameter) ->
      let ret = ScriptDom.TryCastCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | TryConvertCall(collation=aCollation; dataType=aDataType; parameter=aParameter; style=aStyle) ->
      let ret = ScriptDom.TryConvertCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Parameter <- aParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Style <- aStyle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | TryParseCall(collation=aCollation; culture=aCulture; dataType=aDataType; stringValue=aStringValue) ->
      let ret = ScriptDom.TryParseCall()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Culture <- aCulture |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StringValue <- aStringValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | UserDefinedTypePropertyAccess(callTarget=aCallTarget; collation=aCollation; propertyName=aPropertyName) ->
      let ret = ScriptDom.UserDefinedTypePropertyAccess()
      ret.CallTarget <- aCallTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.PrimaryExpression (* 404 *)
    | ValueExpression(x) -> x.ToCs() :> ScriptDom.PrimaryExpression (* 414 *)
//// shared props PrimaryExpression 
  member this.Collation = 
    match this with
    | AtTimeZoneCall(collation=collation) -> collation
    | CaseExpression _ as x -> x.Collation
    | CastCall(collation=collation) -> collation
    | CoalesceExpression(collation=collation) -> collation
    | ColumnReferenceExpression(collation=collation) -> collation
    | ConvertCall(collation=collation) -> collation
    | FunctionCall(collation=collation) -> collation
    | IIfCall(collation=collation) -> collation
    | LeftFunctionCall(collation=collation) -> collation
    | NextValueForExpression(collation=collation) -> collation
    | NullIfExpression(collation=collation) -> collation
    | OdbcFunctionCall(collation=collation) -> collation
    | ParameterlessCall(collation=collation) -> collation
    | ParenthesisExpression(collation=collation) -> collation
    | ParseCall(collation=collation) -> collation
    | PartitionFunctionCall(collation=collation) -> collation
    | RightFunctionCall(collation=collation) -> collation
    | ScalarSubquery(collation=collation) -> collation
    | TryCastCall(collation=collation) -> collation
    | TryConvertCall(collation=collation) -> collation
    | TryParseCall(collation=collation) -> collation
    | UserDefinedTypePropertyAccess(collation=collation) -> collation
    | ValueExpression _ as x -> x.Collation
  static member FromCs(src:ScriptDom.PrimaryExpression) : PrimaryExpression =
    match src with
    | :? ScriptDom.AtTimeZoneCall as src ->
      PrimaryExpression.AtTimeZoneCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DateValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TimeZone |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.CaseExpression as src ->
      match src with
      | :? ScriptDom.SearchedCaseExpression as src->
        PrimaryExpression.CaseExpression((CaseExpression.SearchedCaseExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ElseExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenClauses |> Seq.map (fun src -> SearchedWhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))) |> List.ofSeq))))
      | :? ScriptDom.SimpleCaseExpression as src->
        PrimaryExpression.CaseExpression((CaseExpression.SimpleCaseExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ElseExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.InputExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenClauses |> Seq.map (fun src -> SimpleWhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))))
    | :? ScriptDom.CastCall as src ->
      PrimaryExpression.CastCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.CoalesceExpression as src ->
      PrimaryExpression.CoalesceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.ColumnReferenceExpression as src ->
      PrimaryExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
    | :? ScriptDom.ConvertCall as src ->
      PrimaryExpression.ConvertCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Style |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.FunctionCall as src ->
      PrimaryExpression.FunctionCall((src.CallTarget |> Option.ofObj |> Option.map (CallTarget.FromCs)), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FunctionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OverClause |> Option.ofObj |> Option.map (OverClause.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.UniqueRowFilter), (src.WithinGroupClause |> Option.ofObj |> Option.map (WithinGroupClause.FromCs)))
    | :? ScriptDom.IIfCall as src ->
      PrimaryExpression.IIfCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ElseExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Predicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.LeftFunctionCall as src ->
      PrimaryExpression.LeftFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.NextValueForExpression as src ->
      PrimaryExpression.NextValueForExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OverClause |> Option.ofObj |> Option.map (OverClause.FromCs)), (src.SequenceName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.NullIfExpression as src ->
      PrimaryExpression.NullIfExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FirstExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SecondExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.OdbcFunctionCall as src ->
      PrimaryExpression.OdbcFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ParametersUsed))
    | :? ScriptDom.ParameterlessCall as src ->
      PrimaryExpression.ParameterlessCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ParameterlessCallType))
    | :? ScriptDom.ParenthesisExpression as src ->
      PrimaryExpression.ParenthesisExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.ParseCall as src ->
      PrimaryExpression.ParseCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Culture |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.StringValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.PartitionFunctionCall as src ->
      PrimaryExpression.PartitionFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FunctionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.RightFunctionCall as src ->
      PrimaryExpression.RightFunctionCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.ScalarSubquery as src ->
      PrimaryExpression.ScalarSubquery((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
    | :? ScriptDom.TryCastCall as src ->
      PrimaryExpression.TryCastCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.TryConvertCall as src ->
      PrimaryExpression.TryConvertCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Parameter |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Style |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.TryParseCall as src ->
      PrimaryExpression.TryParseCall((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Culture |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.StringValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.UserDefinedTypePropertyAccess as src ->
      PrimaryExpression.UserDefinedTypePropertyAccess((src.CallTarget |> Option.ofObj |> Option.map (CallTarget.FromCs)), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.ValueExpression as src ->
      match src with
      | :? ScriptDom.GlobalVariableExpression as src->
        PrimaryExpression.ValueExpression((ValueExpression.GlobalVariableExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))))
      | :? ScriptDom.Literal as src->
        PrimaryExpression.ValueExpression((ValueExpression.Literal((Literal.FromCs(src)))))
      | :? ScriptDom.VariableReference as src->
        PrimaryExpression.ValueExpression((ValueExpression.VariableReference((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))))
and AlterCreateEndpointStatementBase = (* IsAbstract = true , children = 2*)
  | AlterEndpointStatement of affinity:EndpointAffinity option * endpointType:ScriptDom.EndpointType * name:Identifier option * payloadOptions:(PayloadOption) list * protocol:ScriptDom.EndpointProtocol * protocolOptions:(EndpointProtocolOption) list * state:ScriptDom.EndpointState
  | CreateEndpointStatement of affinity:EndpointAffinity option * endpointType:ScriptDom.EndpointType * name:Identifier option * owner:Identifier option * payloadOptions:(PayloadOption) list * protocol:ScriptDom.EndpointProtocol * protocolOptions:(EndpointProtocolOption) list * state:ScriptDom.EndpointState
  member this.ToCs() : ScriptDom.AlterCreateEndpointStatementBase =
    match this with
    | AlterEndpointStatement(affinity=aAffinity; endpointType=aEndpointType; name=aName; payloadOptions=aPayloadOptions; protocol=aProtocol; protocolOptions=aProtocolOptions; state=aState) ->
      let ret = ScriptDom.AlterEndpointStatement()
      ret.Affinity <- aAffinity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EndpointType <- aEndpointType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPayloadOptions do ret.PayloadOptions.Add (e.ToCs())
      ret.Protocol <- aProtocol
      for e in aProtocolOptions do ret.ProtocolOptions.Add (e.ToCs())
      ret.State <- aState
      ret :> ScriptDom.AlterCreateEndpointStatementBase (* 404 *)
    | CreateEndpointStatement(affinity=aAffinity; endpointType=aEndpointType; name=aName; owner=aOwner; payloadOptions=aPayloadOptions; protocol=aProtocol; protocolOptions=aProtocolOptions; state=aState) ->
      let ret = ScriptDom.CreateEndpointStatement()
      ret.Affinity <- aAffinity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EndpointType <- aEndpointType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPayloadOptions do ret.PayloadOptions.Add (e.ToCs())
      ret.Protocol <- aProtocol
      for e in aProtocolOptions do ret.ProtocolOptions.Add (e.ToCs())
      ret.State <- aState
      ret :> ScriptDom.AlterCreateEndpointStatementBase (* 404 *)
//// shared props AlterCreateEndpointStatementBase 
  member this.Affinity = 
    match this with
    | AlterEndpointStatement(affinity=affinity) -> affinity
    | CreateEndpointStatement(affinity=affinity) -> affinity
  member this.EndpointType = 
    match this with
    | AlterEndpointStatement(endpointType=endpointType) -> endpointType
    | CreateEndpointStatement(endpointType=endpointType) -> endpointType
  member this.Name = 
    match this with
    | AlterEndpointStatement(name=name) -> name
    | CreateEndpointStatement(name=name) -> name
  member this.PayloadOptions = 
    match this with
    | AlterEndpointStatement(payloadOptions=payloadOptions) -> payloadOptions
    | CreateEndpointStatement(payloadOptions=payloadOptions) -> payloadOptions
  member this.Protocol = 
    match this with
    | AlterEndpointStatement(protocol=protocol) -> protocol
    | CreateEndpointStatement(protocol=protocol) -> protocol
  member this.ProtocolOptions = 
    match this with
    | AlterEndpointStatement(protocolOptions=protocolOptions) -> protocolOptions
    | CreateEndpointStatement(protocolOptions=protocolOptions) -> protocolOptions
  member this.State = 
    match this with
    | AlterEndpointStatement(state=state) -> state
    | CreateEndpointStatement(state=state) -> state
  static member FromCs(src:ScriptDom.AlterCreateEndpointStatementBase) : AlterCreateEndpointStatementBase =
    match src with
    | :? ScriptDom.AlterEndpointStatement as src ->
      AlterCreateEndpointStatementBase.AlterEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (EndpointAffinity.FromCs)), (src.EndpointType), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PayloadOptions |> Seq.map (PayloadOption.FromCs) |> List.ofSeq), (src.Protocol), (src.ProtocolOptions |> Seq.map (EndpointProtocolOption.FromCs) |> List.ofSeq), (src.State))
    | :? ScriptDom.CreateEndpointStatement as src ->
      AlterCreateEndpointStatementBase.CreateEndpointStatement((src.Affinity |> Option.ofObj |> Option.map (EndpointAffinity.FromCs)), (src.EndpointType), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PayloadOptions |> Seq.map (PayloadOption.FromCs) |> List.ofSeq), (src.Protocol), (src.ProtocolOptions |> Seq.map (EndpointProtocolOption.FromCs) |> List.ofSeq), (src.State))
and AlterCreateServiceStatementBase = (* IsAbstract = true , children = 2*)
  | AlterServiceStatement of name:Identifier option * queueName:SchemaObjectName option * serviceContracts:(ServiceContract) list
  | CreateServiceStatement of name:Identifier option * owner:Identifier option * queueName:SchemaObjectName option * serviceContracts:(ServiceContract) list
  member this.ToCs() : ScriptDom.AlterCreateServiceStatementBase =
    match this with
    | AlterServiceStatement(name=aName; queueName=aQueueName; serviceContracts=aServiceContracts) ->
      let ret = ScriptDom.AlterServiceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aServiceContracts do ret.ServiceContracts.Add (e.ToCs())
      ret :> ScriptDom.AlterCreateServiceStatementBase (* 404 *)
    | CreateServiceStatement(name=aName; owner=aOwner; queueName=aQueueName; serviceContracts=aServiceContracts) ->
      let ret = ScriptDom.CreateServiceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aServiceContracts do ret.ServiceContracts.Add (e.ToCs())
      ret :> ScriptDom.AlterCreateServiceStatementBase (* 404 *)
//// shared props AlterCreateServiceStatementBase 
  member this.Name = 
    match this with
    | AlterServiceStatement(name=name) -> name
    | CreateServiceStatement(name=name) -> name
  member this.QueueName = 
    match this with
    | AlterServiceStatement(queueName=queueName) -> queueName
    | CreateServiceStatement(queueName=queueName) -> queueName
  member this.ServiceContracts = 
    match this with
    | AlterServiceStatement(serviceContracts=serviceContracts) -> serviceContracts
    | CreateServiceStatement(serviceContracts=serviceContracts) -> serviceContracts
  static member FromCs(src:ScriptDom.AlterCreateServiceStatementBase) : AlterCreateServiceStatementBase =
    match src with
    | :? ScriptDom.AlterServiceStatement as src ->
      AlterCreateServiceStatementBase.AlterServiceStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueueName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.CreateServiceStatement as src ->
      AlterCreateServiceStatementBase.CreateServiceStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueueName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ServiceContracts |> Seq.map (fun src -> ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq))
and AlterDatabaseScopedConfigurationStatement = (* IsAbstract = true , children = 2*)
  | AlterDatabaseScopedConfigurationClearStatement of option:DatabaseConfigurationClearOption option * secondary:bool
  | AlterDatabaseScopedConfigurationSetStatement of option:DatabaseConfigurationSetOption option * secondary:bool
  member this.ToCs() : ScriptDom.AlterDatabaseScopedConfigurationStatement =
    match this with
    | AlterDatabaseScopedConfigurationClearStatement(option=aOption; secondary=aSecondary) ->
      let ret = ScriptDom.AlterDatabaseScopedConfigurationClearStatement()
      ret.Option <- aOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secondary <- aSecondary
      ret :> ScriptDom.AlterDatabaseScopedConfigurationStatement (* 404 *)
    | AlterDatabaseScopedConfigurationSetStatement(option=aOption; secondary=aSecondary) ->
      let ret = ScriptDom.AlterDatabaseScopedConfigurationSetStatement()
      ret.Option <- aOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secondary <- aSecondary
      ret :> ScriptDom.AlterDatabaseScopedConfigurationStatement (* 404 *)
//// shared props AlterDatabaseScopedConfigurationStatement 
  member this.Secondary = 
    match this with
    | AlterDatabaseScopedConfigurationClearStatement(secondary=secondary) -> secondary
    | AlterDatabaseScopedConfigurationSetStatement(secondary=secondary) -> secondary
  static member FromCs(src:ScriptDom.AlterDatabaseScopedConfigurationStatement) : AlterDatabaseScopedConfigurationStatement =
    match src with
    | :? ScriptDom.AlterDatabaseScopedConfigurationClearStatement as src ->
      AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationClearStatement((src.Option |> Option.ofObj |> Option.map (DatabaseConfigurationClearOption.FromCs)), (src.Secondary))
    | :? ScriptDom.AlterDatabaseScopedConfigurationSetStatement as src ->
      AlterDatabaseScopedConfigurationStatement.AlterDatabaseScopedConfigurationSetStatement((src.Option |> Option.ofObj |> Option.map (DatabaseConfigurationSetOption.FromCs)), (src.Secondary))
and AlterDatabaseStatement = (* IsAbstract = true , children = 10*)
  | AlterDatabaseAddFileGroupStatement of containsFileStream:bool * containsMemoryOptimizedData:bool * databaseName:Identifier option * fileGroup:Identifier option * useCurrent:bool
  | AlterDatabaseAddFileStatement of databaseName:Identifier option * fileDeclarations:(FileDeclaration) list * fileGroup:Identifier option * isLog:bool * useCurrent:bool
  | AlterDatabaseCollateStatement of collation:Identifier option * databaseName:Identifier option * useCurrent:bool
  | AlterDatabaseModifyFileGroupStatement of databaseName:Identifier option * fileGroup:Identifier option * makeDefault:bool * newFileGroupName:Identifier option * termination:AlterDatabaseTermination option * updatabilityOption:ScriptDom.ModifyFileGroupOption * useCurrent:bool
  | AlterDatabaseModifyFileStatement of databaseName:Identifier option * fileDeclaration:FileDeclaration option * useCurrent:bool
  | AlterDatabaseModifyNameStatement of databaseName:Identifier option * newDatabaseName:Identifier option * useCurrent:bool
  | AlterDatabaseRebuildLogStatement of databaseName:Identifier option * fileDeclaration:FileDeclaration option * useCurrent:bool
  | AlterDatabaseRemoveFileGroupStatement of databaseName:Identifier option * fileGroup:Identifier option * useCurrent:bool
  | AlterDatabaseRemoveFileStatement of databaseName:Identifier option * file:Identifier option * useCurrent:bool
  | AlterDatabaseSetStatement of databaseName:Identifier option * options:(DatabaseOption) list * termination:AlterDatabaseTermination option * useCurrent:bool
  member this.ToCs() : ScriptDom.AlterDatabaseStatement =
    match this with
    | AlterDatabaseAddFileGroupStatement(containsFileStream=aContainsFileStream; containsMemoryOptimizedData=aContainsMemoryOptimizedData; databaseName=aDatabaseName; fileGroup=aFileGroup; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseAddFileGroupStatement()
      ret.ContainsFileStream <- aContainsFileStream
      ret.ContainsMemoryOptimizedData <- aContainsMemoryOptimizedData
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseAddFileStatement(databaseName=aDatabaseName; fileDeclarations=aFileDeclarations; fileGroup=aFileGroup; isLog=aIsLog; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseAddFileStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aFileDeclarations do ret.FileDeclarations.Add (e.ToCs())
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLog <- aIsLog
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseCollateStatement(collation=aCollation; databaseName=aDatabaseName; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseCollateStatement()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseModifyFileGroupStatement(databaseName=aDatabaseName; fileGroup=aFileGroup; makeDefault=aMakeDefault; newFileGroupName=aNewFileGroupName; termination=aTermination; updatabilityOption=aUpdatabilityOption; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseModifyFileGroupStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MakeDefault <- aMakeDefault
      ret.NewFileGroupName <- aNewFileGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Termination <- aTermination |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UpdatabilityOption <- aUpdatabilityOption
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseModifyFileStatement(databaseName=aDatabaseName; fileDeclaration=aFileDeclaration; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseModifyFileStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileDeclaration <- aFileDeclaration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseModifyNameStatement(databaseName=aDatabaseName; newDatabaseName=aNewDatabaseName; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseModifyNameStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NewDatabaseName <- aNewDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseRebuildLogStatement(databaseName=aDatabaseName; fileDeclaration=aFileDeclaration; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseRebuildLogStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileDeclaration <- aFileDeclaration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseRemoveFileGroupStatement(databaseName=aDatabaseName; fileGroup=aFileGroup; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseRemoveFileGroupStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseRemoveFileStatement(databaseName=aDatabaseName; file=aFile; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseRemoveFileStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
    | AlterDatabaseSetStatement(databaseName=aDatabaseName; options=aOptions; termination=aTermination; useCurrent=aUseCurrent) ->
      let ret = ScriptDom.AlterDatabaseSetStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Termination <- aTermination |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UseCurrent <- aUseCurrent
      ret :> ScriptDom.AlterDatabaseStatement (* 404 *)
//// shared props AlterDatabaseStatement 
  member this.DatabaseName = 
    match this with
    | AlterDatabaseAddFileGroupStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseAddFileStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseCollateStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseModifyFileGroupStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseModifyFileStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseModifyNameStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseRebuildLogStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseRemoveFileGroupStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseRemoveFileStatement(databaseName=databaseName) -> databaseName
    | AlterDatabaseSetStatement(databaseName=databaseName) -> databaseName
  member this.UseCurrent = 
    match this with
    | AlterDatabaseAddFileGroupStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseAddFileStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseCollateStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseModifyFileGroupStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseModifyFileStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseModifyNameStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseRebuildLogStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseRemoveFileGroupStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseRemoveFileStatement(useCurrent=useCurrent) -> useCurrent
    | AlterDatabaseSetStatement(useCurrent=useCurrent) -> useCurrent
  static member FromCs(src:ScriptDom.AlterDatabaseStatement) : AlterDatabaseStatement =
    match src with
    | :? ScriptDom.AlterDatabaseAddFileGroupStatement as src ->
      AlterDatabaseStatement.AlterDatabaseAddFileGroupStatement((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseAddFileStatement as src ->
      AlterDatabaseStatement.AlterDatabaseAddFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLog), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseCollateStatement as src ->
      AlterDatabaseStatement.AlterDatabaseCollateStatement((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseModifyFileGroupStatement as src ->
      AlterDatabaseStatement.AlterDatabaseModifyFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.MakeDefault), (src.NewFileGroupName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Termination |> Option.ofObj |> Option.map (AlterDatabaseTermination.FromCs)), (src.UpdatabilityOption), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseModifyFileStatement as src ->
      AlterDatabaseStatement.AlterDatabaseModifyFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileDeclaration |> Option.ofObj |> Option.map (FileDeclaration.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseModifyNameStatement as src ->
      AlterDatabaseStatement.AlterDatabaseModifyNameStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.NewDatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseRebuildLogStatement as src ->
      AlterDatabaseStatement.AlterDatabaseRebuildLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileDeclaration |> Option.ofObj |> Option.map (FileDeclaration.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseRemoveFileGroupStatement as src ->
      AlterDatabaseStatement.AlterDatabaseRemoveFileGroupStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseRemoveFileStatement as src ->
      AlterDatabaseStatement.AlterDatabaseRemoveFileStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.File |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UseCurrent))
    | :? ScriptDom.AlterDatabaseSetStatement as src ->
      AlterDatabaseStatement.AlterDatabaseSetStatement((src.DatabaseName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (DatabaseOption.FromCs) |> List.ofSeq), (src.Termination |> Option.ofObj |> Option.map (AlterDatabaseTermination.FromCs)), (src.UseCurrent))
and AlterLoginStatement = (* IsAbstract = true , children = 3*)
  | AlterLoginAddDropCredentialStatement of credentialName:Identifier option * isAdd:bool * name:Identifier option
  | AlterLoginEnableDisableStatement of isEnable:bool * name:Identifier option
  | AlterLoginOptionsStatement of name:Identifier option * options:(PrincipalOption) list
  member this.ToCs() : ScriptDom.AlterLoginStatement =
    match this with
    | AlterLoginAddDropCredentialStatement(credentialName=aCredentialName; isAdd=aIsAdd; name=aName) ->
      let ret = ScriptDom.AlterLoginAddDropCredentialStatement()
      ret.CredentialName <- aCredentialName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsAdd <- aIsAdd
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterLoginStatement (* 404 *)
    | AlterLoginEnableDisableStatement(isEnable=aIsEnable; name=aName) ->
      let ret = ScriptDom.AlterLoginEnableDisableStatement()
      ret.IsEnable <- aIsEnable
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterLoginStatement (* 404 *)
    | AlterLoginOptionsStatement(name=aName; options=aOptions) ->
      let ret = ScriptDom.AlterLoginOptionsStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.AlterLoginStatement (* 404 *)
//// shared props AlterLoginStatement 
  member this.Name = 
    match this with
    | AlterLoginAddDropCredentialStatement(name=name) -> name
    | AlterLoginEnableDisableStatement(name=name) -> name
    | AlterLoginOptionsStatement(name=name) -> name
  static member FromCs(src:ScriptDom.AlterLoginStatement) : AlterLoginStatement =
    match src with
    | :? ScriptDom.AlterLoginAddDropCredentialStatement as src ->
      AlterLoginStatement.AlterLoginAddDropCredentialStatement((src.CredentialName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsAdd), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterLoginEnableDisableStatement as src ->
      AlterLoginStatement.AlterLoginEnableDisableStatement((src.IsEnable), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterLoginOptionsStatement as src ->
      AlterLoginStatement.AlterLoginOptionsStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))
and AlterTableStatement = (* IsAbstract = true , children = 12*)
  | AlterTableAddTableElementStatement of definition:TableDefinition option * existingRowsCheckEnforcement:ScriptDom.ConstraintEnforcement * schemaObjectName:SchemaObjectName option
  | AlterTableAlterColumnStatement of alterTableAlterColumnOption:ScriptDom.AlterTableAlterColumnOption * collation:Identifier option * columnIdentifier:Identifier option * dataType:DataTypeReference option * encryption:ColumnEncryptionDefinition option * generatedAlways:(ScriptDom.GeneratedAlwaysType) option * isHidden:bool * isMasked:bool * maskingFunction:StringLiteral option * options:(IndexOption) list * schemaObjectName:SchemaObjectName option * storageOptions:ColumnStorageOptions option
  | AlterTableAlterIndexStatement of alterIndexType:ScriptDom.AlterIndexType * indexIdentifier:Identifier option * indexOptions:(IndexOption) list * schemaObjectName:SchemaObjectName option
  | AlterTableAlterPartitionStatement of boundaryValue:ScalarExpression option * isSplit:bool * schemaObjectName:SchemaObjectName option
  | AlterTableChangeTrackingModificationStatement of isEnable:bool * schemaObjectName:SchemaObjectName option * trackColumnsUpdated:ScriptDom.OptionState
  | AlterTableConstraintModificationStatement of all:bool * constraintEnforcement:ScriptDom.ConstraintEnforcement * constraintNames:(Identifier) list * existingRowsCheckEnforcement:ScriptDom.ConstraintEnforcement * schemaObjectName:SchemaObjectName option
  | AlterTableDropTableElementStatement of alterTableDropTableElements:(AlterTableDropTableElement) list * schemaObjectName:SchemaObjectName option
  | AlterTableFileTableNamespaceStatement of isEnable:bool * schemaObjectName:SchemaObjectName option
  | AlterTableRebuildStatement of indexOptions:(IndexOption) list * partition:PartitionSpecifier option * schemaObjectName:SchemaObjectName option
  | AlterTableSetStatement of options:(TableOption) list * schemaObjectName:SchemaObjectName option
  | AlterTableSwitchStatement of options:(TableSwitchOption) list * schemaObjectName:SchemaObjectName option * sourcePartitionNumber:ScalarExpression option * targetPartitionNumber:ScalarExpression option * targetTable:SchemaObjectName option
  | AlterTableTriggerModificationStatement of all:bool * schemaObjectName:SchemaObjectName option * triggerEnforcement:ScriptDom.TriggerEnforcement * triggerNames:(Identifier) list
  member this.ToCs() : ScriptDom.AlterTableStatement =
    match this with
    | AlterTableAddTableElementStatement(definition=aDefinition; existingRowsCheckEnforcement=aExistingRowsCheckEnforcement; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableAddTableElementStatement()
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExistingRowsCheckEnforcement <- aExistingRowsCheckEnforcement
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableAlterColumnStatement(alterTableAlterColumnOption=aAlterTableAlterColumnOption; collation=aCollation; columnIdentifier=aColumnIdentifier; dataType=aDataType; encryption=aEncryption; generatedAlways=aGeneratedAlways; isHidden=aIsHidden; isMasked=aIsMasked; maskingFunction=aMaskingFunction; options=aOptions; schemaObjectName=aSchemaObjectName; storageOptions=aStorageOptions) ->
      let ret = ScriptDom.AlterTableAlterColumnStatement()
      ret.AlterTableAlterColumnOption <- aAlterTableAlterColumnOption
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Encryption <- aEncryption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GeneratedAlways <- Option.toNullable aGeneratedAlways
      ret.IsHidden <- aIsHidden
      ret.IsMasked <- aIsMasked
      ret.MaskingFunction <- aMaskingFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StorageOptions <- aStorageOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableAlterIndexStatement(alterIndexType=aAlterIndexType; indexIdentifier=aIndexIdentifier; indexOptions=aIndexOptions; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableAlterIndexStatement()
      ret.AlterIndexType <- aAlterIndexType
      ret.IndexIdentifier <- aIndexIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableAlterPartitionStatement(boundaryValue=aBoundaryValue; isSplit=aIsSplit; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableAlterPartitionStatement()
      ret.BoundaryValue <- aBoundaryValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsSplit <- aIsSplit
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableChangeTrackingModificationStatement(isEnable=aIsEnable; schemaObjectName=aSchemaObjectName; trackColumnsUpdated=aTrackColumnsUpdated) ->
      let ret = ScriptDom.AlterTableChangeTrackingModificationStatement()
      ret.IsEnable <- aIsEnable
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TrackColumnsUpdated <- aTrackColumnsUpdated
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableConstraintModificationStatement(all=aAll; constraintEnforcement=aConstraintEnforcement; constraintNames=aConstraintNames; existingRowsCheckEnforcement=aExistingRowsCheckEnforcement; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableConstraintModificationStatement()
      ret.All <- aAll
      ret.ConstraintEnforcement <- aConstraintEnforcement
      for e in aConstraintNames do ret.ConstraintNames.Add (e.ToCs())
      ret.ExistingRowsCheckEnforcement <- aExistingRowsCheckEnforcement
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableDropTableElementStatement(alterTableDropTableElements=aAlterTableDropTableElements; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableDropTableElementStatement()
      for e in aAlterTableDropTableElements do ret.AlterTableDropTableElements.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableFileTableNamespaceStatement(isEnable=aIsEnable; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableFileTableNamespaceStatement()
      ret.IsEnable <- aIsEnable
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableRebuildStatement(indexOptions=aIndexOptions; partition=aPartition; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableRebuildStatement()
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Partition <- aPartition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableSetStatement(options=aOptions; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.AlterTableSetStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableSwitchStatement(options=aOptions; schemaObjectName=aSchemaObjectName; sourcePartitionNumber=aSourcePartitionNumber; targetPartitionNumber=aTargetPartitionNumber; targetTable=aTargetTable) ->
      let ret = ScriptDom.AlterTableSwitchStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourcePartitionNumber <- aSourcePartitionNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TargetPartitionNumber <- aTargetPartitionNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TargetTable <- aTargetTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterTableStatement (* 404 *)
    | AlterTableTriggerModificationStatement(all=aAll; schemaObjectName=aSchemaObjectName; triggerEnforcement=aTriggerEnforcement; triggerNames=aTriggerNames) ->
      let ret = ScriptDom.AlterTableTriggerModificationStatement()
      ret.All <- aAll
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerEnforcement <- aTriggerEnforcement
      for e in aTriggerNames do ret.TriggerNames.Add (e.ToCs())
      ret :> ScriptDom.AlterTableStatement (* 404 *)
//// shared props AlterTableStatement 
  member this.SchemaObjectName = 
    match this with
    | AlterTableAddTableElementStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableAlterColumnStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableAlterIndexStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableAlterPartitionStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableChangeTrackingModificationStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableConstraintModificationStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableDropTableElementStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableFileTableNamespaceStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableRebuildStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableSetStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableSwitchStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | AlterTableTriggerModificationStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
  static member FromCs(src:ScriptDom.AlterTableStatement) : AlterTableStatement =
    match src with
    | :? ScriptDom.AlterTableAddTableElementStatement as src ->
      AlterTableStatement.AlterTableAddTableElementStatement((src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.ExistingRowsCheckEnforcement), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableAlterColumnStatement as src ->
      AlterTableStatement.AlterTableAlterColumnStatement((src.AlterTableAlterColumnOption), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IsHidden), (src.IsMasked), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Options |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))
    | :? ScriptDom.AlterTableAlterIndexStatement as src ->
      AlterTableStatement.AlterTableAlterIndexStatement((src.AlterIndexType), (src.IndexIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableAlterPartitionStatement as src ->
      AlterTableStatement.AlterTableAlterPartitionStatement((src.BoundaryValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsSplit), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableChangeTrackingModificationStatement as src ->
      AlterTableStatement.AlterTableChangeTrackingModificationStatement((src.IsEnable), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TrackColumnsUpdated))
    | :? ScriptDom.AlterTableConstraintModificationStatement as src ->
      AlterTableStatement.AlterTableConstraintModificationStatement((src.All), (src.ConstraintEnforcement), (src.ConstraintNames |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ExistingRowsCheckEnforcement), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableDropTableElementStatement as src ->
      AlterTableStatement.AlterTableDropTableElementStatement((src.AlterTableDropTableElements |> Seq.map (fun src -> AlterTableDropTableElement.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (DropClusteredConstraintOption.FromCs) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableElementType))) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableFileTableNamespaceStatement as src ->
      AlterTableStatement.AlterTableFileTableNamespaceStatement((src.IsEnable), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableRebuildStatement as src ->
      AlterTableStatement.AlterTableRebuildStatement((src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Partition |> Option.ofObj |> Option.map (PartitionSpecifier.FromCs)), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableSetStatement as src ->
      AlterTableStatement.AlterTableSetStatement((src.Options |> Seq.map (TableOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableSwitchStatement as src ->
      AlterTableStatement.AlterTableSwitchStatement((src.Options |> Seq.map (TableSwitchOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SourcePartitionNumber |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TargetPartitionNumber |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TargetTable |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.AlterTableTriggerModificationStatement as src ->
      AlterTableStatement.AlterTableTriggerModificationStatement((src.All), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TriggerEnforcement), (src.TriggerNames |> Seq.map (Identifier.FromCs) |> List.ofSeq))
and ApplicationRoleStatement = (* IsAbstract = true , children = 2*)
  | AlterApplicationRoleStatement of applicationRoleOptions:(ApplicationRoleOption) list * name:Identifier option
  | CreateApplicationRoleStatement of applicationRoleOptions:(ApplicationRoleOption) list * name:Identifier option
  member this.ToCs() : ScriptDom.ApplicationRoleStatement =
    match this with
    | AlterApplicationRoleStatement(applicationRoleOptions=aApplicationRoleOptions; name=aName) ->
      let ret = ScriptDom.AlterApplicationRoleStatement()
      for e in aApplicationRoleOptions do ret.ApplicationRoleOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ApplicationRoleStatement (* 404 *)
    | CreateApplicationRoleStatement(applicationRoleOptions=aApplicationRoleOptions; name=aName) ->
      let ret = ScriptDom.CreateApplicationRoleStatement()
      for e in aApplicationRoleOptions do ret.ApplicationRoleOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ApplicationRoleStatement (* 404 *)
//// shared props ApplicationRoleStatement 
  member this.ApplicationRoleOptions = 
    match this with
    | AlterApplicationRoleStatement(applicationRoleOptions=applicationRoleOptions) -> applicationRoleOptions
    | CreateApplicationRoleStatement(applicationRoleOptions=applicationRoleOptions) -> applicationRoleOptions
  member this.Name = 
    match this with
    | AlterApplicationRoleStatement(name=name) -> name
    | CreateApplicationRoleStatement(name=name) -> name
  static member FromCs(src:ScriptDom.ApplicationRoleStatement) : ApplicationRoleStatement =
    match src with
    | :? ScriptDom.AlterApplicationRoleStatement as src ->
      ApplicationRoleStatement.AlterApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateApplicationRoleStatement as src ->
      ApplicationRoleStatement.CreateApplicationRoleStatement((src.ApplicationRoleOptions |> Seq.map (fun src -> ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and AssemblyStatement = (* IsAbstract = true , children = 2*)
  | AlterAssemblyStatement of addFiles:(AddFileSpec) list * dropFiles:(Literal) list * isDropAll:bool * name:Identifier option * options:(AssemblyOption) list * parameters:(ScalarExpression) list
  | CreateAssemblyStatement of name:Identifier option * options:(AssemblyOption) list * owner:Identifier option * parameters:(ScalarExpression) list
  member this.ToCs() : ScriptDom.AssemblyStatement =
    match this with
    | AlterAssemblyStatement(addFiles=aAddFiles; dropFiles=aDropFiles; isDropAll=aIsDropAll; name=aName; options=aOptions; parameters=aParameters) ->
      let ret = ScriptDom.AlterAssemblyStatement()
      for e in aAddFiles do ret.AddFiles.Add (e.ToCs())
      for e in aDropFiles do ret.DropFiles.Add (e.ToCs())
      ret.IsDropAll <- aIsDropAll
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.AssemblyStatement (* 404 *)
    | CreateAssemblyStatement(name=aName; options=aOptions; owner=aOwner; parameters=aParameters) ->
      let ret = ScriptDom.CreateAssemblyStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.AssemblyStatement (* 404 *)
//// shared props AssemblyStatement 
  member this.Name = 
    match this with
    | AlterAssemblyStatement(name=name) -> name
    | CreateAssemblyStatement(name=name) -> name
  member this.Options = 
    match this with
    | AlterAssemblyStatement(options=options) -> options
    | CreateAssemblyStatement(options=options) -> options
  member this.Parameters = 
    match this with
    | AlterAssemblyStatement(parameters=parameters) -> parameters
    | CreateAssemblyStatement(parameters=parameters) -> parameters
  static member FromCs(src:ScriptDom.AssemblyStatement) : AssemblyStatement =
    match src with
    | :? ScriptDom.AlterAssemblyStatement as src ->
      AssemblyStatement.AlterAssemblyStatement((src.AddFiles |> Seq.map (fun src -> AddFileSpec.AddFileSpec((src.File |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FileName |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.DropFiles |> Seq.map (Literal.FromCs) |> List.ofSeq), (src.IsDropAll), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AssemblyOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateAssemblyStatement as src ->
      AssemblyStatement.CreateAssemblyStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AssemblyOption.FromCs) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
and AuditSpecificationStatement = (* IsAbstract = true , children = 4*)
  | AlterDatabaseAuditSpecificationStatement of auditName:Identifier option * auditState:ScriptDom.OptionState * parts:(AuditSpecificationPart) list * specificationName:Identifier option
  | AlterServerAuditSpecificationStatement of auditName:Identifier option * auditState:ScriptDom.OptionState * parts:(AuditSpecificationPart) list * specificationName:Identifier option
  | CreateDatabaseAuditSpecificationStatement of auditName:Identifier option * auditState:ScriptDom.OptionState * parts:(AuditSpecificationPart) list * specificationName:Identifier option
  | CreateServerAuditSpecificationStatement of auditName:Identifier option * auditState:ScriptDom.OptionState * parts:(AuditSpecificationPart) list * specificationName:Identifier option
  member this.ToCs() : ScriptDom.AuditSpecificationStatement =
    match this with
    | AlterDatabaseAuditSpecificationStatement(auditName=aAuditName; auditState=aAuditState; parts=aParts; specificationName=aSpecificationName) ->
      let ret = ScriptDom.AlterDatabaseAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 404 *)
    | AlterServerAuditSpecificationStatement(auditName=aAuditName; auditState=aAuditState; parts=aParts; specificationName=aSpecificationName) ->
      let ret = ScriptDom.AlterServerAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 404 *)
    | CreateDatabaseAuditSpecificationStatement(auditName=aAuditName; auditState=aAuditState; parts=aParts; specificationName=aSpecificationName) ->
      let ret = ScriptDom.CreateDatabaseAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 404 *)
    | CreateServerAuditSpecificationStatement(auditName=aAuditName; auditState=aAuditState; parts=aParts; specificationName=aSpecificationName) ->
      let ret = ScriptDom.CreateServerAuditSpecificationStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditState <- aAuditState
      for e in aParts do ret.Parts.Add (e.ToCs())
      ret.SpecificationName <- aSpecificationName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AuditSpecificationStatement (* 404 *)
//// shared props AuditSpecificationStatement 
  member this.AuditName = 
    match this with
    | AlterDatabaseAuditSpecificationStatement(auditName=auditName) -> auditName
    | AlterServerAuditSpecificationStatement(auditName=auditName) -> auditName
    | CreateDatabaseAuditSpecificationStatement(auditName=auditName) -> auditName
    | CreateServerAuditSpecificationStatement(auditName=auditName) -> auditName
  member this.AuditState = 
    match this with
    | AlterDatabaseAuditSpecificationStatement(auditState=auditState) -> auditState
    | AlterServerAuditSpecificationStatement(auditState=auditState) -> auditState
    | CreateDatabaseAuditSpecificationStatement(auditState=auditState) -> auditState
    | CreateServerAuditSpecificationStatement(auditState=auditState) -> auditState
  member this.Parts = 
    match this with
    | AlterDatabaseAuditSpecificationStatement(parts=parts) -> parts
    | AlterServerAuditSpecificationStatement(parts=parts) -> parts
    | CreateDatabaseAuditSpecificationStatement(parts=parts) -> parts
    | CreateServerAuditSpecificationStatement(parts=parts) -> parts
  member this.SpecificationName = 
    match this with
    | AlterDatabaseAuditSpecificationStatement(specificationName=specificationName) -> specificationName
    | AlterServerAuditSpecificationStatement(specificationName=specificationName) -> specificationName
    | CreateDatabaseAuditSpecificationStatement(specificationName=specificationName) -> specificationName
    | CreateServerAuditSpecificationStatement(specificationName=specificationName) -> specificationName
  static member FromCs(src:ScriptDom.AuditSpecificationStatement) : AuditSpecificationStatement =
    match src with
    | :? ScriptDom.AlterDatabaseAuditSpecificationStatement as src ->
      AuditSpecificationStatement.AlterDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.AlterServerAuditSpecificationStatement as src ->
      AuditSpecificationStatement.AlterServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateDatabaseAuditSpecificationStatement as src ->
      AuditSpecificationStatement.CreateDatabaseAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateServerAuditSpecificationStatement as src ->
      AuditSpecificationStatement.CreateServerAuditSpecificationStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditState), (src.Parts |> Seq.map (fun src -> AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))) |> List.ofSeq), (src.SpecificationName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and AvailabilityGroupStatement = (* IsAbstract = true , children = 2*)
  | AlterAvailabilityGroupStatement of action:AlterAvailabilityGroupAction option * alterAvailabilityGroupStatementType:ScriptDom.AlterAvailabilityGroupStatementType * databases:(Identifier) list * name:Identifier option * options:(AvailabilityGroupOption) list * replicas:(AvailabilityReplica) list
  | CreateAvailabilityGroupStatement of databases:(Identifier) list * name:Identifier option * options:(AvailabilityGroupOption) list * replicas:(AvailabilityReplica) list
  member this.ToCs() : ScriptDom.AvailabilityGroupStatement =
    match this with
    | AlterAvailabilityGroupStatement(action=aAction; alterAvailabilityGroupStatementType=aAlterAvailabilityGroupStatementType; databases=aDatabases; name=aName; options=aOptions; replicas=aReplicas) ->
      let ret = ScriptDom.AlterAvailabilityGroupStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AlterAvailabilityGroupStatementType <- aAlterAvailabilityGroupStatementType
      for e in aDatabases do ret.Databases.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aReplicas do ret.Replicas.Add (e.ToCs())
      ret :> ScriptDom.AvailabilityGroupStatement (* 404 *)
    | CreateAvailabilityGroupStatement(databases=aDatabases; name=aName; options=aOptions; replicas=aReplicas) ->
      let ret = ScriptDom.CreateAvailabilityGroupStatement()
      for e in aDatabases do ret.Databases.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aReplicas do ret.Replicas.Add (e.ToCs())
      ret :> ScriptDom.AvailabilityGroupStatement (* 404 *)
//// shared props AvailabilityGroupStatement 
  member this.Databases = 
    match this with
    | AlterAvailabilityGroupStatement(databases=databases) -> databases
    | CreateAvailabilityGroupStatement(databases=databases) -> databases
  member this.Name = 
    match this with
    | AlterAvailabilityGroupStatement(name=name) -> name
    | CreateAvailabilityGroupStatement(name=name) -> name
  member this.Options = 
    match this with
    | AlterAvailabilityGroupStatement(options=options) -> options
    | CreateAvailabilityGroupStatement(options=options) -> options
  member this.Replicas = 
    match this with
    | AlterAvailabilityGroupStatement(replicas=replicas) -> replicas
    | CreateAvailabilityGroupStatement(replicas=replicas) -> replicas
  static member FromCs(src:ScriptDom.AvailabilityGroupStatement) : AvailabilityGroupStatement =
    match src with
    | :? ScriptDom.AlterAvailabilityGroupStatement as src ->
      AvailabilityGroupStatement.AlterAvailabilityGroupStatement((src.Action |> Option.ofObj |> Option.map (AlterAvailabilityGroupAction.FromCs)), (src.AlterAvailabilityGroupStatementType), (src.Databases |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AvailabilityGroupOption.FromCs) |> List.ofSeq), (src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (AvailabilityReplicaOption.FromCs) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.CreateAvailabilityGroupStatement as src ->
      AvailabilityGroupStatement.CreateAvailabilityGroupStatement((src.Databases |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AvailabilityGroupOption.FromCs) |> List.ofSeq), (src.Replicas |> Seq.map (fun src -> AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (AvailabilityReplicaOption.FromCs) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))) |> List.ofSeq))
and BackupRestoreMasterKeyStatementBase = (* IsAbstract = true , children = 4*)
  | BackupMasterKeyStatement of file:Literal option * password:Literal option
  | BackupServiceMasterKeyStatement of file:Literal option * password:Literal option
  | RestoreMasterKeyStatement of encryptionPassword:Literal option * file:Literal option * isForce:bool * password:Literal option
  | RestoreServiceMasterKeyStatement of file:Literal option * isForce:bool * password:Literal option
  member this.ToCs() : ScriptDom.BackupRestoreMasterKeyStatementBase =
    match this with
    | BackupMasterKeyStatement(file=aFile; password=aPassword) ->
      let ret = ScriptDom.BackupMasterKeyStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 404 *)
    | BackupServiceMasterKeyStatement(file=aFile; password=aPassword) ->
      let ret = ScriptDom.BackupServiceMasterKeyStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 404 *)
    | RestoreMasterKeyStatement(encryptionPassword=aEncryptionPassword; file=aFile; isForce=aIsForce; password=aPassword) ->
      let ret = ScriptDom.RestoreMasterKeyStatement()
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsForce <- aIsForce
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 404 *)
    | RestoreServiceMasterKeyStatement(file=aFile; isForce=aIsForce; password=aPassword) ->
      let ret = ScriptDom.RestoreServiceMasterKeyStatement()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsForce <- aIsForce
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BackupRestoreMasterKeyStatementBase (* 404 *)
//// shared props BackupRestoreMasterKeyStatementBase 
  member this.File = 
    match this with
    | BackupMasterKeyStatement(file=file) -> file
    | BackupServiceMasterKeyStatement(file=file) -> file
    | RestoreMasterKeyStatement(file=file) -> file
    | RestoreServiceMasterKeyStatement(file=file) -> file
  member this.Password = 
    match this with
    | BackupMasterKeyStatement(password=password) -> password
    | BackupServiceMasterKeyStatement(password=password) -> password
    | RestoreMasterKeyStatement(password=password) -> password
    | RestoreServiceMasterKeyStatement(password=password) -> password
  static member FromCs(src:ScriptDom.BackupRestoreMasterKeyStatementBase) : BackupRestoreMasterKeyStatementBase =
    match src with
    | :? ScriptDom.BackupMasterKeyStatement as src ->
      BackupRestoreMasterKeyStatementBase.BackupMasterKeyStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.BackupServiceMasterKeyStatement as src ->
      BackupRestoreMasterKeyStatementBase.BackupServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.RestoreMasterKeyStatement as src ->
      BackupRestoreMasterKeyStatementBase.RestoreMasterKeyStatement((src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsForce), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.RestoreServiceMasterKeyStatement as src ->
      BackupRestoreMasterKeyStatementBase.RestoreServiceMasterKeyStatement((src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsForce), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
and BackupStatement = (* IsAbstract = true , children = 2*)
  | BackupDatabaseStatement of databaseName:IdentifierOrValueExpression option * devices:(DeviceInfo) list * files:(BackupRestoreFileInfo) list * mirrorToClauses:(MirrorToClause) list * options:(BackupOption) list
  | BackupTransactionLogStatement of databaseName:IdentifierOrValueExpression option * devices:(DeviceInfo) list * mirrorToClauses:(MirrorToClause) list * options:(BackupOption) list
  member this.ToCs() : ScriptDom.BackupStatement =
    match this with
    | BackupDatabaseStatement(databaseName=aDatabaseName; devices=aDevices; files=aFiles; mirrorToClauses=aMirrorToClauses; options=aOptions) ->
      let ret = ScriptDom.BackupDatabaseStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aDevices do ret.Devices.Add (e.ToCs())
      for e in aFiles do ret.Files.Add (e.ToCs())
      for e in aMirrorToClauses do ret.MirrorToClauses.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.BackupStatement (* 404 *)
    | BackupTransactionLogStatement(databaseName=aDatabaseName; devices=aDevices; mirrorToClauses=aMirrorToClauses; options=aOptions) ->
      let ret = ScriptDom.BackupTransactionLogStatement()
      ret.DatabaseName <- aDatabaseName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aDevices do ret.Devices.Add (e.ToCs())
      for e in aMirrorToClauses do ret.MirrorToClauses.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.BackupStatement (* 404 *)
//// shared props BackupStatement 
  member this.DatabaseName = 
    match this with
    | BackupDatabaseStatement(databaseName=databaseName) -> databaseName
    | BackupTransactionLogStatement(databaseName=databaseName) -> databaseName
  member this.Devices = 
    match this with
    | BackupDatabaseStatement(devices=devices) -> devices
    | BackupTransactionLogStatement(devices=devices) -> devices
  member this.MirrorToClauses = 
    match this with
    | BackupDatabaseStatement(mirrorToClauses=mirrorToClauses) -> mirrorToClauses
    | BackupTransactionLogStatement(mirrorToClauses=mirrorToClauses) -> mirrorToClauses
  member this.Options = 
    match this with
    | BackupDatabaseStatement(options=options) -> options
    | BackupTransactionLogStatement(options=options) -> options
  static member FromCs(src:ScriptDom.BackupStatement) : BackupStatement =
    match src with
    | :? ScriptDom.BackupDatabaseStatement as src ->
      BackupStatement.BackupDatabaseStatement((src.DatabaseName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.Files |> Seq.map (fun src -> BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (BackupOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.BackupTransactionLogStatement as src ->
      BackupStatement.BackupTransactionLogStatement((src.DatabaseName |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.MirrorToClauses |> Seq.map (fun src -> MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Options |> Seq.map (BackupOption.FromCs) |> List.ofSeq))
and BeginEndBlockStatement = (* IsAbstract = false , children = 1*)
  | Base of statementList:StatementList option
  | BeginEndAtomicBlockStatement of options:(AtomicBlockOption) list * statementList:StatementList option
  member this.ToCs() : ScriptDom.BeginEndBlockStatement =
    match this with
    | BeginEndAtomicBlockStatement(options=aOptions; statementList=aStatementList) ->
      let ret = ScriptDom.BeginEndAtomicBlockStatement()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BeginEndBlockStatement (* 404 *)
    | Base(statementList=aStatementList) ->

      let ret = ScriptDom.BeginEndBlockStatement()
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props BeginEndBlockStatement 
  member this.StatementList = 
    match this with
    | Base (statementList=statementList) -> statementList
    | BeginEndAtomicBlockStatement(statementList=statementList) -> statementList
  static member FromCs(src:ScriptDom.BeginEndBlockStatement) : BeginEndBlockStatement =
    match src with
    | :? ScriptDom.BeginEndAtomicBlockStatement as src ->
      BeginEndBlockStatement.BeginEndAtomicBlockStatement((src.Options |> Seq.map (AtomicBlockOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | _ -> (* :? ScriptDom.BeginEndBlockStatement as src *)
      BeginEndBlockStatement.Base(((src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs))))
and BrokerPriorityStatement = (* IsAbstract = true , children = 2*)
  | AlterBrokerPriorityStatement of brokerPriorityParameters:(BrokerPriorityParameter) list * name:Identifier option
  | CreateBrokerPriorityStatement of brokerPriorityParameters:(BrokerPriorityParameter) list * name:Identifier option
  member this.ToCs() : ScriptDom.BrokerPriorityStatement =
    match this with
    | AlterBrokerPriorityStatement(brokerPriorityParameters=aBrokerPriorityParameters; name=aName) ->
      let ret = ScriptDom.AlterBrokerPriorityStatement()
      for e in aBrokerPriorityParameters do ret.BrokerPriorityParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BrokerPriorityStatement (* 404 *)
    | CreateBrokerPriorityStatement(brokerPriorityParameters=aBrokerPriorityParameters; name=aName) ->
      let ret = ScriptDom.CreateBrokerPriorityStatement()
      for e in aBrokerPriorityParameters do ret.BrokerPriorityParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BrokerPriorityStatement (* 404 *)
//// shared props BrokerPriorityStatement 
  member this.BrokerPriorityParameters = 
    match this with
    | AlterBrokerPriorityStatement(brokerPriorityParameters=brokerPriorityParameters) -> brokerPriorityParameters
    | CreateBrokerPriorityStatement(brokerPriorityParameters=brokerPriorityParameters) -> brokerPriorityParameters
  member this.Name = 
    match this with
    | AlterBrokerPriorityStatement(name=name) -> name
    | CreateBrokerPriorityStatement(name=name) -> name
  static member FromCs(src:ScriptDom.BrokerPriorityStatement) : BrokerPriorityStatement =
    match src with
    | :? ScriptDom.AlterBrokerPriorityStatement as src ->
      BrokerPriorityStatement.AlterBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateBrokerPriorityStatement as src ->
      BrokerPriorityStatement.CreateBrokerPriorityStatement((src.BrokerPriorityParameters |> Seq.map (fun src -> BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and BulkInsertBase = (* IsAbstract = true , children = 2*)
  | BulkInsertStatement of from:IdentifierOrValueExpression option * options:(BulkInsertOption) list * to_:SchemaObjectName option
  | InsertBulkStatement of columnDefinitions:(InsertBulkColumnDefinition) list * options:(BulkInsertOption) list * to_:SchemaObjectName option
  member this.ToCs() : ScriptDom.BulkInsertBase =
    match this with
    | BulkInsertStatement(from=aFrom; options=aOptions; to_=aTo) ->
      let ret = ScriptDom.BulkInsertStatement()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BulkInsertBase (* 404 *)
    | InsertBulkStatement(columnDefinitions=aColumnDefinitions; options=aOptions; to_=aTo) ->
      let ret = ScriptDom.InsertBulkStatement()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.BulkInsertBase (* 404 *)
//// shared props BulkInsertBase 
  member this.Options = 
    match this with
    | BulkInsertStatement(options=options) -> options
    | InsertBulkStatement(options=options) -> options
  member this.To = 
    match this with
    | BulkInsertStatement(to_=to_) -> to_
    | InsertBulkStatement(to_=to_) -> to_
  static member FromCs(src:ScriptDom.BulkInsertBase) : BulkInsertBase =
    match src with
    | :? ScriptDom.BulkInsertStatement as src ->
      BulkInsertBase.BulkInsertStatement((src.From |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Options |> Seq.map (BulkInsertOption.FromCs) |> List.ofSeq), (src.To |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.InsertBulkStatement as src ->
      BulkInsertBase.InsertBulkStatement((src.ColumnDefinitions |> Seq.map (fun src -> InsertBulkColumnDefinition.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullNotNull))) |> List.ofSeq), (src.Options |> Seq.map (BulkInsertOption.FromCs) |> List.ofSeq), (src.To |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and CertificateStatementBase = (* IsAbstract = true , children = 3*)
  | AlterCertificateStatement of activeForBeginDialog:ScriptDom.OptionState * attestedBy:Literal option * decryptionPassword:Literal option * encryptionPassword:Literal option * kind:ScriptDom.AlterCertificateStatementKind * name:Identifier option * privateKeyPath:Literal option
  | BackupCertificateStatement of activeForBeginDialog:ScriptDom.OptionState * decryptionPassword:Literal option * encryptionPassword:Literal option * file:Literal option * name:Identifier option * privateKeyPath:Literal option
  | CreateCertificateStatement of activeForBeginDialog:ScriptDom.OptionState * certificateOptions:(CertificateOption) list * certificateSource:EncryptionSource option * decryptionPassword:Literal option * encryptionPassword:Literal option * name:Identifier option * owner:Identifier option * privateKeyPath:Literal option
  member this.ToCs() : ScriptDom.CertificateStatementBase =
    match this with
    | AlterCertificateStatement(activeForBeginDialog=aActiveForBeginDialog; attestedBy=aAttestedBy; decryptionPassword=aDecryptionPassword; encryptionPassword=aEncryptionPassword; kind=aKind; name=aName; privateKeyPath=aPrivateKeyPath) ->
      let ret = ScriptDom.AlterCertificateStatement()
      ret.ActiveForBeginDialog <- aActiveForBeginDialog
      ret.AttestedBy <- aAttestedBy |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Kind <- aKind
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrivateKeyPath <- aPrivateKeyPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CertificateStatementBase (* 404 *)
    | BackupCertificateStatement(activeForBeginDialog=aActiveForBeginDialog; decryptionPassword=aDecryptionPassword; encryptionPassword=aEncryptionPassword; file=aFile; name=aName; privateKeyPath=aPrivateKeyPath) ->
      let ret = ScriptDom.BackupCertificateStatement()
      ret.ActiveForBeginDialog <- aActiveForBeginDialog
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrivateKeyPath <- aPrivateKeyPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CertificateStatementBase (* 404 *)
    | CreateCertificateStatement(activeForBeginDialog=aActiveForBeginDialog; certificateOptions=aCertificateOptions; certificateSource=aCertificateSource; decryptionPassword=aDecryptionPassword; encryptionPassword=aEncryptionPassword; name=aName; owner=aOwner; privateKeyPath=aPrivateKeyPath) ->
      let ret = ScriptDom.CreateCertificateStatement()
      ret.ActiveForBeginDialog <- aActiveForBeginDialog
      for e in aCertificateOptions do ret.CertificateOptions.Add (e.ToCs())
      ret.CertificateSource <- aCertificateSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DecryptionPassword <- aDecryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EncryptionPassword <- aEncryptionPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrivateKeyPath <- aPrivateKeyPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CertificateStatementBase (* 404 *)
//// shared props CertificateStatementBase 
  member this.ActiveForBeginDialog = 
    match this with
    | AlterCertificateStatement(activeForBeginDialog=activeForBeginDialog) -> activeForBeginDialog
    | BackupCertificateStatement(activeForBeginDialog=activeForBeginDialog) -> activeForBeginDialog
    | CreateCertificateStatement(activeForBeginDialog=activeForBeginDialog) -> activeForBeginDialog
  member this.DecryptionPassword = 
    match this with
    | AlterCertificateStatement(decryptionPassword=decryptionPassword) -> decryptionPassword
    | BackupCertificateStatement(decryptionPassword=decryptionPassword) -> decryptionPassword
    | CreateCertificateStatement(decryptionPassword=decryptionPassword) -> decryptionPassword
  member this.EncryptionPassword = 
    match this with
    | AlterCertificateStatement(encryptionPassword=encryptionPassword) -> encryptionPassword
    | BackupCertificateStatement(encryptionPassword=encryptionPassword) -> encryptionPassword
    | CreateCertificateStatement(encryptionPassword=encryptionPassword) -> encryptionPassword
  member this.Name = 
    match this with
    | AlterCertificateStatement(name=name) -> name
    | BackupCertificateStatement(name=name) -> name
    | CreateCertificateStatement(name=name) -> name
  member this.PrivateKeyPath = 
    match this with
    | AlterCertificateStatement(privateKeyPath=privateKeyPath) -> privateKeyPath
    | BackupCertificateStatement(privateKeyPath=privateKeyPath) -> privateKeyPath
    | CreateCertificateStatement(privateKeyPath=privateKeyPath) -> privateKeyPath
  static member FromCs(src:ScriptDom.CertificateStatementBase) : CertificateStatementBase =
    match src with
    | :? ScriptDom.AlterCertificateStatement as src ->
      CertificateStatementBase.AlterCertificateStatement((src.ActiveForBeginDialog), (src.AttestedBy |> Option.ofObj |> Option.map (Literal.FromCs)), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Kind), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrivateKeyPath |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.BackupCertificateStatement as src ->
      CertificateStatementBase.BackupCertificateStatement((src.ActiveForBeginDialog), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.File |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrivateKeyPath |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.CreateCertificateStatement as src ->
      CertificateStatementBase.CreateCertificateStatement((src.ActiveForBeginDialog), (src.CertificateOptions |> Seq.map (fun src -> CertificateOption.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.CertificateSource |> Option.ofObj |> Option.map (EncryptionSource.FromCs)), (src.DecryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.EncryptionPassword |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrivateKeyPath |> Option.ofObj |> Option.map (Literal.FromCs)))
and ColumnEncryptionKeyStatement = (* IsAbstract = true , children = 2*)
  | AlterColumnEncryptionKeyStatement of alterType:ScriptDom.ColumnEncryptionKeyAlterType * columnEncryptionKeyValues:(ColumnEncryptionKeyValue) list * name:Identifier option
  | CreateColumnEncryptionKeyStatement of columnEncryptionKeyValues:(ColumnEncryptionKeyValue) list * name:Identifier option
  member this.ToCs() : ScriptDom.ColumnEncryptionKeyStatement =
    match this with
    | AlterColumnEncryptionKeyStatement(alterType=aAlterType; columnEncryptionKeyValues=aColumnEncryptionKeyValues; name=aName) ->
      let ret = ScriptDom.AlterColumnEncryptionKeyStatement()
      ret.AlterType <- aAlterType
      for e in aColumnEncryptionKeyValues do ret.ColumnEncryptionKeyValues.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnEncryptionKeyStatement (* 404 *)
    | CreateColumnEncryptionKeyStatement(columnEncryptionKeyValues=aColumnEncryptionKeyValues; name=aName) ->
      let ret = ScriptDom.CreateColumnEncryptionKeyStatement()
      for e in aColumnEncryptionKeyValues do ret.ColumnEncryptionKeyValues.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ColumnEncryptionKeyStatement (* 404 *)
//// shared props ColumnEncryptionKeyStatement 
  member this.ColumnEncryptionKeyValues = 
    match this with
    | AlterColumnEncryptionKeyStatement(columnEncryptionKeyValues=columnEncryptionKeyValues) -> columnEncryptionKeyValues
    | CreateColumnEncryptionKeyStatement(columnEncryptionKeyValues=columnEncryptionKeyValues) -> columnEncryptionKeyValues
  member this.Name = 
    match this with
    | AlterColumnEncryptionKeyStatement(name=name) -> name
    | CreateColumnEncryptionKeyStatement(name=name) -> name
  static member FromCs(src:ScriptDom.ColumnEncryptionKeyStatement) : ColumnEncryptionKeyStatement =
    match src with
    | :? ScriptDom.AlterColumnEncryptionKeyStatement as src ->
      ColumnEncryptionKeyStatement.AlterColumnEncryptionKeyStatement((src.AlterType), (src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (ColumnEncryptionKeyValueParameter.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateColumnEncryptionKeyStatement as src ->
      ColumnEncryptionKeyStatement.CreateColumnEncryptionKeyStatement((src.ColumnEncryptionKeyValues |> Seq.map (fun src -> ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (ColumnEncryptionKeyValueParameter.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and CreateTypeStatement = (* IsAbstract = true , children = 3*)
  | CreateTypeTableStatement of definition:TableDefinition option * name:SchemaObjectName option * options:(TableOption) list
  | CreateTypeUddtStatement of dataType:DataTypeReference option * name:SchemaObjectName option * nullableConstraint:NullableConstraintDefinition option
  | CreateTypeUdtStatement of assemblyName:AssemblyName option * name:SchemaObjectName option
  member this.ToCs() : ScriptDom.CreateTypeStatement =
    match this with
    | CreateTypeTableStatement(definition=aDefinition; name=aName; options=aOptions) ->
      let ret = ScriptDom.CreateTypeTableStatement()
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.CreateTypeStatement (* 404 *)
    | CreateTypeUddtStatement(dataType=aDataType; name=aName; nullableConstraint=aNullableConstraint) ->
      let ret = ScriptDom.CreateTypeUddtStatement()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullableConstraint <- aNullableConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateTypeStatement (* 404 *)
    | CreateTypeUdtStatement(assemblyName=aAssemblyName; name=aName) ->
      let ret = ScriptDom.CreateTypeUdtStatement()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateTypeStatement (* 404 *)
//// shared props CreateTypeStatement 
  member this.Name = 
    match this with
    | CreateTypeTableStatement(name=name) -> name
    | CreateTypeUddtStatement(name=name) -> name
    | CreateTypeUdtStatement(name=name) -> name
  static member FromCs(src:ScriptDom.CreateTypeStatement) : CreateTypeStatement =
    match src with
    | :? ScriptDom.CreateTypeTableStatement as src ->
      CreateTypeStatement.CreateTypeTableStatement((src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TableOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateTypeUddtStatement as src ->
      CreateTypeStatement.CreateTypeUddtStatement((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.NullableConstraint |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))
    | :? ScriptDom.CreateTypeUdtStatement as src ->
      CreateTypeStatement.CreateTypeUdtStatement((src.AssemblyName |> Option.ofObj |> Option.map (AssemblyName.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and CredentialStatement = (* IsAbstract = true , children = 2*)
  | AlterCredentialStatement of identity:Literal option * isDatabaseScoped:bool * name:Identifier option * secret:Literal option
  | CreateCredentialStatement of cryptographicProviderName:Identifier option * identity:Literal option * isDatabaseScoped:bool * name:Identifier option * secret:Literal option
  member this.ToCs() : ScriptDom.CredentialStatement =
    match this with
    | AlterCredentialStatement(identity=aIdentity; isDatabaseScoped=aIsDatabaseScoped; name=aName; secret=aSecret) ->
      let ret = ScriptDom.AlterCredentialStatement()
      ret.Identity <- aIdentity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDatabaseScoped <- aIsDatabaseScoped
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secret <- aSecret |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CredentialStatement (* 404 *)
    | CreateCredentialStatement(cryptographicProviderName=aCryptographicProviderName; identity=aIdentity; isDatabaseScoped=aIsDatabaseScoped; name=aName; secret=aSecret) ->
      let ret = ScriptDom.CreateCredentialStatement()
      ret.CryptographicProviderName <- aCryptographicProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Identity <- aIdentity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDatabaseScoped <- aIsDatabaseScoped
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Secret <- aSecret |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CredentialStatement (* 404 *)
//// shared props CredentialStatement 
  member this.Identity = 
    match this with
    | AlterCredentialStatement(identity=identity) -> identity
    | CreateCredentialStatement(identity=identity) -> identity
  member this.IsDatabaseScoped = 
    match this with
    | AlterCredentialStatement(isDatabaseScoped=isDatabaseScoped) -> isDatabaseScoped
    | CreateCredentialStatement(isDatabaseScoped=isDatabaseScoped) -> isDatabaseScoped
  member this.Name = 
    match this with
    | AlterCredentialStatement(name=name) -> name
    | CreateCredentialStatement(name=name) -> name
  member this.Secret = 
    match this with
    | AlterCredentialStatement(secret=secret) -> secret
    | CreateCredentialStatement(secret=secret) -> secret
  static member FromCs(src:ScriptDom.CredentialStatement) : CredentialStatement =
    match src with
    | :? ScriptDom.AlterCredentialStatement as src ->
      CredentialStatement.AlterCredentialStatement((src.Identity |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsDatabaseScoped), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Secret |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.CreateCredentialStatement as src ->
      CredentialStatement.CreateCredentialStatement((src.CryptographicProviderName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identity |> Option.ofObj |> Option.map (Literal.FromCs)), (src.IsDatabaseScoped), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Secret |> Option.ofObj |> Option.map (Literal.FromCs)))
and CursorStatement = (* IsAbstract = true , children = 4*)
  | CloseCursorStatement of cursor:CursorId option
  | DeallocateCursorStatement of cursor:CursorId option
  | FetchCursorStatement of cursor:CursorId option * fetchType:FetchType option * intoVariables:(VariableReference) list
  | OpenCursorStatement of cursor:CursorId option
  member this.ToCs() : ScriptDom.CursorStatement =
    match this with
    | CloseCursorStatement(cursor=aCursor) ->
      let ret = ScriptDom.CloseCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CursorStatement (* 404 *)
    | DeallocateCursorStatement(cursor=aCursor) ->
      let ret = ScriptDom.DeallocateCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CursorStatement (* 404 *)
    | FetchCursorStatement(cursor=aCursor; fetchType=aFetchType; intoVariables=aIntoVariables) ->
      let ret = ScriptDom.FetchCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FetchType <- aFetchType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIntoVariables do ret.IntoVariables.Add (e.ToCs())
      ret :> ScriptDom.CursorStatement (* 404 *)
    | OpenCursorStatement(cursor=aCursor) ->
      let ret = ScriptDom.OpenCursorStatement()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CursorStatement (* 404 *)
//// shared props CursorStatement 
  member this.Cursor = 
    match this with
    | CloseCursorStatement(cursor=cursor) -> cursor
    | DeallocateCursorStatement(cursor=cursor) -> cursor
    | FetchCursorStatement(cursor=cursor) -> cursor
    | OpenCursorStatement(cursor=cursor) -> cursor
  static member FromCs(src:ScriptDom.CursorStatement) : CursorStatement =
    match src with
    | :? ScriptDom.CloseCursorStatement as src ->
      CursorStatement.CloseCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)))
    | :? ScriptDom.DeallocateCursorStatement as src ->
      CursorStatement.DeallocateCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)))
    | :? ScriptDom.FetchCursorStatement as src ->
      CursorStatement.FetchCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)), (src.FetchType |> Option.ofObj |> Option.map (FetchType.FromCs)), (src.IntoVariables |> Seq.map (fun src -> VariableReference.VariableReference((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))) |> List.ofSeq))
    | :? ScriptDom.OpenCursorStatement as src ->
      CursorStatement.OpenCursorStatement((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)))
and DatabaseEncryptionKeyStatement = (* IsAbstract = true , children = 2*)
  | AlterDatabaseEncryptionKeyStatement of algorithm:ScriptDom.DatabaseEncryptionKeyAlgorithm * encryptor:CryptoMechanism option * regenerate:bool
  | CreateDatabaseEncryptionKeyStatement of algorithm:ScriptDom.DatabaseEncryptionKeyAlgorithm * encryptor:CryptoMechanism option
  member this.ToCs() : ScriptDom.DatabaseEncryptionKeyStatement =
    match this with
    | AlterDatabaseEncryptionKeyStatement(algorithm=aAlgorithm; encryptor=aEncryptor; regenerate=aRegenerate) ->
      let ret = ScriptDom.AlterDatabaseEncryptionKeyStatement()
      ret.Algorithm <- aAlgorithm
      ret.Encryptor <- aEncryptor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Regenerate <- aRegenerate
      ret :> ScriptDom.DatabaseEncryptionKeyStatement (* 404 *)
    | CreateDatabaseEncryptionKeyStatement(algorithm=aAlgorithm; encryptor=aEncryptor) ->
      let ret = ScriptDom.CreateDatabaseEncryptionKeyStatement()
      ret.Algorithm <- aAlgorithm
      ret.Encryptor <- aEncryptor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DatabaseEncryptionKeyStatement (* 404 *)
//// shared props DatabaseEncryptionKeyStatement 
  member this.Algorithm = 
    match this with
    | AlterDatabaseEncryptionKeyStatement(algorithm=algorithm) -> algorithm
    | CreateDatabaseEncryptionKeyStatement(algorithm=algorithm) -> algorithm
  member this.Encryptor = 
    match this with
    | AlterDatabaseEncryptionKeyStatement(encryptor=encryptor) -> encryptor
    | CreateDatabaseEncryptionKeyStatement(encryptor=encryptor) -> encryptor
  static member FromCs(src:ScriptDom.DatabaseEncryptionKeyStatement) : DatabaseEncryptionKeyStatement =
    match src with
    | :? ScriptDom.AlterDatabaseEncryptionKeyStatement as src ->
      DatabaseEncryptionKeyStatement.AlterDatabaseEncryptionKeyStatement((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)), (src.Regenerate))
    | :? ScriptDom.CreateDatabaseEncryptionKeyStatement as src ->
      DatabaseEncryptionKeyStatement.CreateDatabaseEncryptionKeyStatement((src.Algorithm), (src.Encryptor |> Option.ofObj |> Option.map (CryptoMechanism.FromCs)))
and DropChildObjectsStatement = (* IsAbstract = true , children = 1*)
  | DropStatisticsStatement of objects:(ChildObjectName) list
  member this.ToCs() : ScriptDom.DropChildObjectsStatement =
    match this with
    | DropStatisticsStatement(objects=aObjects) ->
      let ret = ScriptDom.DropStatisticsStatement()
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropChildObjectsStatement (* 404 *)
//// shared props DropChildObjectsStatement 
  member this.Objects = 
    match this with
    | DropStatisticsStatement(objects=objects) -> objects
  static member FromCs(src:ScriptDom.DropChildObjectsStatement) : DropChildObjectsStatement =
    match src with
    | :? ScriptDom.DropStatisticsStatement as src ->
      DropChildObjectsStatement.DropStatisticsStatement((src.Objects |> Seq.map (fun src -> ChildObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ChildIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq))
and DropObjectsStatement = (* IsAbstract = true , children = 13*)
  | DropAggregateStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropAssemblyStatement of isIfExists:bool * objects:(SchemaObjectName) list * withNoDependents:bool
  | DropDefaultStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropExternalTableStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropFunctionStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropProcedureStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropRuleStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropSecurityPolicyStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropSequenceStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropSynonymStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropTableStatement of isIfExists:bool * objects:(SchemaObjectName) list
  | DropTriggerStatement of isIfExists:bool * objects:(SchemaObjectName) list * triggerScope:ScriptDom.TriggerScope
  | DropViewStatement of isIfExists:bool * objects:(SchemaObjectName) list
  member this.ToCs() : ScriptDom.DropObjectsStatement =
    match this with
    | DropAggregateStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropAggregateStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropAssemblyStatement(isIfExists=aIsIfExists; objects=aObjects; withNoDependents=aWithNoDependents) ->
      let ret = ScriptDom.DropAssemblyStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret.WithNoDependents <- aWithNoDependents
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropDefaultStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropDefaultStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropExternalTableStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropExternalTableStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropFunctionStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropFunctionStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropProcedureStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropProcedureStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropRuleStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropRuleStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropSecurityPolicyStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropSecurityPolicyStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropSequenceStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropSequenceStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropSynonymStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropSynonymStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropTableStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropTableStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropTriggerStatement(isIfExists=aIsIfExists; objects=aObjects; triggerScope=aTriggerScope) ->
      let ret = ScriptDom.DropTriggerStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret.TriggerScope <- aTriggerScope
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
    | DropViewStatement(isIfExists=aIsIfExists; objects=aObjects) ->
      let ret = ScriptDom.DropViewStatement()
      ret.IsIfExists <- aIsIfExists
      for e in aObjects do ret.Objects.Add (e.ToCs())
      ret :> ScriptDom.DropObjectsStatement (* 404 *)
//// shared props DropObjectsStatement 
  member this.IsIfExists = 
    match this with
    | DropAggregateStatement(isIfExists=isIfExists) -> isIfExists
    | DropAssemblyStatement(isIfExists=isIfExists) -> isIfExists
    | DropDefaultStatement(isIfExists=isIfExists) -> isIfExists
    | DropExternalTableStatement(isIfExists=isIfExists) -> isIfExists
    | DropFunctionStatement(isIfExists=isIfExists) -> isIfExists
    | DropProcedureStatement(isIfExists=isIfExists) -> isIfExists
    | DropRuleStatement(isIfExists=isIfExists) -> isIfExists
    | DropSecurityPolicyStatement(isIfExists=isIfExists) -> isIfExists
    | DropSequenceStatement(isIfExists=isIfExists) -> isIfExists
    | DropSynonymStatement(isIfExists=isIfExists) -> isIfExists
    | DropTableStatement(isIfExists=isIfExists) -> isIfExists
    | DropTriggerStatement(isIfExists=isIfExists) -> isIfExists
    | DropViewStatement(isIfExists=isIfExists) -> isIfExists
  member this.Objects = 
    match this with
    | DropAggregateStatement(objects=objects) -> objects
    | DropAssemblyStatement(objects=objects) -> objects
    | DropDefaultStatement(objects=objects) -> objects
    | DropExternalTableStatement(objects=objects) -> objects
    | DropFunctionStatement(objects=objects) -> objects
    | DropProcedureStatement(objects=objects) -> objects
    | DropRuleStatement(objects=objects) -> objects
    | DropSecurityPolicyStatement(objects=objects) -> objects
    | DropSequenceStatement(objects=objects) -> objects
    | DropSynonymStatement(objects=objects) -> objects
    | DropTableStatement(objects=objects) -> objects
    | DropTriggerStatement(objects=objects) -> objects
    | DropViewStatement(objects=objects) -> objects
  static member FromCs(src:ScriptDom.DropObjectsStatement) : DropObjectsStatement =
    match src with
    | :? ScriptDom.DropAggregateStatement as src ->
      DropObjectsStatement.DropAggregateStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropAssemblyStatement as src ->
      DropObjectsStatement.DropAssemblyStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq), (src.WithNoDependents))
    | :? ScriptDom.DropDefaultStatement as src ->
      DropObjectsStatement.DropDefaultStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropExternalTableStatement as src ->
      DropObjectsStatement.DropExternalTableStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropFunctionStatement as src ->
      DropObjectsStatement.DropFunctionStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropProcedureStatement as src ->
      DropObjectsStatement.DropProcedureStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropRuleStatement as src ->
      DropObjectsStatement.DropRuleStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropSecurityPolicyStatement as src ->
      DropObjectsStatement.DropSecurityPolicyStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropSequenceStatement as src ->
      DropObjectsStatement.DropSequenceStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropSynonymStatement as src ->
      DropObjectsStatement.DropSynonymStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropTableStatement as src ->
      DropObjectsStatement.DropTableStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
    | :? ScriptDom.DropTriggerStatement as src ->
      DropObjectsStatement.DropTriggerStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq), (src.TriggerScope))
    | :? ScriptDom.DropViewStatement as src ->
      DropObjectsStatement.DropViewStatement((src.IsIfExists), (src.Objects |> Seq.map (SchemaObjectName.FromCs) |> List.ofSeq))
and DropUnownedObjectStatement = (* IsAbstract = true , children = 35*)
  | DropApplicationRoleStatement of isIfExists:bool * name:Identifier option
  | DropAsymmetricKeyStatement of isIfExists:bool * name:Identifier option * removeProviderKey:bool
  | DropAvailabilityGroupStatement of isIfExists:bool * name:Identifier option
  | DropBrokerPriorityStatement of isIfExists:bool * name:Identifier option
  | DropCertificateStatement of isIfExists:bool * name:Identifier option
  | DropColumnEncryptionKeyStatement of isIfExists:bool * name:Identifier option
  | DropColumnMasterKeyStatement of isIfExists:bool * name:Identifier option
  | DropContractStatement of isIfExists:bool * name:Identifier option
  | DropCredentialStatement of isDatabaseScoped:bool * isIfExists:bool * name:Identifier option
  | DropCryptographicProviderStatement of isIfExists:bool * name:Identifier option
  | DropDatabaseAuditSpecificationStatement of isIfExists:bool * name:Identifier option
  | DropEndpointStatement of isIfExists:bool * name:Identifier option
  | DropEventSessionStatement of isIfExists:bool * name:Identifier option * sessionScope:ScriptDom.EventSessionScope
  | DropExternalDataSourceStatement of isIfExists:bool * name:Identifier option
  | DropExternalFileFormatStatement of isIfExists:bool * name:Identifier option
  | DropExternalResourcePoolStatement of isIfExists:bool * name:Identifier option
  | DropFederationStatement of isIfExists:bool * name:Identifier option
  | DropFullTextCatalogStatement of isIfExists:bool * name:Identifier option
  | DropFullTextStopListStatement of isIfExists:bool * name:Identifier option
  | DropLoginStatement of isIfExists:bool * name:Identifier option
  | DropMessageTypeStatement of isIfExists:bool * name:Identifier option
  | DropPartitionFunctionStatement of isIfExists:bool * name:Identifier option
  | DropPartitionSchemeStatement of isIfExists:bool * name:Identifier option
  | DropRemoteServiceBindingStatement of isIfExists:bool * name:Identifier option
  | DropResourcePoolStatement of isIfExists:bool * name:Identifier option
  | DropRoleStatement of isIfExists:bool * name:Identifier option
  | DropRouteStatement of isIfExists:bool * name:Identifier option
  | DropSearchPropertyListStatement of isIfExists:bool * name:Identifier option
  | DropServerAuditSpecificationStatement of isIfExists:bool * name:Identifier option
  | DropServerAuditStatement of isIfExists:bool * name:Identifier option
  | DropServerRoleStatement of isIfExists:bool * name:Identifier option
  | DropServiceStatement of isIfExists:bool * name:Identifier option
  | DropSymmetricKeyStatement of isIfExists:bool * name:Identifier option * removeProviderKey:bool
  | DropUserStatement of isIfExists:bool * name:Identifier option
  | DropWorkloadGroupStatement of isIfExists:bool * name:Identifier option
  member this.ToCs() : ScriptDom.DropUnownedObjectStatement =
    match this with
    | DropApplicationRoleStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropApplicationRoleStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropAsymmetricKeyStatement(isIfExists=aIsIfExists; name=aName; removeProviderKey=aRemoveProviderKey) ->
      let ret = ScriptDom.DropAsymmetricKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RemoveProviderKey <- aRemoveProviderKey
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropAvailabilityGroupStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropAvailabilityGroupStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropBrokerPriorityStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropBrokerPriorityStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropCertificateStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropCertificateStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropColumnEncryptionKeyStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropColumnEncryptionKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropColumnMasterKeyStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropColumnMasterKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropContractStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropContractStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropCredentialStatement(isDatabaseScoped=aIsDatabaseScoped; isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropCredentialStatement()
      ret.IsDatabaseScoped <- aIsDatabaseScoped
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropCryptographicProviderStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropCryptographicProviderStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropDatabaseAuditSpecificationStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropDatabaseAuditSpecificationStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropEndpointStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropEndpointStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropEventSessionStatement(isIfExists=aIsIfExists; name=aName; sessionScope=aSessionScope) ->
      let ret = ScriptDom.DropEventSessionStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SessionScope <- aSessionScope
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropExternalDataSourceStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropExternalDataSourceStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropExternalFileFormatStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropExternalFileFormatStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropExternalResourcePoolStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropExternalResourcePoolStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropFederationStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropFederationStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropFullTextCatalogStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropFullTextCatalogStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropFullTextStopListStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropFullTextStopListStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropLoginStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropLoginStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropMessageTypeStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropMessageTypeStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropPartitionFunctionStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropPartitionFunctionStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropPartitionSchemeStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropPartitionSchemeStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropRemoteServiceBindingStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropRemoteServiceBindingStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropResourcePoolStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropResourcePoolStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropRoleStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropRoleStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropRouteStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropRouteStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropSearchPropertyListStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropSearchPropertyListStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropServerAuditSpecificationStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropServerAuditSpecificationStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropServerAuditStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropServerAuditStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropServerRoleStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropServerRoleStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropServiceStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropServiceStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropSymmetricKeyStatement(isIfExists=aIsIfExists; name=aName; removeProviderKey=aRemoveProviderKey) ->
      let ret = ScriptDom.DropSymmetricKeyStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RemoveProviderKey <- aRemoveProviderKey
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropUserStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropUserStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
    | DropWorkloadGroupStatement(isIfExists=aIsIfExists; name=aName) ->
      let ret = ScriptDom.DropWorkloadGroupStatement()
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DropUnownedObjectStatement (* 404 *)
//// shared props DropUnownedObjectStatement 
  member this.IsIfExists = 
    match this with
    | DropApplicationRoleStatement(isIfExists=isIfExists) -> isIfExists
    | DropAsymmetricKeyStatement(isIfExists=isIfExists) -> isIfExists
    | DropAvailabilityGroupStatement(isIfExists=isIfExists) -> isIfExists
    | DropBrokerPriorityStatement(isIfExists=isIfExists) -> isIfExists
    | DropCertificateStatement(isIfExists=isIfExists) -> isIfExists
    | DropColumnEncryptionKeyStatement(isIfExists=isIfExists) -> isIfExists
    | DropColumnMasterKeyStatement(isIfExists=isIfExists) -> isIfExists
    | DropContractStatement(isIfExists=isIfExists) -> isIfExists
    | DropCredentialStatement(isIfExists=isIfExists) -> isIfExists
    | DropCryptographicProviderStatement(isIfExists=isIfExists) -> isIfExists
    | DropDatabaseAuditSpecificationStatement(isIfExists=isIfExists) -> isIfExists
    | DropEndpointStatement(isIfExists=isIfExists) -> isIfExists
    | DropEventSessionStatement(isIfExists=isIfExists) -> isIfExists
    | DropExternalDataSourceStatement(isIfExists=isIfExists) -> isIfExists
    | DropExternalFileFormatStatement(isIfExists=isIfExists) -> isIfExists
    | DropExternalResourcePoolStatement(isIfExists=isIfExists) -> isIfExists
    | DropFederationStatement(isIfExists=isIfExists) -> isIfExists
    | DropFullTextCatalogStatement(isIfExists=isIfExists) -> isIfExists
    | DropFullTextStopListStatement(isIfExists=isIfExists) -> isIfExists
    | DropLoginStatement(isIfExists=isIfExists) -> isIfExists
    | DropMessageTypeStatement(isIfExists=isIfExists) -> isIfExists
    | DropPartitionFunctionStatement(isIfExists=isIfExists) -> isIfExists
    | DropPartitionSchemeStatement(isIfExists=isIfExists) -> isIfExists
    | DropRemoteServiceBindingStatement(isIfExists=isIfExists) -> isIfExists
    | DropResourcePoolStatement(isIfExists=isIfExists) -> isIfExists
    | DropRoleStatement(isIfExists=isIfExists) -> isIfExists
    | DropRouteStatement(isIfExists=isIfExists) -> isIfExists
    | DropSearchPropertyListStatement(isIfExists=isIfExists) -> isIfExists
    | DropServerAuditSpecificationStatement(isIfExists=isIfExists) -> isIfExists
    | DropServerAuditStatement(isIfExists=isIfExists) -> isIfExists
    | DropServerRoleStatement(isIfExists=isIfExists) -> isIfExists
    | DropServiceStatement(isIfExists=isIfExists) -> isIfExists
    | DropSymmetricKeyStatement(isIfExists=isIfExists) -> isIfExists
    | DropUserStatement(isIfExists=isIfExists) -> isIfExists
    | DropWorkloadGroupStatement(isIfExists=isIfExists) -> isIfExists
  member this.Name = 
    match this with
    | DropApplicationRoleStatement(name=name) -> name
    | DropAsymmetricKeyStatement(name=name) -> name
    | DropAvailabilityGroupStatement(name=name) -> name
    | DropBrokerPriorityStatement(name=name) -> name
    | DropCertificateStatement(name=name) -> name
    | DropColumnEncryptionKeyStatement(name=name) -> name
    | DropColumnMasterKeyStatement(name=name) -> name
    | DropContractStatement(name=name) -> name
    | DropCredentialStatement(name=name) -> name
    | DropCryptographicProviderStatement(name=name) -> name
    | DropDatabaseAuditSpecificationStatement(name=name) -> name
    | DropEndpointStatement(name=name) -> name
    | DropEventSessionStatement(name=name) -> name
    | DropExternalDataSourceStatement(name=name) -> name
    | DropExternalFileFormatStatement(name=name) -> name
    | DropExternalResourcePoolStatement(name=name) -> name
    | DropFederationStatement(name=name) -> name
    | DropFullTextCatalogStatement(name=name) -> name
    | DropFullTextStopListStatement(name=name) -> name
    | DropLoginStatement(name=name) -> name
    | DropMessageTypeStatement(name=name) -> name
    | DropPartitionFunctionStatement(name=name) -> name
    | DropPartitionSchemeStatement(name=name) -> name
    | DropRemoteServiceBindingStatement(name=name) -> name
    | DropResourcePoolStatement(name=name) -> name
    | DropRoleStatement(name=name) -> name
    | DropRouteStatement(name=name) -> name
    | DropSearchPropertyListStatement(name=name) -> name
    | DropServerAuditSpecificationStatement(name=name) -> name
    | DropServerAuditStatement(name=name) -> name
    | DropServerRoleStatement(name=name) -> name
    | DropServiceStatement(name=name) -> name
    | DropSymmetricKeyStatement(name=name) -> name
    | DropUserStatement(name=name) -> name
    | DropWorkloadGroupStatement(name=name) -> name
  static member FromCs(src:ScriptDom.DropUnownedObjectStatement) : DropUnownedObjectStatement =
    match src with
    | :? ScriptDom.DropApplicationRoleStatement as src ->
      DropUnownedObjectStatement.DropApplicationRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropAsymmetricKeyStatement as src ->
      DropUnownedObjectStatement.DropAsymmetricKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RemoveProviderKey))
    | :? ScriptDom.DropAvailabilityGroupStatement as src ->
      DropUnownedObjectStatement.DropAvailabilityGroupStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropBrokerPriorityStatement as src ->
      DropUnownedObjectStatement.DropBrokerPriorityStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropCertificateStatement as src ->
      DropUnownedObjectStatement.DropCertificateStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropColumnEncryptionKeyStatement as src ->
      DropUnownedObjectStatement.DropColumnEncryptionKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropColumnMasterKeyStatement as src ->
      DropUnownedObjectStatement.DropColumnMasterKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropContractStatement as src ->
      DropUnownedObjectStatement.DropContractStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropCredentialStatement as src ->
      DropUnownedObjectStatement.DropCredentialStatement((src.IsDatabaseScoped), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropCryptographicProviderStatement as src ->
      DropUnownedObjectStatement.DropCryptographicProviderStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropDatabaseAuditSpecificationStatement as src ->
      DropUnownedObjectStatement.DropDatabaseAuditSpecificationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropEndpointStatement as src ->
      DropUnownedObjectStatement.DropEndpointStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropEventSessionStatement as src ->
      DropUnownedObjectStatement.DropEventSessionStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionScope))
    | :? ScriptDom.DropExternalDataSourceStatement as src ->
      DropUnownedObjectStatement.DropExternalDataSourceStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropExternalFileFormatStatement as src ->
      DropUnownedObjectStatement.DropExternalFileFormatStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropExternalResourcePoolStatement as src ->
      DropUnownedObjectStatement.DropExternalResourcePoolStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropFederationStatement as src ->
      DropUnownedObjectStatement.DropFederationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropFullTextCatalogStatement as src ->
      DropUnownedObjectStatement.DropFullTextCatalogStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropFullTextStopListStatement as src ->
      DropUnownedObjectStatement.DropFullTextStopListStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropLoginStatement as src ->
      DropUnownedObjectStatement.DropLoginStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropMessageTypeStatement as src ->
      DropUnownedObjectStatement.DropMessageTypeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropPartitionFunctionStatement as src ->
      DropUnownedObjectStatement.DropPartitionFunctionStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropPartitionSchemeStatement as src ->
      DropUnownedObjectStatement.DropPartitionSchemeStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropRemoteServiceBindingStatement as src ->
      DropUnownedObjectStatement.DropRemoteServiceBindingStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropResourcePoolStatement as src ->
      DropUnownedObjectStatement.DropResourcePoolStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropRoleStatement as src ->
      DropUnownedObjectStatement.DropRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropRouteStatement as src ->
      DropUnownedObjectStatement.DropRouteStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropSearchPropertyListStatement as src ->
      DropUnownedObjectStatement.DropSearchPropertyListStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropServerAuditSpecificationStatement as src ->
      DropUnownedObjectStatement.DropServerAuditSpecificationStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropServerAuditStatement as src ->
      DropUnownedObjectStatement.DropServerAuditStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropServerRoleStatement as src ->
      DropUnownedObjectStatement.DropServerRoleStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropServiceStatement as src ->
      DropUnownedObjectStatement.DropServiceStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropSymmetricKeyStatement as src ->
      DropUnownedObjectStatement.DropSymmetricKeyStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RemoveProviderKey))
    | :? ScriptDom.DropUserStatement as src ->
      DropUnownedObjectStatement.DropUserStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.DropWorkloadGroupStatement as src ->
      DropUnownedObjectStatement.DropWorkloadGroupStatement((src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and EventSessionStatement = (* IsAbstract = false , children = 2*)
  | Base of eventDeclarations:(EventDeclaration) list * name:Identifier option * sessionOptions:(SessionOption) list * sessionScope:ScriptDom.EventSessionScope * targetDeclarations:(TargetDeclaration) list
  | AlterEventSessionStatement of dropEventDeclarations:(EventSessionObjectName) list * dropTargetDeclarations:(EventSessionObjectName) list * eventDeclarations:(EventDeclaration) list * name:Identifier option * sessionOptions:(SessionOption) list * sessionScope:ScriptDom.EventSessionScope * statementType:ScriptDom.AlterEventSessionStatementType * targetDeclarations:(TargetDeclaration) list
  | CreateEventSessionStatement of eventDeclarations:(EventDeclaration) list * name:Identifier option * sessionOptions:(SessionOption) list * sessionScope:ScriptDom.EventSessionScope * targetDeclarations:(TargetDeclaration) list
  member this.ToCs() : ScriptDom.EventSessionStatement =
    match this with
    | AlterEventSessionStatement(dropEventDeclarations=aDropEventDeclarations; dropTargetDeclarations=aDropTargetDeclarations; eventDeclarations=aEventDeclarations; name=aName; sessionOptions=aSessionOptions; sessionScope=aSessionScope; statementType=aStatementType; targetDeclarations=aTargetDeclarations) ->
      let ret = ScriptDom.AlterEventSessionStatement()
      for e in aDropEventDeclarations do ret.DropEventDeclarations.Add (e.ToCs())
      for e in aDropTargetDeclarations do ret.DropTargetDeclarations.Add (e.ToCs())
      for e in aEventDeclarations do ret.EventDeclarations.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSessionOptions do ret.SessionOptions.Add (e.ToCs())
      ret.SessionScope <- aSessionScope
      ret.StatementType <- aStatementType
      for e in aTargetDeclarations do ret.TargetDeclarations.Add (e.ToCs())
      ret :> ScriptDom.EventSessionStatement (* 404 *)
    | CreateEventSessionStatement(eventDeclarations=aEventDeclarations; name=aName; sessionOptions=aSessionOptions; sessionScope=aSessionScope; targetDeclarations=aTargetDeclarations) ->
      let ret = ScriptDom.CreateEventSessionStatement()
      for e in aEventDeclarations do ret.EventDeclarations.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSessionOptions do ret.SessionOptions.Add (e.ToCs())
      ret.SessionScope <- aSessionScope
      for e in aTargetDeclarations do ret.TargetDeclarations.Add (e.ToCs())
      ret :> ScriptDom.EventSessionStatement (* 404 *)
    | Base(eventDeclarations=aEventDeclarations; name=aName; sessionOptions=aSessionOptions; sessionScope=aSessionScope; targetDeclarations=aTargetDeclarations) ->

      let ret = ScriptDom.EventSessionStatement()
      for e in aEventDeclarations do ret.EventDeclarations.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSessionOptions do ret.SessionOptions.Add (e.ToCs())
      ret.SessionScope <- aSessionScope
      for e in aTargetDeclarations do ret.TargetDeclarations.Add (e.ToCs())
      ret
//// shared props EventSessionStatement 
  member this.EventDeclarations = 
    match this with
    | Base (eventDeclarations=eventDeclarations) -> eventDeclarations
    | AlterEventSessionStatement(eventDeclarations=eventDeclarations) -> eventDeclarations
    | CreateEventSessionStatement(eventDeclarations=eventDeclarations) -> eventDeclarations
  member this.Name = 
    match this with
    | Base (name=name) -> name
    | AlterEventSessionStatement(name=name) -> name
    | CreateEventSessionStatement(name=name) -> name
  member this.SessionOptions = 
    match this with
    | Base (sessionOptions=sessionOptions) -> sessionOptions
    | AlterEventSessionStatement(sessionOptions=sessionOptions) -> sessionOptions
    | CreateEventSessionStatement(sessionOptions=sessionOptions) -> sessionOptions
  member this.SessionScope = 
    match this with
    | Base (sessionScope=sessionScope) -> sessionScope
    | AlterEventSessionStatement(sessionScope=sessionScope) -> sessionScope
    | CreateEventSessionStatement(sessionScope=sessionScope) -> sessionScope
  member this.TargetDeclarations = 
    match this with
    | Base (targetDeclarations=targetDeclarations) -> targetDeclarations
    | AlterEventSessionStatement(targetDeclarations=targetDeclarations) -> targetDeclarations
    | CreateEventSessionStatement(targetDeclarations=targetDeclarations) -> targetDeclarations
  static member FromCs(src:ScriptDom.EventSessionStatement) : EventSessionStatement =
    match src with
    | :? ScriptDom.AlterEventSessionStatement as src ->
      EventSessionStatement.AlterEventSessionStatement((src.DropEventDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.DropTargetDeclarations |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionOptions |> Seq.map (SessionOption.FromCs) |> List.ofSeq), (src.SessionScope), (src.StatementType), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq))
    | :? ScriptDom.CreateEventSessionStatement as src ->
      EventSessionStatement.CreateEventSessionStatement((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionOptions |> Seq.map (SessionOption.FromCs) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq))
    | _ -> (* :? ScriptDom.EventSessionStatement as src *)
      EventSessionStatement.Base(((src.EventDeclarations |> Seq.map (fun src -> EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SessionOptions |> Seq.map (SessionOption.FromCs) |> List.ofSeq), (src.SessionScope), (src.TargetDeclarations |> Seq.map (fun src -> TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq)))
and ExternalDataSourceStatement = (* IsAbstract = true , children = 2*)
  | AlterExternalDataSourceStatement of dataSourceType:ScriptDom.ExternalDataSourceType * externalDataSourceOptions:(ExternalDataSourceOption) list * location:Literal option * name:Identifier option
  | CreateExternalDataSourceStatement of dataSourceType:ScriptDom.ExternalDataSourceType * externalDataSourceOptions:(ExternalDataSourceOption) list * location:Literal option * name:Identifier option
  member this.ToCs() : ScriptDom.ExternalDataSourceStatement =
    match this with
    | AlterExternalDataSourceStatement(dataSourceType=aDataSourceType; externalDataSourceOptions=aExternalDataSourceOptions; location=aLocation; name=aName) ->
      let ret = ScriptDom.AlterExternalDataSourceStatement()
      ret.DataSourceType <- aDataSourceType
      for e in aExternalDataSourceOptions do ret.ExternalDataSourceOptions.Add (e.ToCs())
      ret.Location <- aLocation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalDataSourceStatement (* 404 *)
    | CreateExternalDataSourceStatement(dataSourceType=aDataSourceType; externalDataSourceOptions=aExternalDataSourceOptions; location=aLocation; name=aName) ->
      let ret = ScriptDom.CreateExternalDataSourceStatement()
      ret.DataSourceType <- aDataSourceType
      for e in aExternalDataSourceOptions do ret.ExternalDataSourceOptions.Add (e.ToCs())
      ret.Location <- aLocation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalDataSourceStatement (* 404 *)
//// shared props ExternalDataSourceStatement 
  member this.DataSourceType = 
    match this with
    | AlterExternalDataSourceStatement(dataSourceType=dataSourceType) -> dataSourceType
    | CreateExternalDataSourceStatement(dataSourceType=dataSourceType) -> dataSourceType
  member this.ExternalDataSourceOptions = 
    match this with
    | AlterExternalDataSourceStatement(externalDataSourceOptions=externalDataSourceOptions) -> externalDataSourceOptions
    | CreateExternalDataSourceStatement(externalDataSourceOptions=externalDataSourceOptions) -> externalDataSourceOptions
  member this.Location = 
    match this with
    | AlterExternalDataSourceStatement(location=location) -> location
    | CreateExternalDataSourceStatement(location=location) -> location
  member this.Name = 
    match this with
    | AlterExternalDataSourceStatement(name=name) -> name
    | CreateExternalDataSourceStatement(name=name) -> name
  static member FromCs(src:ScriptDom.ExternalDataSourceStatement) : ExternalDataSourceStatement =
    match src with
    | :? ScriptDom.AlterExternalDataSourceStatement as src ->
      ExternalDataSourceStatement.AlterExternalDataSourceStatement((src.DataSourceType), (src.ExternalDataSourceOptions |> Seq.map (ExternalDataSourceOption.FromCs) |> List.ofSeq), (src.Location |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateExternalDataSourceStatement as src ->
      ExternalDataSourceStatement.CreateExternalDataSourceStatement((src.DataSourceType), (src.ExternalDataSourceOptions |> Seq.map (ExternalDataSourceOption.FromCs) |> List.ofSeq), (src.Location |> Option.ofObj |> Option.map (Literal.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and ExternalFileFormatStatement = (* IsAbstract = true , children = 1*)
  | CreateExternalFileFormatStatement of externalFileFormatOptions:(ExternalFileFormatOption) list * formatType:ScriptDom.ExternalFileFormatType * name:Identifier option
  member this.ToCs() : ScriptDom.ExternalFileFormatStatement =
    match this with
    | CreateExternalFileFormatStatement(externalFileFormatOptions=aExternalFileFormatOptions; formatType=aFormatType; name=aName) ->
      let ret = ScriptDom.CreateExternalFileFormatStatement()
      for e in aExternalFileFormatOptions do ret.ExternalFileFormatOptions.Add (e.ToCs())
      ret.FormatType <- aFormatType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalFileFormatStatement (* 404 *)
//// shared props ExternalFileFormatStatement 
  member this.ExternalFileFormatOptions = 
    match this with
    | CreateExternalFileFormatStatement(externalFileFormatOptions=externalFileFormatOptions) -> externalFileFormatOptions
  member this.FormatType = 
    match this with
    | CreateExternalFileFormatStatement(formatType=formatType) -> formatType
  member this.Name = 
    match this with
    | CreateExternalFileFormatStatement(name=name) -> name
  static member FromCs(src:ScriptDom.ExternalFileFormatStatement) : ExternalFileFormatStatement =
    match src with
    | :? ScriptDom.CreateExternalFileFormatStatement as src ->
      ExternalFileFormatStatement.CreateExternalFileFormatStatement((src.ExternalFileFormatOptions |> Seq.map (ExternalFileFormatOption.FromCs) |> List.ofSeq), (src.FormatType), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and ExternalResourcePoolStatement = (* IsAbstract = false , children = 2*)
  | Base of externalResourcePoolParameters:(ExternalResourcePoolParameter) list * name:Identifier option
  | AlterExternalResourcePoolStatement of externalResourcePoolParameters:(ExternalResourcePoolParameter) list * name:Identifier option
  | CreateExternalResourcePoolStatement of externalResourcePoolParameters:(ExternalResourcePoolParameter) list * name:Identifier option
  member this.ToCs() : ScriptDom.ExternalResourcePoolStatement =
    match this with
    | AlterExternalResourcePoolStatement(externalResourcePoolParameters=aExternalResourcePoolParameters; name=aName) ->
      let ret = ScriptDom.AlterExternalResourcePoolStatement()
      for e in aExternalResourcePoolParameters do ret.ExternalResourcePoolParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalResourcePoolStatement (* 404 *)
    | CreateExternalResourcePoolStatement(externalResourcePoolParameters=aExternalResourcePoolParameters; name=aName) ->
      let ret = ScriptDom.CreateExternalResourcePoolStatement()
      for e in aExternalResourcePoolParameters do ret.ExternalResourcePoolParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalResourcePoolStatement (* 404 *)
    | Base(externalResourcePoolParameters=aExternalResourcePoolParameters; name=aName) ->

      let ret = ScriptDom.ExternalResourcePoolStatement()
      for e in aExternalResourcePoolParameters do ret.ExternalResourcePoolParameters.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props ExternalResourcePoolStatement 
  member this.ExternalResourcePoolParameters = 
    match this with
    | Base (externalResourcePoolParameters=externalResourcePoolParameters) -> externalResourcePoolParameters
    | AlterExternalResourcePoolStatement(externalResourcePoolParameters=externalResourcePoolParameters) -> externalResourcePoolParameters
    | CreateExternalResourcePoolStatement(externalResourcePoolParameters=externalResourcePoolParameters) -> externalResourcePoolParameters
  member this.Name = 
    match this with
    | Base (name=name) -> name
    | AlterExternalResourcePoolStatement(name=name) -> name
    | CreateExternalResourcePoolStatement(name=name) -> name
  static member FromCs(src:ScriptDom.ExternalResourcePoolStatement) : ExternalResourcePoolStatement =
    match src with
    | :? ScriptDom.AlterExternalResourcePoolStatement as src ->
      ExternalResourcePoolStatement.AlterExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateExternalResourcePoolStatement as src ->
      ExternalResourcePoolStatement.CreateExternalResourcePoolStatement((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | _ -> (* :? ScriptDom.ExternalResourcePoolStatement as src *)
      ExternalResourcePoolStatement.Base(((src.ExternalResourcePoolParameters |> Seq.map (fun src -> ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs))))
and ExternalTableStatement = (* IsAbstract = true , children = 1*)
  | CreateExternalTableStatement of columnDefinitions:(ExternalTableColumnDefinition) list * dataSource:Identifier option * externalTableOptions:(ExternalTableOption) list * schemaObjectName:SchemaObjectName option
  member this.ToCs() : ScriptDom.ExternalTableStatement =
    match this with
    | CreateExternalTableStatement(columnDefinitions=aColumnDefinitions; dataSource=aDataSource; externalTableOptions=aExternalTableOptions; schemaObjectName=aSchemaObjectName) ->
      let ret = ScriptDom.CreateExternalTableStatement()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      ret.DataSource <- aDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aExternalTableOptions do ret.ExternalTableOptions.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ExternalTableStatement (* 404 *)
//// shared props ExternalTableStatement 
  member this.ColumnDefinitions = 
    match this with
    | CreateExternalTableStatement(columnDefinitions=columnDefinitions) -> columnDefinitions
  member this.DataSource = 
    match this with
    | CreateExternalTableStatement(dataSource=dataSource) -> dataSource
  member this.ExternalTableOptions = 
    match this with
    | CreateExternalTableStatement(externalTableOptions=externalTableOptions) -> externalTableOptions
  member this.SchemaObjectName = 
    match this with
    | CreateExternalTableStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
  static member FromCs(src:ScriptDom.ExternalTableStatement) : ExternalTableStatement =
    match src with
    | :? ScriptDom.CreateExternalTableStatement as src ->
      ExternalTableStatement.CreateExternalTableStatement((src.ColumnDefinitions |> Seq.map (fun src -> ExternalTableColumnDefinition.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullableConstraint |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))) |> List.ofSeq), (src.DataSource |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ExternalTableOptions |> Seq.map (ExternalTableOption.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and FullTextCatalogStatement = (* IsAbstract = true , children = 2*)
  | AlterFullTextCatalogStatement of action:ScriptDom.AlterFullTextCatalogAction * name:Identifier option * options:(FullTextCatalogOption) list
  | CreateFullTextCatalogStatement of fileGroup:Identifier option * isDefault:bool * name:Identifier option * options:(FullTextCatalogOption) list * owner:Identifier option * path:Literal option
  member this.ToCs() : ScriptDom.FullTextCatalogStatement =
    match this with
    | AlterFullTextCatalogStatement(action=aAction; name=aName; options=aOptions) ->
      let ret = ScriptDom.AlterFullTextCatalogStatement()
      ret.Action <- aAction
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.FullTextCatalogStatement (* 404 *)
    | CreateFullTextCatalogStatement(fileGroup=aFileGroup; isDefault=aIsDefault; name=aName; options=aOptions; owner=aOwner; path=aPath) ->
      let ret = ScriptDom.CreateFullTextCatalogStatement()
      ret.FileGroup <- aFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDefault <- aIsDefault
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FullTextCatalogStatement (* 404 *)
//// shared props FullTextCatalogStatement 
  member this.Name = 
    match this with
    | AlterFullTextCatalogStatement(name=name) -> name
    | CreateFullTextCatalogStatement(name=name) -> name
  member this.Options = 
    match this with
    | AlterFullTextCatalogStatement(options=options) -> options
    | CreateFullTextCatalogStatement(options=options) -> options
  static member FromCs(src:ScriptDom.FullTextCatalogStatement) : FullTextCatalogStatement =
    match src with
    | :? ScriptDom.AlterFullTextCatalogStatement as src ->
      FullTextCatalogStatement.AlterFullTextCatalogStatement((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (FullTextCatalogOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateFullTextCatalogStatement as src ->
      FullTextCatalogStatement.CreateFullTextCatalogStatement((src.FileGroup |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (FullTextCatalogOption.FromCs) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)))
and IndexStatement = (* IsAbstract = true , children = 4*)
  | AlterIndexStatement of all:bool * alterIndexType:ScriptDom.AlterIndexType * indexOptions:(IndexOption) list * name:Identifier option * onName:SchemaObjectName option * partition:PartitionSpecifier option * promotedPaths:(SelectiveXmlIndexPromotedPath) list * xmlNamespaces:XmlNamespaces option
  | CreateIndexStatement of clustered:(bool) option * columns:(ColumnWithSortOrder) list * fileStreamOn:IdentifierOrValueExpression option * filterPredicate:BooleanExpression option * includeColumns:(ColumnReferenceExpression) list * indexOptions:(IndexOption) list * name:Identifier option * onFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * onName:SchemaObjectName option * translated80SyntaxTo90:bool * unique:bool
  | CreateSelectiveXmlIndexStatement of indexOptions:(IndexOption) list * isSecondary:bool * name:Identifier option * onName:SchemaObjectName option * pathName:Identifier option * promotedPaths:(SelectiveXmlIndexPromotedPath) list * usingXmlIndexName:Identifier option * xmlColumn:Identifier option * xmlNamespaces:XmlNamespaces option
  | CreateXmlIndexStatement of indexOptions:(IndexOption) list * name:Identifier option * onName:SchemaObjectName option * primary:bool * secondaryXmlIndexName:Identifier option * secondaryXmlIndexType:ScriptDom.SecondaryXmlIndexType * xmlColumn:Identifier option
  member this.ToCs() : ScriptDom.IndexStatement =
    match this with
    | AlterIndexStatement(all=aAll; alterIndexType=aAlterIndexType; indexOptions=aIndexOptions; name=aName; onName=aOnName; partition=aPartition; promotedPaths=aPromotedPaths; xmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.AlterIndexStatement()
      ret.All <- aAll
      ret.AlterIndexType <- aAlterIndexType
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Partition <- aPartition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPromotedPaths do ret.PromotedPaths.Add (e.ToCs())
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.IndexStatement (* 404 *)
    | CreateIndexStatement(clustered=aClustered; columns=aColumns; fileStreamOn=aFileStreamOn; filterPredicate=aFilterPredicate; includeColumns=aIncludeColumns; indexOptions=aIndexOptions; name=aName; onFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; onName=aOnName; translated80SyntaxTo90=aTranslated80SyntaxTo90; unique=aUnique) ->
      let ret = ScriptDom.CreateIndexStatement()
      ret.Clustered <- Option.toNullable aClustered
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIncludeColumns do ret.IncludeColumns.Add (e.ToCs())
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Translated80SyntaxTo90 <- aTranslated80SyntaxTo90
      ret.Unique <- aUnique
      ret :> ScriptDom.IndexStatement (* 404 *)
    | CreateSelectiveXmlIndexStatement(indexOptions=aIndexOptions; isSecondary=aIsSecondary; name=aName; onName=aOnName; pathName=aPathName; promotedPaths=aPromotedPaths; usingXmlIndexName=aUsingXmlIndexName; xmlColumn=aXmlColumn; xmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.CreateSelectiveXmlIndexStatement()
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IsSecondary <- aIsSecondary
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PathName <- aPathName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPromotedPaths do ret.PromotedPaths.Add (e.ToCs())
      ret.UsingXmlIndexName <- aUsingXmlIndexName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XmlColumn <- aXmlColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.IndexStatement (* 404 *)
    | CreateXmlIndexStatement(indexOptions=aIndexOptions; name=aName; onName=aOnName; primary=aPrimary; secondaryXmlIndexName=aSecondaryXmlIndexName; secondaryXmlIndexType=aSecondaryXmlIndexType; xmlColumn=aXmlColumn) ->
      let ret = ScriptDom.CreateXmlIndexStatement()
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnName <- aOnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Primary <- aPrimary
      ret.SecondaryXmlIndexName <- aSecondaryXmlIndexName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondaryXmlIndexType <- aSecondaryXmlIndexType
      ret.XmlColumn <- aXmlColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.IndexStatement (* 404 *)
//// shared props IndexStatement 
  member this.IndexOptions = 
    match this with
    | AlterIndexStatement(indexOptions=indexOptions) -> indexOptions
    | CreateIndexStatement(indexOptions=indexOptions) -> indexOptions
    | CreateSelectiveXmlIndexStatement(indexOptions=indexOptions) -> indexOptions
    | CreateXmlIndexStatement(indexOptions=indexOptions) -> indexOptions
  member this.Name = 
    match this with
    | AlterIndexStatement(name=name) -> name
    | CreateIndexStatement(name=name) -> name
    | CreateSelectiveXmlIndexStatement(name=name) -> name
    | CreateXmlIndexStatement(name=name) -> name
  member this.OnName = 
    match this with
    | AlterIndexStatement(onName=onName) -> onName
    | CreateIndexStatement(onName=onName) -> onName
    | CreateSelectiveXmlIndexStatement(onName=onName) -> onName
    | CreateXmlIndexStatement(onName=onName) -> onName
  static member FromCs(src:ScriptDom.IndexStatement) : IndexStatement =
    match src with
    | :? ScriptDom.AlterIndexStatement as src ->
      IndexStatement.AlterIndexStatement((src.All), (src.AlterIndexType), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Partition |> Option.ofObj |> Option.map (PartitionSpecifier.FromCs)), (src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)), (src.SQLDataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.XQueryDataType |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.XmlNamespaces |> Option.ofObj |> Option.map (XmlNamespaces.FromCs)))
    | :? ScriptDom.CreateIndexStatement as src ->
      IndexStatement.CreateIndexStatement((Option.ofNullable (src.Clustered)), (src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IncludeColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Translated80SyntaxTo90), (src.Unique))
    | :? ScriptDom.CreateSelectiveXmlIndexStatement as src ->
      IndexStatement.CreateSelectiveXmlIndexStatement((src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IsSecondary), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.PathName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PromotedPaths |> Seq.map (fun src -> SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)), (src.SQLDataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.XQueryDataType |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.UsingXmlIndexName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.XmlColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.XmlNamespaces |> Option.ofObj |> Option.map (XmlNamespaces.FromCs)))
    | :? ScriptDom.CreateXmlIndexStatement as src ->
      IndexStatement.CreateXmlIndexStatement((src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Primary), (src.SecondaryXmlIndexName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SecondaryXmlIndexType), (src.XmlColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
and MasterKeyStatement = (* IsAbstract = true , children = 2*)
  | AlterMasterKeyStatement of option:ScriptDom.AlterMasterKeyOption * password:Literal option
  | CreateMasterKeyStatement of password:Literal option
  member this.ToCs() : ScriptDom.MasterKeyStatement =
    match this with
    | AlterMasterKeyStatement(option=aOption; password=aPassword) ->
      let ret = ScriptDom.AlterMasterKeyStatement()
      ret.Option <- aOption
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MasterKeyStatement (* 404 *)
    | CreateMasterKeyStatement(password=aPassword) ->
      let ret = ScriptDom.CreateMasterKeyStatement()
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MasterKeyStatement (* 404 *)
//// shared props MasterKeyStatement 
  member this.Password = 
    match this with
    | AlterMasterKeyStatement(password=password) -> password
    | CreateMasterKeyStatement(password=password) -> password
  static member FromCs(src:ScriptDom.MasterKeyStatement) : MasterKeyStatement =
    match src with
    | :? ScriptDom.AlterMasterKeyStatement as src ->
      MasterKeyStatement.AlterMasterKeyStatement((src.Option), (src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
    | :? ScriptDom.CreateMasterKeyStatement as src ->
      MasterKeyStatement.CreateMasterKeyStatement((src.Password |> Option.ofObj |> Option.map (Literal.FromCs)))
and MessageTypeStatementBase = (* IsAbstract = true , children = 2*)
  | AlterMessageTypeStatement of name:Identifier option * validationMethod:ScriptDom.MessageValidationMethod * xmlSchemaCollectionName:SchemaObjectName option
  | CreateMessageTypeStatement of name:Identifier option * owner:Identifier option * validationMethod:ScriptDom.MessageValidationMethod * xmlSchemaCollectionName:SchemaObjectName option
  member this.ToCs() : ScriptDom.MessageTypeStatementBase =
    match this with
    | AlterMessageTypeStatement(name=aName; validationMethod=aValidationMethod; xmlSchemaCollectionName=aXmlSchemaCollectionName) ->
      let ret = ScriptDom.AlterMessageTypeStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValidationMethod <- aValidationMethod
      ret.XmlSchemaCollectionName <- aXmlSchemaCollectionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MessageTypeStatementBase (* 404 *)
    | CreateMessageTypeStatement(name=aName; owner=aOwner; validationMethod=aValidationMethod; xmlSchemaCollectionName=aXmlSchemaCollectionName) ->
      let ret = ScriptDom.CreateMessageTypeStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValidationMethod <- aValidationMethod
      ret.XmlSchemaCollectionName <- aXmlSchemaCollectionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.MessageTypeStatementBase (* 404 *)
//// shared props MessageTypeStatementBase 
  member this.Name = 
    match this with
    | AlterMessageTypeStatement(name=name) -> name
    | CreateMessageTypeStatement(name=name) -> name
  member this.ValidationMethod = 
    match this with
    | AlterMessageTypeStatement(validationMethod=validationMethod) -> validationMethod
    | CreateMessageTypeStatement(validationMethod=validationMethod) -> validationMethod
  member this.XmlSchemaCollectionName = 
    match this with
    | AlterMessageTypeStatement(xmlSchemaCollectionName=xmlSchemaCollectionName) -> xmlSchemaCollectionName
    | CreateMessageTypeStatement(xmlSchemaCollectionName=xmlSchemaCollectionName) -> xmlSchemaCollectionName
  static member FromCs(src:ScriptDom.MessageTypeStatementBase) : MessageTypeStatementBase =
    match src with
    | :? ScriptDom.AlterMessageTypeStatement as src ->
      MessageTypeStatementBase.AlterMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ValidationMethod), (src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.CreateMessageTypeStatement as src ->
      MessageTypeStatementBase.CreateMessageTypeStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ValidationMethod), (src.XmlSchemaCollectionName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and ProcedureStatementBodyBase = (* IsAbstract = true , children = 2*)
  | FunctionStatementBody of functionStatementBody:FunctionStatementBody
  | ProcedureStatementBody of procedureStatementBody:ProcedureStatementBody
  member this.ToCs() : ScriptDom.ProcedureStatementBodyBase =
    match this with
    | FunctionStatementBody(x) -> x.ToCs() :> ScriptDom.ProcedureStatementBodyBase (* 414 *)
    | ProcedureStatementBody(x) -> x.ToCs() :> ScriptDom.ProcedureStatementBodyBase (* 414 *)
//// shared props ProcedureStatementBodyBase 
  member this.MethodSpecifier = 
    match this with
    | FunctionStatementBody _ as x -> x.MethodSpecifier
    | ProcedureStatementBody _ as x -> x.MethodSpecifier
  member this.Parameters = 
    match this with
    | FunctionStatementBody _ as x -> x.Parameters
    | ProcedureStatementBody _ as x -> x.Parameters
  member this.StatementList = 
    match this with
    | FunctionStatementBody _ as x -> x.StatementList
    | ProcedureStatementBody _ as x -> x.StatementList
  static member FromCs(src:ScriptDom.ProcedureStatementBodyBase) : ProcedureStatementBodyBase =
    match src with
    | :? ScriptDom.FunctionStatementBody as src ->
      match src with
      | :? ScriptDom.AlterFunctionStatement as src->
        ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.AlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FunctionOption.FromCs) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (OrderBulkInsertOption.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (FunctionReturnType.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | :? ScriptDom.CreateFunctionStatement as src->
        ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.CreateFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FunctionOption.FromCs) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (OrderBulkInsertOption.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (FunctionReturnType.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | :? ScriptDom.CreateOrAlterFunctionStatement as src->
        ProcedureStatementBodyBase.FunctionStatementBody((FunctionStatementBody.CreateOrAlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FunctionOption.FromCs) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (OrderBulkInsertOption.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (FunctionReturnType.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
    | :? ScriptDom.ProcedureStatementBody as src ->
      match src with
      | :? ScriptDom.AlterProcedureStatement as src->
        ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.AlterProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Options |> Seq.map (ProcedureOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | :? ScriptDom.CreateOrAlterProcedureStatement as src->
        ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.CreateOrAlterProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Options |> Seq.map (ProcedureOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
      | :? ScriptDom.CreateProcedureStatement as src->
        ProcedureStatementBodyBase.ProcedureStatementBody((ProcedureStatementBody.CreateProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Options |> Seq.map (ProcedureOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))))
and QueueStatement = (* IsAbstract = true , children = 2*)
  | AlterQueueStatement of name:SchemaObjectName option * queueOptions:(QueueOption) list
  | CreateQueueStatement of name:SchemaObjectName option * onFileGroup:IdentifierOrValueExpression option * queueOptions:(QueueOption) list
  member this.ToCs() : ScriptDom.QueueStatement =
    match this with
    | AlterQueueStatement(name=aName; queueOptions=aQueueOptions) ->
      let ret = ScriptDom.AlterQueueStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aQueueOptions do ret.QueueOptions.Add (e.ToCs())
      ret :> ScriptDom.QueueStatement (* 404 *)
    | CreateQueueStatement(name=aName; onFileGroup=aOnFileGroup; queueOptions=aQueueOptions) ->
      let ret = ScriptDom.CreateQueueStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroup <- aOnFileGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aQueueOptions do ret.QueueOptions.Add (e.ToCs())
      ret :> ScriptDom.QueueStatement (* 404 *)
//// shared props QueueStatement 
  member this.Name = 
    match this with
    | AlterQueueStatement(name=name) -> name
    | CreateQueueStatement(name=name) -> name
  member this.QueueOptions = 
    match this with
    | AlterQueueStatement(queueOptions=queueOptions) -> queueOptions
    | CreateQueueStatement(queueOptions=queueOptions) -> queueOptions
  static member FromCs(src:ScriptDom.QueueStatement) : QueueStatement =
    match src with
    | :? ScriptDom.AlterQueueStatement as src ->
      QueueStatement.AlterQueueStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.QueueOptions |> Seq.map (QueueOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateQueueStatement as src ->
      QueueStatement.CreateQueueStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.OnFileGroup |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.QueueOptions |> Seq.map (QueueOption.FromCs) |> List.ofSeq))
and RemoteServiceBindingStatementBase = (* IsAbstract = true , children = 2*)
  | AlterRemoteServiceBindingStatement of name:Identifier option * options:(RemoteServiceBindingOption) list
  | CreateRemoteServiceBindingStatement of name:Identifier option * options:(RemoteServiceBindingOption) list * owner:Identifier option * service:Literal option
  member this.ToCs() : ScriptDom.RemoteServiceBindingStatementBase =
    match this with
    | AlterRemoteServiceBindingStatement(name=aName; options=aOptions) ->
      let ret = ScriptDom.AlterRemoteServiceBindingStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.RemoteServiceBindingStatementBase (* 404 *)
    | CreateRemoteServiceBindingStatement(name=aName; options=aOptions; owner=aOwner; service=aService) ->
      let ret = ScriptDom.CreateRemoteServiceBindingStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Service <- aService |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.RemoteServiceBindingStatementBase (* 404 *)
//// shared props RemoteServiceBindingStatementBase 
  member this.Name = 
    match this with
    | AlterRemoteServiceBindingStatement(name=name) -> name
    | CreateRemoteServiceBindingStatement(name=name) -> name
  member this.Options = 
    match this with
    | AlterRemoteServiceBindingStatement(options=options) -> options
    | CreateRemoteServiceBindingStatement(options=options) -> options
  static member FromCs(src:ScriptDom.RemoteServiceBindingStatementBase) : RemoteServiceBindingStatementBase =
    match src with
    | :? ScriptDom.AlterRemoteServiceBindingStatement as src ->
      RemoteServiceBindingStatementBase.AlterRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (RemoteServiceBindingOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateRemoteServiceBindingStatement as src ->
      RemoteServiceBindingStatementBase.CreateRemoteServiceBindingStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (RemoteServiceBindingOption.FromCs) |> List.ofSeq), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Service |> Option.ofObj |> Option.map (Literal.FromCs)))
and ResourcePoolStatement = (* IsAbstract = false , children = 2*)
  | Base of name:Identifier option * resourcePoolParameters:(ResourcePoolParameter) list
  | AlterResourcePoolStatement of name:Identifier option * resourcePoolParameters:(ResourcePoolParameter) list
  | CreateResourcePoolStatement of name:Identifier option * resourcePoolParameters:(ResourcePoolParameter) list
  member this.ToCs() : ScriptDom.ResourcePoolStatement =
    match this with
    | AlterResourcePoolStatement(name=aName; resourcePoolParameters=aResourcePoolParameters) ->
      let ret = ScriptDom.AlterResourcePoolStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aResourcePoolParameters do ret.ResourcePoolParameters.Add (e.ToCs())
      ret :> ScriptDom.ResourcePoolStatement (* 404 *)
    | CreateResourcePoolStatement(name=aName; resourcePoolParameters=aResourcePoolParameters) ->
      let ret = ScriptDom.CreateResourcePoolStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aResourcePoolParameters do ret.ResourcePoolParameters.Add (e.ToCs())
      ret :> ScriptDom.ResourcePoolStatement (* 404 *)
    | Base(name=aName; resourcePoolParameters=aResourcePoolParameters) ->

      let ret = ScriptDom.ResourcePoolStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aResourcePoolParameters do ret.ResourcePoolParameters.Add (e.ToCs())
      ret
//// shared props ResourcePoolStatement 
  member this.Name = 
    match this with
    | Base (name=name) -> name
    | AlterResourcePoolStatement(name=name) -> name
    | CreateResourcePoolStatement(name=name) -> name
  member this.ResourcePoolParameters = 
    match this with
    | Base (resourcePoolParameters=resourcePoolParameters) -> resourcePoolParameters
    | AlterResourcePoolStatement(resourcePoolParameters=resourcePoolParameters) -> resourcePoolParameters
    | CreateResourcePoolStatement(resourcePoolParameters=resourcePoolParameters) -> resourcePoolParameters
  static member FromCs(src:ScriptDom.ResourcePoolStatement) : ResourcePoolStatement =
    match src with
    | :? ScriptDom.AlterResourcePoolStatement as src ->
      ResourcePoolStatement.AlterResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.CreateResourcePoolStatement as src ->
      ResourcePoolStatement.CreateResourcePoolStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq))
    | _ -> (* :? ScriptDom.ResourcePoolStatement as src *)
      ResourcePoolStatement.Base(((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ResourcePoolParameters |> Seq.map (fun src -> ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq)))
and RoleStatement = (* IsAbstract = true , children = 2*)
  | AlterRoleStatement of alterRoleStatement:AlterRoleStatement
  | CreateRoleStatement of createRoleStatement:CreateRoleStatement
  member this.ToCs() : ScriptDom.RoleStatement =
    match this with
    | AlterRoleStatement(x) -> x.ToCs() :> ScriptDom.RoleStatement (* 414 *)
    | CreateRoleStatement(x) -> x.ToCs() :> ScriptDom.RoleStatement (* 414 *)
//// shared props RoleStatement 
  member this.Name = 
    match this with
    | AlterRoleStatement _ as x -> x.Name
    | CreateRoleStatement _ as x -> x.Name
  static member FromCs(src:ScriptDom.RoleStatement) : RoleStatement =
    match src with
    | :? ScriptDom.AlterRoleStatement as src ->
      match src with
      | :? ScriptDom.AlterServerRoleStatement as src->
        RoleStatement.AlterRoleStatement((AlterRoleStatement.AlterServerRoleStatement((src.Action |> Option.ofObj |> Option.map (AlterRoleAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | _ -> (* :? ScriptDom.AlterRoleStatement as src *)
        RoleStatement.AlterRoleStatement((AlterRoleStatement.Base((src.Action |> Option.ofObj |> Option.map (AlterRoleAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))))
    | :? ScriptDom.CreateRoleStatement as src ->
      match src with
      | :? ScriptDom.CreateServerRoleStatement as src->
        RoleStatement.CreateRoleStatement((CreateRoleStatement.CreateServerRoleStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)))))
      | _ -> (* :? ScriptDom.CreateRoleStatement as src *)
        RoleStatement.CreateRoleStatement((CreateRoleStatement.Base((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)))))
and RouteStatement = (* IsAbstract = true , children = 2*)
  | AlterRouteStatement of name:Identifier option * routeOptions:(RouteOption) list
  | CreateRouteStatement of name:Identifier option * owner:Identifier option * routeOptions:(RouteOption) list
  member this.ToCs() : ScriptDom.RouteStatement =
    match this with
    | AlterRouteStatement(name=aName; routeOptions=aRouteOptions) ->
      let ret = ScriptDom.AlterRouteStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aRouteOptions do ret.RouteOptions.Add (e.ToCs())
      ret :> ScriptDom.RouteStatement (* 404 *)
    | CreateRouteStatement(name=aName; owner=aOwner; routeOptions=aRouteOptions) ->
      let ret = ScriptDom.CreateRouteStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aRouteOptions do ret.RouteOptions.Add (e.ToCs())
      ret :> ScriptDom.RouteStatement (* 404 *)
//// shared props RouteStatement 
  member this.Name = 
    match this with
    | AlterRouteStatement(name=name) -> name
    | CreateRouteStatement(name=name) -> name
  member this.RouteOptions = 
    match this with
    | AlterRouteStatement(routeOptions=routeOptions) -> routeOptions
    | CreateRouteStatement(routeOptions=routeOptions) -> routeOptions
  static member FromCs(src:ScriptDom.RouteStatement) : RouteStatement =
    match src with
    | :? ScriptDom.AlterRouteStatement as src ->
      RouteStatement.AlterRouteStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))) |> List.ofSeq))
    | :? ScriptDom.CreateRouteStatement as src ->
      RouteStatement.CreateRouteStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RouteOptions |> Seq.map (fun src -> RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))) |> List.ofSeq))
and SecurityPolicyStatement = (* IsAbstract = true , children = 2*)
  | AlterSecurityPolicyStatement of actionType:ScriptDom.SecurityPolicyActionType * name:SchemaObjectName option * notForReplication:bool * securityPolicyOptions:(SecurityPolicyOption) list * securityPredicateActions:(SecurityPredicateAction) list
  | CreateSecurityPolicyStatement of actionType:ScriptDom.SecurityPolicyActionType * name:SchemaObjectName option * notForReplication:bool * securityPolicyOptions:(SecurityPolicyOption) list * securityPredicateActions:(SecurityPredicateAction) list
  member this.ToCs() : ScriptDom.SecurityPolicyStatement =
    match this with
    | AlterSecurityPolicyStatement(actionType=aActionType; name=aName; notForReplication=aNotForReplication; securityPolicyOptions=aSecurityPolicyOptions; securityPredicateActions=aSecurityPredicateActions) ->
      let ret = ScriptDom.AlterSecurityPolicyStatement()
      ret.ActionType <- aActionType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotForReplication <- aNotForReplication
      for e in aSecurityPolicyOptions do ret.SecurityPolicyOptions.Add (e.ToCs())
      for e in aSecurityPredicateActions do ret.SecurityPredicateActions.Add (e.ToCs())
      ret :> ScriptDom.SecurityPolicyStatement (* 404 *)
    | CreateSecurityPolicyStatement(actionType=aActionType; name=aName; notForReplication=aNotForReplication; securityPolicyOptions=aSecurityPolicyOptions; securityPredicateActions=aSecurityPredicateActions) ->
      let ret = ScriptDom.CreateSecurityPolicyStatement()
      ret.ActionType <- aActionType
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NotForReplication <- aNotForReplication
      for e in aSecurityPolicyOptions do ret.SecurityPolicyOptions.Add (e.ToCs())
      for e in aSecurityPredicateActions do ret.SecurityPredicateActions.Add (e.ToCs())
      ret :> ScriptDom.SecurityPolicyStatement (* 404 *)
//// shared props SecurityPolicyStatement 
  member this.ActionType = 
    match this with
    | AlterSecurityPolicyStatement(actionType=actionType) -> actionType
    | CreateSecurityPolicyStatement(actionType=actionType) -> actionType
  member this.Name = 
    match this with
    | AlterSecurityPolicyStatement(name=name) -> name
    | CreateSecurityPolicyStatement(name=name) -> name
  member this.NotForReplication = 
    match this with
    | AlterSecurityPolicyStatement(notForReplication=notForReplication) -> notForReplication
    | CreateSecurityPolicyStatement(notForReplication=notForReplication) -> notForReplication
  member this.SecurityPolicyOptions = 
    match this with
    | AlterSecurityPolicyStatement(securityPolicyOptions=securityPolicyOptions) -> securityPolicyOptions
    | CreateSecurityPolicyStatement(securityPolicyOptions=securityPolicyOptions) -> securityPolicyOptions
  member this.SecurityPredicateActions = 
    match this with
    | AlterSecurityPolicyStatement(securityPredicateActions=securityPredicateActions) -> securityPredicateActions
    | CreateSecurityPolicyStatement(securityPredicateActions=securityPredicateActions) -> securityPredicateActions
  static member FromCs(src:ScriptDom.SecurityPolicyStatement) : SecurityPolicyStatement =
    match src with
    | :? ScriptDom.AlterSecurityPolicyStatement as src ->
      SecurityPolicyStatement.AlterSecurityPolicyStatement((src.ActionType), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.NotForReplication), (src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq), (src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.CreateSecurityPolicyStatement as src ->
      SecurityPolicyStatement.CreateSecurityPolicyStatement((src.ActionType), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.NotForReplication), (src.SecurityPolicyOptions |> Seq.map (fun src -> SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))) |> List.ofSeq), (src.SecurityPredicateActions |> Seq.map (fun src -> SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))) |> List.ofSeq))
and SecurityStatement = (* IsAbstract = true , children = 3*)
  | DenyStatement of asClause:Identifier option * cascadeOption:bool * permissions:(Permission) list * principals:(SecurityPrincipal) list * securityTargetObject:SecurityTargetObject option
  | GrantStatement of asClause:Identifier option * permissions:(Permission) list * principals:(SecurityPrincipal) list * securityTargetObject:SecurityTargetObject option * withGrantOption:bool
  | RevokeStatement of asClause:Identifier option * cascadeOption:bool * grantOptionFor:bool * permissions:(Permission) list * principals:(SecurityPrincipal) list * securityTargetObject:SecurityTargetObject option
  member this.ToCs() : ScriptDom.SecurityStatement =
    match this with
    | DenyStatement(asClause=aAsClause; cascadeOption=aCascadeOption; permissions=aPermissions; principals=aPrincipals; securityTargetObject=aSecurityTargetObject) ->
      let ret = ScriptDom.DenyStatement()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CascadeOption <- aCascadeOption
      for e in aPermissions do ret.Permissions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatement (* 404 *)
    | GrantStatement(asClause=aAsClause; permissions=aPermissions; principals=aPrincipals; securityTargetObject=aSecurityTargetObject; withGrantOption=aWithGrantOption) ->
      let ret = ScriptDom.GrantStatement()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPermissions do ret.Permissions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithGrantOption <- aWithGrantOption
      ret :> ScriptDom.SecurityStatement (* 404 *)
    | RevokeStatement(asClause=aAsClause; cascadeOption=aCascadeOption; grantOptionFor=aGrantOptionFor; permissions=aPermissions; principals=aPrincipals; securityTargetObject=aSecurityTargetObject) ->
      let ret = ScriptDom.RevokeStatement()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CascadeOption <- aCascadeOption
      ret.GrantOptionFor <- aGrantOptionFor
      for e in aPermissions do ret.Permissions.Add (e.ToCs())
      for e in aPrincipals do ret.Principals.Add (e.ToCs())
      ret.SecurityTargetObject <- aSecurityTargetObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatement (* 404 *)
//// shared props SecurityStatement 
  member this.AsClause = 
    match this with
    | DenyStatement(asClause=asClause) -> asClause
    | GrantStatement(asClause=asClause) -> asClause
    | RevokeStatement(asClause=asClause) -> asClause
  member this.Permissions = 
    match this with
    | DenyStatement(permissions=permissions) -> permissions
    | GrantStatement(permissions=permissions) -> permissions
    | RevokeStatement(permissions=permissions) -> permissions
  member this.Principals = 
    match this with
    | DenyStatement(principals=principals) -> principals
    | GrantStatement(principals=principals) -> principals
    | RevokeStatement(principals=principals) -> principals
  member this.SecurityTargetObject = 
    match this with
    | DenyStatement(securityTargetObject=securityTargetObject) -> securityTargetObject
    | GrantStatement(securityTargetObject=securityTargetObject) -> securityTargetObject
    | RevokeStatement(securityTargetObject=securityTargetObject) -> securityTargetObject
  static member FromCs(src:ScriptDom.SecurityStatement) : SecurityStatement =
    match src with
    | :? ScriptDom.DenyStatement as src ->
      SecurityStatement.DenyStatement((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.CascadeOption), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)))
    | :? ScriptDom.GrantStatement as src ->
      SecurityStatement.GrantStatement((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)), (src.WithGrantOption))
    | :? ScriptDom.RevokeStatement as src ->
      SecurityStatement.RevokeStatement((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.CascadeOption), (src.GrantOptionFor), (src.Permissions |> Seq.map (fun src -> Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.Principals |> Seq.map (fun src -> SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))) |> List.ofSeq), (src.SecurityTargetObject |> Option.ofObj |> Option.map (SecurityTargetObject.FromCs)))
and SecurityStatementBody80 = (* IsAbstract = true , children = 3*)
  | DenyStatement80 of cascadeOption:bool * securityElement80:SecurityElement80 option * securityUserClause80:SecurityUserClause80 option
  | GrantStatement80 of asClause:Identifier option * securityElement80:SecurityElement80 option * securityUserClause80:SecurityUserClause80 option * withGrantOption:bool
  | RevokeStatement80 of asClause:Identifier option * cascadeOption:bool * grantOptionFor:bool * securityElement80:SecurityElement80 option * securityUserClause80:SecurityUserClause80 option
  member this.ToCs() : ScriptDom.SecurityStatementBody80 =
    match this with
    | DenyStatement80(cascadeOption=aCascadeOption; securityElement80=aSecurityElement80; securityUserClause80=aSecurityUserClause80) ->
      let ret = ScriptDom.DenyStatement80()
      ret.CascadeOption <- aCascadeOption
      ret.SecurityElement80 <- aSecurityElement80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityUserClause80 <- aSecurityUserClause80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatementBody80 (* 404 *)
    | GrantStatement80(asClause=aAsClause; securityElement80=aSecurityElement80; securityUserClause80=aSecurityUserClause80; withGrantOption=aWithGrantOption) ->
      let ret = ScriptDom.GrantStatement80()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityElement80 <- aSecurityElement80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityUserClause80 <- aSecurityUserClause80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithGrantOption <- aWithGrantOption
      ret :> ScriptDom.SecurityStatementBody80 (* 404 *)
    | RevokeStatement80(asClause=aAsClause; cascadeOption=aCascadeOption; grantOptionFor=aGrantOptionFor; securityElement80=aSecurityElement80; securityUserClause80=aSecurityUserClause80) ->
      let ret = ScriptDom.RevokeStatement80()
      ret.AsClause <- aAsClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.CascadeOption <- aCascadeOption
      ret.GrantOptionFor <- aGrantOptionFor
      ret.SecurityElement80 <- aSecurityElement80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityUserClause80 <- aSecurityUserClause80 |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SecurityStatementBody80 (* 404 *)
//// shared props SecurityStatementBody80 
  member this.SecurityElement80 = 
    match this with
    | DenyStatement80(securityElement80=securityElement80) -> securityElement80
    | GrantStatement80(securityElement80=securityElement80) -> securityElement80
    | RevokeStatement80(securityElement80=securityElement80) -> securityElement80
  member this.SecurityUserClause80 = 
    match this with
    | DenyStatement80(securityUserClause80=securityUserClause80) -> securityUserClause80
    | GrantStatement80(securityUserClause80=securityUserClause80) -> securityUserClause80
    | RevokeStatement80(securityUserClause80=securityUserClause80) -> securityUserClause80
  static member FromCs(src:ScriptDom.SecurityStatementBody80) : SecurityStatementBody80 =
    match src with
    | :? ScriptDom.DenyStatement80 as src ->
      SecurityStatementBody80.DenyStatement80((src.CascadeOption), (src.SecurityElement80 |> Option.ofObj |> Option.map (SecurityElement80.FromCs)), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (SecurityUserClause80.FromCs)))
    | :? ScriptDom.GrantStatement80 as src ->
      SecurityStatementBody80.GrantStatement80((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SecurityElement80 |> Option.ofObj |> Option.map (SecurityElement80.FromCs)), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (SecurityUserClause80.FromCs)), (src.WithGrantOption))
    | :? ScriptDom.RevokeStatement80 as src ->
      SecurityStatementBody80.RevokeStatement80((src.AsClause |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.CascadeOption), (src.GrantOptionFor), (src.SecurityElement80 |> Option.ofObj |> Option.map (SecurityElement80.FromCs)), (src.SecurityUserClause80 |> Option.ofObj |> Option.map (SecurityUserClause80.FromCs)))
and SequenceStatement = (* IsAbstract = true , children = 2*)
  | AlterSequenceStatement of name:SchemaObjectName option * sequenceOptions:(SequenceOption) list
  | CreateSequenceStatement of name:SchemaObjectName option * sequenceOptions:(SequenceOption) list
  member this.ToCs() : ScriptDom.SequenceStatement =
    match this with
    | AlterSequenceStatement(name=aName; sequenceOptions=aSequenceOptions) ->
      let ret = ScriptDom.AlterSequenceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSequenceOptions do ret.SequenceOptions.Add (e.ToCs())
      ret :> ScriptDom.SequenceStatement (* 404 *)
    | CreateSequenceStatement(name=aName; sequenceOptions=aSequenceOptions) ->
      let ret = ScriptDom.CreateSequenceStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSequenceOptions do ret.SequenceOptions.Add (e.ToCs())
      ret :> ScriptDom.SequenceStatement (* 404 *)
//// shared props SequenceStatement 
  member this.Name = 
    match this with
    | AlterSequenceStatement(name=name) -> name
    | CreateSequenceStatement(name=name) -> name
  member this.SequenceOptions = 
    match this with
    | AlterSequenceStatement(sequenceOptions=sequenceOptions) -> sequenceOptions
    | CreateSequenceStatement(sequenceOptions=sequenceOptions) -> sequenceOptions
  static member FromCs(src:ScriptDom.SequenceStatement) : SequenceStatement =
    match src with
    | :? ScriptDom.AlterSequenceStatement as src ->
      SequenceStatement.AlterSequenceStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SequenceOptions |> Seq.map (SequenceOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateSequenceStatement as src ->
      SequenceStatement.CreateSequenceStatement((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SequenceOptions |> Seq.map (SequenceOption.FromCs) |> List.ofSeq))
and ServerAuditStatement = (* IsAbstract = true , children = 2*)
  | AlterServerAuditStatement of auditName:Identifier option * auditTarget:AuditTarget option * newName:Identifier option * options:(AuditOption) list * predicateExpression:BooleanExpression option * removeWhere:bool
  | CreateServerAuditStatement of auditName:Identifier option * auditTarget:AuditTarget option * options:(AuditOption) list * predicateExpression:BooleanExpression option
  member this.ToCs() : ScriptDom.ServerAuditStatement =
    match this with
    | AlterServerAuditStatement(auditName=aAuditName; auditTarget=aAuditTarget; newName=aNewName; options=aOptions; predicateExpression=aPredicateExpression; removeWhere=aRemoveWhere) ->
      let ret = ScriptDom.AlterServerAuditStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditTarget <- aAuditTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NewName <- aNewName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.PredicateExpression <- aPredicateExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RemoveWhere <- aRemoveWhere
      ret :> ScriptDom.ServerAuditStatement (* 404 *)
    | CreateServerAuditStatement(auditName=aAuditName; auditTarget=aAuditTarget; options=aOptions; predicateExpression=aPredicateExpression) ->
      let ret = ScriptDom.CreateServerAuditStatement()
      ret.AuditName <- aAuditName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.AuditTarget <- aAuditTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.PredicateExpression <- aPredicateExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ServerAuditStatement (* 404 *)
//// shared props ServerAuditStatement 
  member this.AuditName = 
    match this with
    | AlterServerAuditStatement(auditName=auditName) -> auditName
    | CreateServerAuditStatement(auditName=auditName) -> auditName
  member this.AuditTarget = 
    match this with
    | AlterServerAuditStatement(auditTarget=auditTarget) -> auditTarget
    | CreateServerAuditStatement(auditTarget=auditTarget) -> auditTarget
  member this.Options = 
    match this with
    | AlterServerAuditStatement(options=options) -> options
    | CreateServerAuditStatement(options=options) -> options
  member this.PredicateExpression = 
    match this with
    | AlterServerAuditStatement(predicateExpression=predicateExpression) -> predicateExpression
    | CreateServerAuditStatement(predicateExpression=predicateExpression) -> predicateExpression
  static member FromCs(src:ScriptDom.ServerAuditStatement) : ServerAuditStatement =
    match src with
    | :? ScriptDom.AlterServerAuditStatement as src ->
      ServerAuditStatement.AlterServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditTarget |> Option.ofObj |> Option.map (AuditTarget.FromCs)), (src.NewName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Options |> Seq.map (AuditOption.FromCs) |> List.ofSeq), (src.PredicateExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.RemoveWhere))
    | :? ScriptDom.CreateServerAuditStatement as src ->
      ServerAuditStatement.CreateServerAuditStatement((src.AuditName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.AuditTarget |> Option.ofObj |> Option.map (AuditTarget.FromCs)), (src.Options |> Seq.map (AuditOption.FromCs) |> List.ofSeq), (src.PredicateExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
and SetOnOffStatement = (* IsAbstract = true , children = 4*)
  | PredicateSetStatement of isOn:bool * options:ScriptDom.SetOptions
  | SetIdentityInsertStatement of isOn:bool * table:SchemaObjectName option
  | SetOffsetsStatement of isOn:bool * options:ScriptDom.SetOffsets
  | SetStatisticsStatement of isOn:bool * options:ScriptDom.SetStatisticsOptions
  member this.ToCs() : ScriptDom.SetOnOffStatement =
    match this with
    | PredicateSetStatement(isOn=aIsOn; options=aOptions) ->
      let ret = ScriptDom.PredicateSetStatement()
      ret.IsOn <- aIsOn
      ret.Options <- aOptions
      ret :> ScriptDom.SetOnOffStatement (* 404 *)
    | SetIdentityInsertStatement(isOn=aIsOn; table=aTable) ->
      let ret = ScriptDom.SetIdentityInsertStatement()
      ret.IsOn <- aIsOn
      ret.Table <- aTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SetOnOffStatement (* 404 *)
    | SetOffsetsStatement(isOn=aIsOn; options=aOptions) ->
      let ret = ScriptDom.SetOffsetsStatement()
      ret.IsOn <- aIsOn
      ret.Options <- aOptions
      ret :> ScriptDom.SetOnOffStatement (* 404 *)
    | SetStatisticsStatement(isOn=aIsOn; options=aOptions) ->
      let ret = ScriptDom.SetStatisticsStatement()
      ret.IsOn <- aIsOn
      ret.Options <- aOptions
      ret :> ScriptDom.SetOnOffStatement (* 404 *)
//// shared props SetOnOffStatement 
  member this.IsOn = 
    match this with
    | PredicateSetStatement(isOn=isOn) -> isOn
    | SetIdentityInsertStatement(isOn=isOn) -> isOn
    | SetOffsetsStatement(isOn=isOn) -> isOn
    | SetStatisticsStatement(isOn=isOn) -> isOn
  static member FromCs(src:ScriptDom.SetOnOffStatement) : SetOnOffStatement =
    match src with
    | :? ScriptDom.PredicateSetStatement as src ->
      SetOnOffStatement.PredicateSetStatement((src.IsOn), (src.Options))
    | :? ScriptDom.SetIdentityInsertStatement as src ->
      SetOnOffStatement.SetIdentityInsertStatement((src.IsOn), (src.Table |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.SetOffsetsStatement as src ->
      SetOnOffStatement.SetOffsetsStatement((src.IsOn), (src.Options))
    | :? ScriptDom.SetStatisticsStatement as src ->
      SetOnOffStatement.SetStatisticsStatement((src.IsOn), (src.Options))
and SignatureStatementBase = (* IsAbstract = true , children = 2*)
  | AddSignatureStatement of cryptos:(CryptoMechanism) list * element:SchemaObjectName option * elementKind:ScriptDom.SignableElementKind * isCounter:bool
  | DropSignatureStatement of cryptos:(CryptoMechanism) list * element:SchemaObjectName option * elementKind:ScriptDom.SignableElementKind * isCounter:bool
  member this.ToCs() : ScriptDom.SignatureStatementBase =
    match this with
    | AddSignatureStatement(cryptos=aCryptos; element=aElement; elementKind=aElementKind; isCounter=aIsCounter) ->
      let ret = ScriptDom.AddSignatureStatement()
      for e in aCryptos do ret.Cryptos.Add (e.ToCs())
      ret.Element <- aElement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElementKind <- aElementKind
      ret.IsCounter <- aIsCounter
      ret :> ScriptDom.SignatureStatementBase (* 404 *)
    | DropSignatureStatement(cryptos=aCryptos; element=aElement; elementKind=aElementKind; isCounter=aIsCounter) ->
      let ret = ScriptDom.DropSignatureStatement()
      for e in aCryptos do ret.Cryptos.Add (e.ToCs())
      ret.Element <- aElement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElementKind <- aElementKind
      ret.IsCounter <- aIsCounter
      ret :> ScriptDom.SignatureStatementBase (* 404 *)
//// shared props SignatureStatementBase 
  member this.Cryptos = 
    match this with
    | AddSignatureStatement(cryptos=cryptos) -> cryptos
    | DropSignatureStatement(cryptos=cryptos) -> cryptos
  member this.Element = 
    match this with
    | AddSignatureStatement(element=element) -> element
    | DropSignatureStatement(element=element) -> element
  member this.ElementKind = 
    match this with
    | AddSignatureStatement(elementKind=elementKind) -> elementKind
    | DropSignatureStatement(elementKind=elementKind) -> elementKind
  member this.IsCounter = 
    match this with
    | AddSignatureStatement(isCounter=isCounter) -> isCounter
    | DropSignatureStatement(isCounter=isCounter) -> isCounter
  static member FromCs(src:ScriptDom.SignatureStatementBase) : SignatureStatementBase =
    match src with
    | :? ScriptDom.AddSignatureStatement as src ->
      SignatureStatementBase.AddSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Element |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ElementKind), (src.IsCounter))
    | :? ScriptDom.DropSignatureStatement as src ->
      SignatureStatementBase.DropSignatureStatement((src.Cryptos |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.Element |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ElementKind), (src.IsCounter))
and StatementWithCtesAndXmlNamespaces = (* IsAbstract = true , children = 2*)
  | DataModificationStatement of dataModificationStatement:DataModificationStatement
  | SelectStatement of selectStatement:SelectStatement
  member this.ToCs() : ScriptDom.StatementWithCtesAndXmlNamespaces =
    match this with
    | DataModificationStatement(x) -> x.ToCs() :> ScriptDom.StatementWithCtesAndXmlNamespaces (* 414 *)
    | SelectStatement(x) -> x.ToCs() :> ScriptDom.StatementWithCtesAndXmlNamespaces (* 414 *)
//// shared props StatementWithCtesAndXmlNamespaces 
  member this.OptimizerHints = 
    match this with
    | DataModificationStatement _ as x -> x.OptimizerHints
    | SelectStatement _ as x -> x.OptimizerHints
  member this.WithCtesAndXmlNamespaces = 
    match this with
    | DataModificationStatement _ as x -> x.WithCtesAndXmlNamespaces
    | SelectStatement _ as x -> x.WithCtesAndXmlNamespaces
  static member FromCs(src:ScriptDom.StatementWithCtesAndXmlNamespaces) : StatementWithCtesAndXmlNamespaces =
    match src with
    | :? ScriptDom.DataModificationStatement as src ->
      match src with
      | :? ScriptDom.DeleteStatement as src->
        StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.DeleteStatement((src.DeleteSpecification |> Option.ofObj |> Option.map (DeleteSpecification.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))))
      | :? ScriptDom.InsertStatement as src->
        StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.InsertStatement((src.InsertSpecification |> Option.ofObj |> Option.map (InsertSpecification.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))))
      | :? ScriptDom.MergeStatement as src->
        StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.MergeStatement((src.MergeSpecification |> Option.ofObj |> Option.map (MergeSpecification.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))))
      | :? ScriptDom.UpdateStatement as src->
        StatementWithCtesAndXmlNamespaces.DataModificationStatement((DataModificationStatement.UpdateStatement((src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.UpdateSpecification |> Option.ofObj |> Option.map (UpdateSpecification.FromCs)), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))))
    | :? ScriptDom.SelectStatement as src ->
      match src with
      | :? ScriptDom.SelectStatementSnippet as src->
        StatementWithCtesAndXmlNamespaces.SelectStatement((SelectStatement.SelectStatementSnippet((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.On |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)), (src.Script), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))))
      | _ -> (* :? ScriptDom.SelectStatement as src *)
        StatementWithCtesAndXmlNamespaces.SelectStatement((SelectStatement.Base((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.On |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))))
and SymmetricKeyStatement = (* IsAbstract = true , children = 2*)
  | AlterSymmetricKeyStatement of encryptingMechanisms:(CryptoMechanism) list * isAdd:bool * name:Identifier option
  | CreateSymmetricKeyStatement of encryptingMechanisms:(CryptoMechanism) list * keyOptions:(KeyOption) list * name:Identifier option * owner:Identifier option * provider:Identifier option
  member this.ToCs() : ScriptDom.SymmetricKeyStatement =
    match this with
    | AlterSymmetricKeyStatement(encryptingMechanisms=aEncryptingMechanisms; isAdd=aIsAdd; name=aName) ->
      let ret = ScriptDom.AlterSymmetricKeyStatement()
      for e in aEncryptingMechanisms do ret.EncryptingMechanisms.Add (e.ToCs())
      ret.IsAdd <- aIsAdd
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SymmetricKeyStatement (* 404 *)
    | CreateSymmetricKeyStatement(encryptingMechanisms=aEncryptingMechanisms; keyOptions=aKeyOptions; name=aName; owner=aOwner; provider=aProvider) ->
      let ret = ScriptDom.CreateSymmetricKeyStatement()
      for e in aEncryptingMechanisms do ret.EncryptingMechanisms.Add (e.ToCs())
      for e in aKeyOptions do ret.KeyOptions.Add (e.ToCs())
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Provider <- aProvider |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SymmetricKeyStatement (* 404 *)
//// shared props SymmetricKeyStatement 
  member this.EncryptingMechanisms = 
    match this with
    | AlterSymmetricKeyStatement(encryptingMechanisms=encryptingMechanisms) -> encryptingMechanisms
    | CreateSymmetricKeyStatement(encryptingMechanisms=encryptingMechanisms) -> encryptingMechanisms
  member this.Name = 
    match this with
    | AlterSymmetricKeyStatement(name=name) -> name
    | CreateSymmetricKeyStatement(name=name) -> name
  static member FromCs(src:ScriptDom.SymmetricKeyStatement) : SymmetricKeyStatement =
    match src with
    | :? ScriptDom.AlterSymmetricKeyStatement as src ->
      SymmetricKeyStatement.AlterSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.IsAdd), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.CreateSymmetricKeyStatement as src ->
      SymmetricKeyStatement.CreateSymmetricKeyStatement((src.EncryptingMechanisms |> Seq.map (fun src -> CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))) |> List.ofSeq), (src.KeyOptions |> Seq.map (KeyOption.FromCs) |> List.ofSeq), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Provider |> Option.ofObj |> Option.map (Identifier.FromCs)))
and TextModificationStatement = (* IsAbstract = true , children = 2*)
  | UpdateTextStatement of bulk:bool * column:ColumnReferenceExpression option * deleteLength:ScalarExpression option * insertOffset:ScalarExpression option * sourceColumn:ColumnReferenceExpression option * sourceParameter:ValueExpression option * textId:ValueExpression option * timestamp:Literal option * withLog:bool
  | WriteTextStatement of bulk:bool * column:ColumnReferenceExpression option * sourceParameter:ValueExpression option * textId:ValueExpression option * timestamp:Literal option * withLog:bool
  member this.ToCs() : ScriptDom.TextModificationStatement =
    match this with
    | UpdateTextStatement(bulk=aBulk; column=aColumn; deleteLength=aDeleteLength; insertOffset=aInsertOffset; sourceColumn=aSourceColumn; sourceParameter=aSourceParameter; textId=aTextId; timestamp=aTimestamp; withLog=aWithLog) ->
      let ret = ScriptDom.UpdateTextStatement()
      ret.Bulk <- aBulk
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DeleteLength <- aDeleteLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InsertOffset <- aInsertOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceColumn <- aSourceColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceParameter <- aSourceParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextId <- aTextId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timestamp <- aTimestamp |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithLog <- aWithLog
      ret :> ScriptDom.TextModificationStatement (* 404 *)
    | WriteTextStatement(bulk=aBulk; column=aColumn; sourceParameter=aSourceParameter; textId=aTextId; timestamp=aTimestamp; withLog=aWithLog) ->
      let ret = ScriptDom.WriteTextStatement()
      ret.Bulk <- aBulk
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SourceParameter <- aSourceParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TextId <- aTextId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Timestamp <- aTimestamp |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithLog <- aWithLog
      ret :> ScriptDom.TextModificationStatement (* 404 *)
//// shared props TextModificationStatement 
  member this.Bulk = 
    match this with
    | UpdateTextStatement(bulk=bulk) -> bulk
    | WriteTextStatement(bulk=bulk) -> bulk
  member this.Column = 
    match this with
    | UpdateTextStatement(column=column) -> column
    | WriteTextStatement(column=column) -> column
  member this.TextId = 
    match this with
    | UpdateTextStatement(textId=textId) -> textId
    | WriteTextStatement(textId=textId) -> textId
  member this.Timestamp = 
    match this with
    | UpdateTextStatement(timestamp=timestamp) -> timestamp
    | WriteTextStatement(timestamp=timestamp) -> timestamp
  member this.WithLog = 
    match this with
    | UpdateTextStatement(withLog=withLog) -> withLog
    | WriteTextStatement(withLog=withLog) -> withLog
  static member FromCs(src:ScriptDom.TextModificationStatement) : TextModificationStatement =
    match src with
    | :? ScriptDom.UpdateTextStatement as src ->
      TextModificationStatement.UpdateTextStatement((src.Bulk), (src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.DeleteLength |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.InsertOffset |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SourceColumn |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SourceParameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TextId |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Timestamp |> Option.ofObj |> Option.map (Literal.FromCs)), (src.WithLog))
    | :? ScriptDom.WriteTextStatement as src ->
      TextModificationStatement.WriteTextStatement((src.Bulk), (src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SourceParameter |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TextId |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Timestamp |> Option.ofObj |> Option.map (Literal.FromCs)), (src.WithLog))
and TransactionStatement = (* IsAbstract = true , children = 4*)
  | BeginTransactionStatement of distributed:bool * markDefined:bool * markDescription:ValueExpression option * name:IdentifierOrValueExpression option
  | CommitTransactionStatement of delayedDurabilityOption:ScriptDom.OptionState * name:IdentifierOrValueExpression option
  | RollbackTransactionStatement of name:IdentifierOrValueExpression option
  | SaveTransactionStatement of name:IdentifierOrValueExpression option
  member this.ToCs() : ScriptDom.TransactionStatement =
    match this with
    | BeginTransactionStatement(distributed=aDistributed; markDefined=aMarkDefined; markDescription=aMarkDescription; name=aName) ->
      let ret = ScriptDom.BeginTransactionStatement()
      ret.Distributed <- aDistributed
      ret.MarkDefined <- aMarkDefined
      ret.MarkDescription <- aMarkDescription |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 404 *)
    | CommitTransactionStatement(delayedDurabilityOption=aDelayedDurabilityOption; name=aName) ->
      let ret = ScriptDom.CommitTransactionStatement()
      ret.DelayedDurabilityOption <- aDelayedDurabilityOption
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 404 *)
    | RollbackTransactionStatement(name=aName) ->
      let ret = ScriptDom.RollbackTransactionStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 404 *)
    | SaveTransactionStatement(name=aName) ->
      let ret = ScriptDom.SaveTransactionStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TransactionStatement (* 404 *)
//// shared props TransactionStatement 
  member this.Name = 
    match this with
    | BeginTransactionStatement(name=name) -> name
    | CommitTransactionStatement(name=name) -> name
    | RollbackTransactionStatement(name=name) -> name
    | SaveTransactionStatement(name=name) -> name
  static member FromCs(src:ScriptDom.TransactionStatement) : TransactionStatement =
    match src with
    | :? ScriptDom.BeginTransactionStatement as src ->
      TransactionStatement.BeginTransactionStatement((src.Distributed), (src.MarkDefined), (src.MarkDescription |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.CommitTransactionStatement as src ->
      TransactionStatement.CommitTransactionStatement((src.DelayedDurabilityOption), (src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.RollbackTransactionStatement as src ->
      TransactionStatement.RollbackTransactionStatement((src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
    | :? ScriptDom.SaveTransactionStatement as src ->
      TransactionStatement.SaveTransactionStatement((src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
and TriggerStatementBody = (* IsAbstract = true , children = 3*)
  | AlterTriggerStatement of isNotForReplication:bool * methodSpecifier:MethodSpecifier option * name:SchemaObjectName option * options:(TriggerOption) list * statementList:StatementList option * triggerActions:(TriggerAction) list * triggerObject:TriggerObject option * triggerType:ScriptDom.TriggerType * withAppend:bool
  | CreateOrAlterTriggerStatement of isNotForReplication:bool * methodSpecifier:MethodSpecifier option * name:SchemaObjectName option * options:(TriggerOption) list * statementList:StatementList option * triggerActions:(TriggerAction) list * triggerObject:TriggerObject option * triggerType:ScriptDom.TriggerType * withAppend:bool
  | CreateTriggerStatement of isNotForReplication:bool * methodSpecifier:MethodSpecifier option * name:SchemaObjectName option * options:(TriggerOption) list * statementList:StatementList option * triggerActions:(TriggerAction) list * triggerObject:TriggerObject option * triggerType:ScriptDom.TriggerType * withAppend:bool
  member this.ToCs() : ScriptDom.TriggerStatementBody =
    match this with
    | AlterTriggerStatement(isNotForReplication=aIsNotForReplication; methodSpecifier=aMethodSpecifier; name=aName; options=aOptions; statementList=aStatementList; triggerActions=aTriggerActions; triggerObject=aTriggerObject; triggerType=aTriggerType; withAppend=aWithAppend) ->
      let ret = ScriptDom.AlterTriggerStatement()
      ret.IsNotForReplication <- aIsNotForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTriggerActions do ret.TriggerActions.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerType <- aTriggerType
      ret.WithAppend <- aWithAppend
      ret :> ScriptDom.TriggerStatementBody (* 404 *)
    | CreateOrAlterTriggerStatement(isNotForReplication=aIsNotForReplication; methodSpecifier=aMethodSpecifier; name=aName; options=aOptions; statementList=aStatementList; triggerActions=aTriggerActions; triggerObject=aTriggerObject; triggerType=aTriggerType; withAppend=aWithAppend) ->
      let ret = ScriptDom.CreateOrAlterTriggerStatement()
      ret.IsNotForReplication <- aIsNotForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTriggerActions do ret.TriggerActions.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerType <- aTriggerType
      ret.WithAppend <- aWithAppend
      ret :> ScriptDom.TriggerStatementBody (* 404 *)
    | CreateTriggerStatement(isNotForReplication=aIsNotForReplication; methodSpecifier=aMethodSpecifier; name=aName; options=aOptions; statementList=aStatementList; triggerActions=aTriggerActions; triggerObject=aTriggerObject; triggerType=aTriggerType; withAppend=aWithAppend) ->
      let ret = ScriptDom.CreateTriggerStatement()
      ret.IsNotForReplication <- aIsNotForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTriggerActions do ret.TriggerActions.Add (e.ToCs())
      ret.TriggerObject <- aTriggerObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerType <- aTriggerType
      ret.WithAppend <- aWithAppend
      ret :> ScriptDom.TriggerStatementBody (* 404 *)
//// shared props TriggerStatementBody 
  member this.IsNotForReplication = 
    match this with
    | AlterTriggerStatement(isNotForReplication=isNotForReplication) -> isNotForReplication
    | CreateOrAlterTriggerStatement(isNotForReplication=isNotForReplication) -> isNotForReplication
    | CreateTriggerStatement(isNotForReplication=isNotForReplication) -> isNotForReplication
  member this.MethodSpecifier = 
    match this with
    | AlterTriggerStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
    | CreateOrAlterTriggerStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
    | CreateTriggerStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
  member this.Name = 
    match this with
    | AlterTriggerStatement(name=name) -> name
    | CreateOrAlterTriggerStatement(name=name) -> name
    | CreateTriggerStatement(name=name) -> name
  member this.Options = 
    match this with
    | AlterTriggerStatement(options=options) -> options
    | CreateOrAlterTriggerStatement(options=options) -> options
    | CreateTriggerStatement(options=options) -> options
  member this.StatementList = 
    match this with
    | AlterTriggerStatement(statementList=statementList) -> statementList
    | CreateOrAlterTriggerStatement(statementList=statementList) -> statementList
    | CreateTriggerStatement(statementList=statementList) -> statementList
  member this.TriggerActions = 
    match this with
    | AlterTriggerStatement(triggerActions=triggerActions) -> triggerActions
    | CreateOrAlterTriggerStatement(triggerActions=triggerActions) -> triggerActions
    | CreateTriggerStatement(triggerActions=triggerActions) -> triggerActions
  member this.TriggerObject = 
    match this with
    | AlterTriggerStatement(triggerObject=triggerObject) -> triggerObject
    | CreateOrAlterTriggerStatement(triggerObject=triggerObject) -> triggerObject
    | CreateTriggerStatement(triggerObject=triggerObject) -> triggerObject
  member this.TriggerType = 
    match this with
    | AlterTriggerStatement(triggerType=triggerType) -> triggerType
    | CreateOrAlterTriggerStatement(triggerType=triggerType) -> triggerType
    | CreateTriggerStatement(triggerType=triggerType) -> triggerType
  member this.WithAppend = 
    match this with
    | AlterTriggerStatement(withAppend=withAppend) -> withAppend
    | CreateOrAlterTriggerStatement(withAppend=withAppend) -> withAppend
    | CreateTriggerStatement(withAppend=withAppend) -> withAppend
  static member FromCs(src:ScriptDom.TriggerStatementBody) : TriggerStatementBody =
    match src with
    | :? ScriptDom.AlterTriggerStatement as src ->
      TriggerStatementBody.AlterTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TriggerOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)), (src.TriggerType), (src.WithAppend))
    | :? ScriptDom.CreateOrAlterTriggerStatement as src ->
      TriggerStatementBody.CreateOrAlterTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TriggerOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)), (src.TriggerType), (src.WithAppend))
    | :? ScriptDom.CreateTriggerStatement as src ->
      TriggerStatementBody.CreateTriggerStatement((src.IsNotForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (TriggerOption.FromCs) |> List.ofSeq), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)), (src.TriggerActions |> Seq.map (fun src -> TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))) |> List.ofSeq), (src.TriggerObject |> Option.ofObj |> Option.map (TriggerObject.FromCs)), (src.TriggerType), (src.WithAppend))
and UserStatement = (* IsAbstract = true , children = 2*)
  | AlterUserStatement of name:Identifier option * userOptions:(PrincipalOption) list
  | CreateUserStatement of name:Identifier option * userLoginOption:UserLoginOption option * userOptions:(PrincipalOption) list
  member this.ToCs() : ScriptDom.UserStatement =
    match this with
    | AlterUserStatement(name=aName; userOptions=aUserOptions) ->
      let ret = ScriptDom.AlterUserStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aUserOptions do ret.UserOptions.Add (e.ToCs())
      ret :> ScriptDom.UserStatement (* 404 *)
    | CreateUserStatement(name=aName; userLoginOption=aUserLoginOption; userOptions=aUserOptions) ->
      let ret = ScriptDom.CreateUserStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserLoginOption <- aUserLoginOption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aUserOptions do ret.UserOptions.Add (e.ToCs())
      ret :> ScriptDom.UserStatement (* 404 *)
//// shared props UserStatement 
  member this.Name = 
    match this with
    | AlterUserStatement(name=name) -> name
    | CreateUserStatement(name=name) -> name
  member this.UserOptions = 
    match this with
    | AlterUserStatement(userOptions=userOptions) -> userOptions
    | CreateUserStatement(userOptions=userOptions) -> userOptions
  static member FromCs(src:ScriptDom.UserStatement) : UserStatement =
    match src with
    | :? ScriptDom.AlterUserStatement as src ->
      UserStatement.AlterUserStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UserOptions |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateUserStatement as src ->
      UserStatement.CreateUserStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UserLoginOption |> Option.ofObj |> Option.map (UserLoginOption.FromCs)), (src.UserOptions |> Seq.map (PrincipalOption.FromCs) |> List.ofSeq))
and ViewStatementBody = (* IsAbstract = true , children = 3*)
  | AlterViewStatement of columns:(Identifier) list * schemaObjectName:SchemaObjectName option * selectStatement:SelectStatement option * viewOptions:(ViewOption) list * withCheckOption:bool
  | CreateOrAlterViewStatement of columns:(Identifier) list * schemaObjectName:SchemaObjectName option * selectStatement:SelectStatement option * viewOptions:(ViewOption) list * withCheckOption:bool
  | CreateViewStatement of columns:(Identifier) list * schemaObjectName:SchemaObjectName option * selectStatement:SelectStatement option * viewOptions:(ViewOption) list * withCheckOption:bool
  member this.ToCs() : ScriptDom.ViewStatementBody =
    match this with
    | AlterViewStatement(columns=aColumns; schemaObjectName=aSchemaObjectName; selectStatement=aSelectStatement; viewOptions=aViewOptions; withCheckOption=aWithCheckOption) ->
      let ret = ScriptDom.AlterViewStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aViewOptions do ret.ViewOptions.Add (e.ToCs())
      ret.WithCheckOption <- aWithCheckOption
      ret :> ScriptDom.ViewStatementBody (* 404 *)
    | CreateOrAlterViewStatement(columns=aColumns; schemaObjectName=aSchemaObjectName; selectStatement=aSelectStatement; viewOptions=aViewOptions; withCheckOption=aWithCheckOption) ->
      let ret = ScriptDom.CreateOrAlterViewStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aViewOptions do ret.ViewOptions.Add (e.ToCs())
      ret.WithCheckOption <- aWithCheckOption
      ret :> ScriptDom.ViewStatementBody (* 404 *)
    | CreateViewStatement(columns=aColumns; schemaObjectName=aSchemaObjectName; selectStatement=aSelectStatement; viewOptions=aViewOptions; withCheckOption=aWithCheckOption) ->
      let ret = ScriptDom.CreateViewStatement()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SelectStatement <- aSelectStatement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aViewOptions do ret.ViewOptions.Add (e.ToCs())
      ret.WithCheckOption <- aWithCheckOption
      ret :> ScriptDom.ViewStatementBody (* 404 *)
//// shared props ViewStatementBody 
  member this.Columns = 
    match this with
    | AlterViewStatement(columns=columns) -> columns
    | CreateOrAlterViewStatement(columns=columns) -> columns
    | CreateViewStatement(columns=columns) -> columns
  member this.SchemaObjectName = 
    match this with
    | AlterViewStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | CreateOrAlterViewStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
    | CreateViewStatement(schemaObjectName=schemaObjectName) -> schemaObjectName
  member this.SelectStatement = 
    match this with
    | AlterViewStatement(selectStatement=selectStatement) -> selectStatement
    | CreateOrAlterViewStatement(selectStatement=selectStatement) -> selectStatement
    | CreateViewStatement(selectStatement=selectStatement) -> selectStatement
  member this.ViewOptions = 
    match this with
    | AlterViewStatement(viewOptions=viewOptions) -> viewOptions
    | CreateOrAlterViewStatement(viewOptions=viewOptions) -> viewOptions
    | CreateViewStatement(viewOptions=viewOptions) -> viewOptions
  member this.WithCheckOption = 
    match this with
    | AlterViewStatement(withCheckOption=withCheckOption) -> withCheckOption
    | CreateOrAlterViewStatement(withCheckOption=withCheckOption) -> withCheckOption
    | CreateViewStatement(withCheckOption=withCheckOption) -> withCheckOption
  static member FromCs(src:ScriptDom.ViewStatementBody) : ViewStatementBody =
    match src with
    | :? ScriptDom.AlterViewStatement as src ->
      ViewStatementBody.AlterViewStatement((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)), (src.ViewOptions |> Seq.map (fun src -> ViewOption.ViewOption((src.OptionKind))) |> List.ofSeq), (src.WithCheckOption))
    | :? ScriptDom.CreateOrAlterViewStatement as src ->
      ViewStatementBody.CreateOrAlterViewStatement((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)), (src.ViewOptions |> Seq.map (fun src -> ViewOption.ViewOption((src.OptionKind))) |> List.ofSeq), (src.WithCheckOption))
    | :? ScriptDom.CreateViewStatement as src ->
      ViewStatementBody.CreateViewStatement((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectStatement |> Option.ofObj |> Option.map (SelectStatement.FromCs)), (src.ViewOptions |> Seq.map (fun src -> ViewOption.ViewOption((src.OptionKind))) |> List.ofSeq), (src.WithCheckOption))
and WaitForSupportedStatement = (* IsAbstract = true , children = 2*)
  | GetConversationGroupStatement of groupId:VariableReference option * queue:SchemaObjectName option
  | ReceiveStatement of into:VariableTableReference option * isConversationGroupIdWhere:bool * queue:SchemaObjectName option * selectElements:(SelectElement) list * top:ScalarExpression option * where:ValueExpression option
  member this.ToCs() : ScriptDom.WaitForSupportedStatement =
    match this with
    | GetConversationGroupStatement(groupId=aGroupId; queue=aQueue) ->
      let ret = ScriptDom.GetConversationGroupStatement()
      ret.GroupId <- aGroupId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Queue <- aQueue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WaitForSupportedStatement (* 404 *)
    | ReceiveStatement(into=aInto; isConversationGroupIdWhere=aIsConversationGroupIdWhere; queue=aQueue; selectElements=aSelectElements; top=aTop; where=aWhere) ->
      let ret = ScriptDom.ReceiveStatement()
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsConversationGroupIdWhere <- aIsConversationGroupIdWhere
      ret.Queue <- aQueue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSelectElements do ret.SelectElements.Add (e.ToCs())
      ret.Top <- aTop |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Where <- aWhere |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.WaitForSupportedStatement (* 404 *)
  static member FromCs(src:ScriptDom.WaitForSupportedStatement) : WaitForSupportedStatement =
    match src with
    | :? ScriptDom.GetConversationGroupStatement as src ->
      WaitForSupportedStatement.GetConversationGroupStatement((src.GroupId |> Option.ofObj |> Option.map (VariableReference.FromCs)), (src.Queue |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.ReceiveStatement as src ->
      WaitForSupportedStatement.ReceiveStatement((src.Into |> Option.ofObj |> Option.map (VariableTableReference.FromCs)), (src.IsConversationGroupIdWhere), (src.Queue |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.SelectElements |> Seq.map (SelectElement.FromCs) |> List.ofSeq), (src.Top |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Where |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
and WorkloadGroupStatement = (* IsAbstract = true , children = 2*)
  | AlterWorkloadGroupStatement of externalPoolName:Identifier option * name:Identifier option * poolName:Identifier option * workloadGroupParameters:(WorkloadGroupParameter) list
  | CreateWorkloadGroupStatement of externalPoolName:Identifier option * name:Identifier option * poolName:Identifier option * workloadGroupParameters:(WorkloadGroupParameter) list
  member this.ToCs() : ScriptDom.WorkloadGroupStatement =
    match this with
    | AlterWorkloadGroupStatement(externalPoolName=aExternalPoolName; name=aName; poolName=aPoolName; workloadGroupParameters=aWorkloadGroupParameters) ->
      let ret = ScriptDom.AlterWorkloadGroupStatement()
      ret.ExternalPoolName <- aExternalPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PoolName <- aPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWorkloadGroupParameters do ret.WorkloadGroupParameters.Add (e.ToCs())
      ret :> ScriptDom.WorkloadGroupStatement (* 404 *)
    | CreateWorkloadGroupStatement(externalPoolName=aExternalPoolName; name=aName; poolName=aPoolName; workloadGroupParameters=aWorkloadGroupParameters) ->
      let ret = ScriptDom.CreateWorkloadGroupStatement()
      ret.ExternalPoolName <- aExternalPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PoolName <- aPoolName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWorkloadGroupParameters do ret.WorkloadGroupParameters.Add (e.ToCs())
      ret :> ScriptDom.WorkloadGroupStatement (* 404 *)
//// shared props WorkloadGroupStatement 
  member this.ExternalPoolName = 
    match this with
    | AlterWorkloadGroupStatement(externalPoolName=externalPoolName) -> externalPoolName
    | CreateWorkloadGroupStatement(externalPoolName=externalPoolName) -> externalPoolName
  member this.Name = 
    match this with
    | AlterWorkloadGroupStatement(name=name) -> name
    | CreateWorkloadGroupStatement(name=name) -> name
  member this.PoolName = 
    match this with
    | AlterWorkloadGroupStatement(poolName=poolName) -> poolName
    | CreateWorkloadGroupStatement(poolName=poolName) -> poolName
  member this.WorkloadGroupParameters = 
    match this with
    | AlterWorkloadGroupStatement(workloadGroupParameters=workloadGroupParameters) -> workloadGroupParameters
    | CreateWorkloadGroupStatement(workloadGroupParameters=workloadGroupParameters) -> workloadGroupParameters
  static member FromCs(src:ScriptDom.WorkloadGroupStatement) : WorkloadGroupStatement =
    match src with
    | :? ScriptDom.AlterWorkloadGroupStatement as src ->
      WorkloadGroupStatement.AlterWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.WorkloadGroupParameters |> Seq.map (WorkloadGroupParameter.FromCs) |> List.ofSeq))
    | :? ScriptDom.CreateWorkloadGroupStatement as src ->
      WorkloadGroupStatement.CreateWorkloadGroupStatement((src.ExternalPoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PoolName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.WorkloadGroupParameters |> Seq.map (WorkloadGroupParameter.FromCs) |> List.ofSeq))
and JoinTableReference = (* IsAbstract = true , children = 2*)
  | QualifiedJoin of firstTableReference:TableReference option * joinHint:ScriptDom.JoinHint * qualifiedJoinType:ScriptDom.QualifiedJoinType * searchCondition:BooleanExpression option * secondTableReference:TableReference option
  | UnqualifiedJoin of firstTableReference:TableReference option * secondTableReference:TableReference option * unqualifiedJoinType:ScriptDom.UnqualifiedJoinType
  member this.ToCs() : ScriptDom.JoinTableReference =
    match this with
    | QualifiedJoin(firstTableReference=aFirstTableReference; joinHint=aJoinHint; qualifiedJoinType=aQualifiedJoinType; searchCondition=aSearchCondition; secondTableReference=aSecondTableReference) ->
      let ret = ScriptDom.QualifiedJoin()
      ret.FirstTableReference <- aFirstTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.JoinHint <- aJoinHint
      ret.QualifiedJoinType <- aQualifiedJoinType
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondTableReference <- aSecondTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.JoinTableReference (* 404 *)
    | UnqualifiedJoin(firstTableReference=aFirstTableReference; secondTableReference=aSecondTableReference; unqualifiedJoinType=aUnqualifiedJoinType) ->
      let ret = ScriptDom.UnqualifiedJoin()
      ret.FirstTableReference <- aFirstTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecondTableReference <- aSecondTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UnqualifiedJoinType <- aUnqualifiedJoinType
      ret :> ScriptDom.JoinTableReference (* 404 *)
//// shared props JoinTableReference 
  member this.FirstTableReference = 
    match this with
    | QualifiedJoin(firstTableReference=firstTableReference) -> firstTableReference
    | UnqualifiedJoin(firstTableReference=firstTableReference) -> firstTableReference
  member this.SecondTableReference = 
    match this with
    | QualifiedJoin(secondTableReference=secondTableReference) -> secondTableReference
    | UnqualifiedJoin(secondTableReference=secondTableReference) -> secondTableReference
  static member FromCs(src:ScriptDom.JoinTableReference) : JoinTableReference =
    match src with
    | :? ScriptDom.QualifiedJoin as src ->
      JoinTableReference.QualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.JoinHint), (src.QualifiedJoinType), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.SecondTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)))
    | :? ScriptDom.UnqualifiedJoin as src ->
      JoinTableReference.UnqualifiedJoin((src.FirstTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.SecondTableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.UnqualifiedJoinType))
and TableReferenceWithAlias = (* IsAbstract = true , children = 15*)
  | AdHocTableReference of alias:Identifier option * dataSource:AdHocDataSource option * object:SchemaObjectNameOrValueExpression option
  | BuiltInFunctionTableReference of alias:Identifier option * name:Identifier option * parameters:(ScalarExpression) list
  | FullTextTableReference of alias:Identifier option * columns:(ColumnReferenceExpression) list * fullTextFunctionType:ScriptDom.FullTextFunctionType * language:ValueExpression option * propertyName:StringLiteral option * searchCondition:ValueExpression option * tableName:SchemaObjectName option * topN:ValueExpression option
  | GlobalFunctionTableReference of alias:Identifier option * name:Identifier option * parameters:(ScalarExpression) list
  | InternalOpenRowset of alias:Identifier option * identifier:Identifier option * varArgs:(ScalarExpression) list
  | NamedTableReference of alias:Identifier option * forPath:bool * schemaObject:SchemaObjectName option * tableHints:(TableHint) list * tableSampleClause:TableSampleClause option * temporalClause:TemporalClause option
  | OpenJsonTableReference of alias:Identifier option * rowPattern:StringLiteral option * schemaDeclarationItems:(SchemaDeclarationItemOpenjson) list * variable:ScalarExpression option
  | OpenQueryTableReference of alias:Identifier option * linkedServer:Identifier option * query:StringLiteral option
  | OpenRowsetTableReference of alias:Identifier option * dataSource:StringLiteral option * object:SchemaObjectName option * password:StringLiteral option * providerName:StringLiteral option * providerString:StringLiteral option * query:StringLiteral option * userId:StringLiteral option
  | OpenXmlTableReference of alias:Identifier option * flags:ValueExpression option * rowPattern:ValueExpression option * schemaDeclarationItems:(SchemaDeclarationItem) list * tableName:SchemaObjectName option * variable:VariableReference option
  | PivotedTableReference of aggregateFunctionIdentifier:MultiPartIdentifier option * alias:Identifier option * inColumns:(Identifier) list * pivotColumn:ColumnReferenceExpression option * tableReference:TableReference option * valueColumns:(ColumnReferenceExpression) list
  | SemanticTableReference of alias:Identifier option * columns:(ColumnReferenceExpression) list * matchedColumn:ColumnReferenceExpression option * matchedKey:ScalarExpression option * semanticFunctionType:ScriptDom.SemanticFunctionType * sourceKey:ScalarExpression option * tableName:SchemaObjectName option
  | TableReferenceWithAliasAndColumns of tableReferenceWithAliasAndColumns:TableReferenceWithAliasAndColumns
  | UnpivotedTableReference of alias:Identifier option * inColumns:(ColumnReferenceExpression) list * pivotColumn:Identifier option * tableReference:TableReference option * valueColumn:Identifier option
  | VariableTableReference of alias:Identifier option * variable:VariableReference option
  member this.ToCs() : ScriptDom.TableReferenceWithAlias =
    match this with
    | AdHocTableReference(alias=aAlias; dataSource=aDataSource; object=aObject) ->
      let ret = ScriptDom.AdHocTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataSource <- aDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | BuiltInFunctionTableReference(alias=aAlias; name=aName; parameters=aParameters) ->
      let ret = ScriptDom.BuiltInFunctionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | FullTextTableReference(alias=aAlias; columns=aColumns; fullTextFunctionType=aFullTextFunctionType; language=aLanguage; propertyName=aPropertyName; searchCondition=aSearchCondition; tableName=aTableName; topN=aTopN) ->
      let ret = ScriptDom.FullTextTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FullTextFunctionType <- aFullTextFunctionType
      ret.Language <- aLanguage |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PropertyName <- aPropertyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopN <- aTopN |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | GlobalFunctionTableReference(alias=aAlias; name=aName; parameters=aParameters) ->
      let ret = ScriptDom.GlobalFunctionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | InternalOpenRowset(alias=aAlias; identifier=aIdentifier; varArgs=aVarArgs) ->
      let ret = ScriptDom.InternalOpenRowset()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aVarArgs do ret.VarArgs.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | NamedTableReference(alias=aAlias; forPath=aForPath; schemaObject=aSchemaObject; tableHints=aTableHints; tableSampleClause=aTableSampleClause; temporalClause=aTemporalClause) ->
      let ret = ScriptDom.NamedTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ForPath <- aForPath
      ret.SchemaObject <- aSchemaObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableHints do ret.TableHints.Add (e.ToCs())
      ret.TableSampleClause <- aTableSampleClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TemporalClause <- aTemporalClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | OpenJsonTableReference(alias=aAlias; rowPattern=aRowPattern; schemaDeclarationItems=aSchemaDeclarationItems; variable=aVariable) ->
      let ret = ScriptDom.OpenJsonTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RowPattern <- aRowPattern |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSchemaDeclarationItems do ret.SchemaDeclarationItems.Add (e.ToCs())
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | OpenQueryTableReference(alias=aAlias; linkedServer=aLinkedServer; query=aQuery) ->
      let ret = ScriptDom.OpenQueryTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LinkedServer <- aLinkedServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Query <- aQuery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | OpenRowsetTableReference(alias=aAlias; dataSource=aDataSource; object=aObject; password=aPassword; providerName=aProviderName; providerString=aProviderString; query=aQuery; userId=aUserId) ->
      let ret = ScriptDom.OpenRowsetTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataSource <- aDataSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Object <- aObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Password <- aPassword |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderName <- aProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderString <- aProviderString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Query <- aQuery |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserId <- aUserId |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | OpenXmlTableReference(alias=aAlias; flags=aFlags; rowPattern=aRowPattern; schemaDeclarationItems=aSchemaDeclarationItems; tableName=aTableName; variable=aVariable) ->
      let ret = ScriptDom.OpenXmlTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Flags <- aFlags |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.RowPattern <- aRowPattern |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSchemaDeclarationItems do ret.SchemaDeclarationItems.Add (e.ToCs())
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | PivotedTableReference(aggregateFunctionIdentifier=aAggregateFunctionIdentifier; alias=aAlias; inColumns=aInColumns; pivotColumn=aPivotColumn; tableReference=aTableReference; valueColumns=aValueColumns) ->
      let ret = ScriptDom.PivotedTableReference()
      ret.AggregateFunctionIdentifier <- aAggregateFunctionIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aInColumns do ret.InColumns.Add (e.ToCs())
      ret.PivotColumn <- aPivotColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aValueColumns do ret.ValueColumns.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | SemanticTableReference(alias=aAlias; columns=aColumns; matchedColumn=aMatchedColumn; matchedKey=aMatchedKey; semanticFunctionType=aSemanticFunctionType; sourceKey=aSourceKey; tableName=aTableName) ->
      let ret = ScriptDom.SemanticTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.MatchedColumn <- aMatchedColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MatchedKey <- aMatchedKey |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SemanticFunctionType <- aSemanticFunctionType
      ret.SourceKey <- aSourceKey |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableName <- aTableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | TableReferenceWithAliasAndColumns(x) -> x.ToCs() :> ScriptDom.TableReferenceWithAlias (* 414 *)
    | UnpivotedTableReference(alias=aAlias; inColumns=aInColumns; pivotColumn=aPivotColumn; tableReference=aTableReference; valueColumn=aValueColumn) ->
      let ret = ScriptDom.UnpivotedTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aInColumns do ret.InColumns.Add (e.ToCs())
      ret.PivotColumn <- aPivotColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValueColumn <- aValueColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
    | VariableTableReference(alias=aAlias; variable=aVariable) ->
      let ret = ScriptDom.VariableTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAlias (* 404 *)
//// shared props TableReferenceWithAlias 
  member this.Alias = 
    match this with
    | AdHocTableReference(alias=alias) -> alias
    | BuiltInFunctionTableReference(alias=alias) -> alias
    | FullTextTableReference(alias=alias) -> alias
    | GlobalFunctionTableReference(alias=alias) -> alias
    | InternalOpenRowset(alias=alias) -> alias
    | NamedTableReference(alias=alias) -> alias
    | OpenJsonTableReference(alias=alias) -> alias
    | OpenQueryTableReference(alias=alias) -> alias
    | OpenRowsetTableReference(alias=alias) -> alias
    | OpenXmlTableReference(alias=alias) -> alias
    | PivotedTableReference(alias=alias) -> alias
    | SemanticTableReference(alias=alias) -> alias
    | TableReferenceWithAliasAndColumns _ as x -> x.Alias
    | UnpivotedTableReference(alias=alias) -> alias
    | VariableTableReference(alias=alias) -> alias
  static member FromCs(src:ScriptDom.TableReferenceWithAlias) : TableReferenceWithAlias =
    match src with
    | :? ScriptDom.AdHocTableReference as src ->
      TableReferenceWithAlias.AdHocTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataSource |> Option.ofObj |> Option.map (AdHocDataSource.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectNameOrValueExpression.FromCs)))
    | :? ScriptDom.BuiltInFunctionTableReference as src ->
      TableReferenceWithAlias.BuiltInFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.FullTextTableReference as src ->
      TableReferenceWithAlias.FullTextTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.FullTextFunctionType), (src.Language |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.PropertyName |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TopN |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
    | :? ScriptDom.GlobalFunctionTableReference as src ->
      TableReferenceWithAlias.GlobalFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.InternalOpenRowset as src ->
      TableReferenceWithAlias.InternalOpenRowset((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.VarArgs |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
    | :? ScriptDom.NamedTableReference as src ->
      TableReferenceWithAlias.NamedTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ForPath), (src.SchemaObject |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TableHints |> Seq.map (TableHint.FromCs) |> List.ofSeq), (src.TableSampleClause |> Option.ofObj |> Option.map (TableSampleClause.FromCs)), (src.TemporalClause |> Option.ofObj |> Option.map (TemporalClause.FromCs)))
    | :? ScriptDom.OpenJsonTableReference as src ->
      TableReferenceWithAlias.OpenJsonTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.RowPattern |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.SchemaDeclarationItems |> Seq.map (fun src -> SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq), (src.Variable |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
    | :? ScriptDom.OpenQueryTableReference as src ->
      TableReferenceWithAlias.OpenQueryTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LinkedServer |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Query |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.OpenRowsetTableReference as src ->
      TableReferenceWithAlias.OpenRowsetTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataSource |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Object |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Password |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ProviderName |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ProviderString |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Query |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.UserId |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
    | :? ScriptDom.OpenXmlTableReference as src ->
      TableReferenceWithAlias.OpenXmlTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Flags |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.RowPattern |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.SchemaDeclarationItems |> Seq.map (SchemaDeclarationItem.FromCs) |> List.ofSeq), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
    | :? ScriptDom.PivotedTableReference as src ->
      TableReferenceWithAlias.PivotedTableReference((src.AggregateFunctionIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)), (src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.InColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PivotColumn |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.ValueColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.SemanticTableReference as src ->
      TableReferenceWithAlias.SemanticTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.MatchedColumn |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.MatchedKey |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SemanticFunctionType), (src.SourceKey |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TableName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.TableReferenceWithAliasAndColumns as src ->
      match src with
      | :? ScriptDom.BulkOpenRowset as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.BulkOpenRowset((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.DataFile |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Options |> Seq.map (BulkInsertOption.FromCs) |> List.ofSeq))))
      | :? ScriptDom.ChangeTableChangesTableReference as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.ChangeTableChangesTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SinceVersion |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Target |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.ChangeTableVersionTableReference as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.ChangeTableVersionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrimaryKeyColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrimaryKeyValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.DataModificationTableReference as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.DataModificationTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.DataModificationSpecification |> Option.ofObj |> Option.map (DataModificationSpecification.FromCs)))))
      | :? ScriptDom.InlineDerivedTable as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.InlineDerivedTable((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))) |> List.ofSeq))))
      | :? ScriptDom.QueryDerivedTable as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.QueryDerivedTable((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))))
      | :? ScriptDom.SchemaObjectFunctionTableReference as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.SchemaObjectFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.SchemaObject |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))))
      | :? ScriptDom.VariableMethodCallTableReference as src->
        TableReferenceWithAlias.TableReferenceWithAliasAndColumns((TableReferenceWithAliasAndColumns.VariableMethodCallTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.MethodName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))))
    | :? ScriptDom.UnpivotedTableReference as src ->
      TableReferenceWithAlias.UnpivotedTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.InColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.PivotColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.ValueColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | :? ScriptDom.VariableTableReference as src ->
      TableReferenceWithAlias.VariableTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and CaseExpression = (* IsAbstract = true , children = 2*)
  | SearchedCaseExpression of collation:Identifier option * elseExpression:ScalarExpression option * whenClauses:(SearchedWhenClause) list
  | SimpleCaseExpression of collation:Identifier option * elseExpression:ScalarExpression option * inputExpression:ScalarExpression option * whenClauses:(SimpleWhenClause) list
  member this.ToCs() : ScriptDom.CaseExpression =
    match this with
    | SearchedCaseExpression(collation=aCollation; elseExpression=aElseExpression; whenClauses=aWhenClauses) ->
      let ret = ScriptDom.SearchedCaseExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElseExpression <- aElseExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWhenClauses do ret.WhenClauses.Add (e.ToCs())
      ret :> ScriptDom.CaseExpression (* 404 *)
    | SimpleCaseExpression(collation=aCollation; elseExpression=aElseExpression; inputExpression=aInputExpression; whenClauses=aWhenClauses) ->
      let ret = ScriptDom.SimpleCaseExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ElseExpression <- aElseExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.InputExpression <- aInputExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aWhenClauses do ret.WhenClauses.Add (e.ToCs())
      ret :> ScriptDom.CaseExpression (* 404 *)
//// shared props CaseExpression 
  member this.Collation = 
    match this with
    | SearchedCaseExpression(collation=collation) -> collation
    | SimpleCaseExpression(collation=collation) -> collation
  member this.ElseExpression = 
    match this with
    | SearchedCaseExpression(elseExpression=elseExpression) -> elseExpression
    | SimpleCaseExpression(elseExpression=elseExpression) -> elseExpression
  static member FromCs(src:ScriptDom.CaseExpression) : CaseExpression =
    match src with
    | :? ScriptDom.SearchedCaseExpression as src ->
      CaseExpression.SearchedCaseExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ElseExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenClauses |> Seq.map (fun src -> SearchedWhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))) |> List.ofSeq))
    | :? ScriptDom.SimpleCaseExpression as src ->
      CaseExpression.SimpleCaseExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ElseExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.InputExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenClauses |> Seq.map (fun src -> SimpleWhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
and ValueExpression = (* IsAbstract = true , children = 3*)
  | GlobalVariableExpression of collation:Identifier option * name:String
  | Literal of literal:Literal
  | VariableReference of collation:Identifier option * name:String
  member this.ToCs() : ScriptDom.ValueExpression =
    match this with
    | GlobalVariableExpression(collation=aCollation; name=aName) ->
      let ret = ScriptDom.GlobalVariableExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName
      ret :> ScriptDom.ValueExpression (* 404 *)
    | Literal(x) -> x.ToCs() :> ScriptDom.ValueExpression (* 414 *)
    | VariableReference(collation=aCollation; name=aName) ->
      let ret = ScriptDom.VariableReference()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName
      ret :> ScriptDom.ValueExpression (* 404 *)
//// shared props ValueExpression 
  member this.Collation = 
    match this with
    | GlobalVariableExpression(collation=collation) -> collation
    | Literal _ as x -> x.Collation
    | VariableReference(collation=collation) -> collation
  static member FromCs(src:ScriptDom.ValueExpression) : ValueExpression =
    match src with
    | :? ScriptDom.GlobalVariableExpression as src ->
      ValueExpression.GlobalVariableExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))
    | :? ScriptDom.Literal as src ->
      match src with
      | :? ScriptDom.BinaryLiteral as src->
        ValueExpression.Literal((Literal.BinaryLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.LiteralType), (src.Value))))
      | :? ScriptDom.DefaultLiteral as src->
        ValueExpression.Literal((Literal.DefaultLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.IdentifierLiteral as src->
        ValueExpression.Literal((Literal.IdentifierLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.QuoteType), (src.Value))))
      | :? ScriptDom.IntegerLiteral as src->
        ValueExpression.Literal((Literal.IntegerLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.MaxLiteral as src->
        ValueExpression.Literal((Literal.MaxLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.MoneyLiteral as src->
        ValueExpression.Literal((Literal.MoneyLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.NullLiteral as src->
        ValueExpression.Literal((Literal.NullLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.NumericLiteral as src->
        ValueExpression.Literal((Literal.NumericLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.OdbcLiteral as src->
        ValueExpression.Literal((Literal.OdbcLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsNational), (src.LiteralType), (src.OdbcLiteralType), (src.Value))))
      | :? ScriptDom.RealLiteral as src->
        ValueExpression.Literal((Literal.RealLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))))
      | :? ScriptDom.StringLiteral as src->
        ValueExpression.Literal((Literal.StringLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (src.Value))))
    | :? ScriptDom.VariableReference as src ->
      ValueExpression.VariableReference((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))
and FunctionStatementBody = (* IsAbstract = true , children = 3*)
  | AlterFunctionStatement of methodSpecifier:MethodSpecifier option * name:SchemaObjectName option * options:(FunctionOption) list * orderHint:OrderBulkInsertOption option * parameters:(ProcedureParameter) list * returnType:FunctionReturnType option * statementList:StatementList option
  | CreateFunctionStatement of methodSpecifier:MethodSpecifier option * name:SchemaObjectName option * options:(FunctionOption) list * orderHint:OrderBulkInsertOption option * parameters:(ProcedureParameter) list * returnType:FunctionReturnType option * statementList:StatementList option
  | CreateOrAlterFunctionStatement of methodSpecifier:MethodSpecifier option * name:SchemaObjectName option * options:(FunctionOption) list * orderHint:OrderBulkInsertOption option * parameters:(ProcedureParameter) list * returnType:FunctionReturnType option * statementList:StatementList option
  member this.ToCs() : ScriptDom.FunctionStatementBody =
    match this with
    | AlterFunctionStatement(methodSpecifier=aMethodSpecifier; name=aName; options=aOptions; orderHint=aOrderHint; parameters=aParameters; returnType=aReturnType; statementList=aStatementList) ->
      let ret = ScriptDom.AlterFunctionStatement()
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OrderHint <- aOrderHint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionStatementBody (* 404 *)
    | CreateFunctionStatement(methodSpecifier=aMethodSpecifier; name=aName; options=aOptions; orderHint=aOrderHint; parameters=aParameters; returnType=aReturnType; statementList=aStatementList) ->
      let ret = ScriptDom.CreateFunctionStatement()
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OrderHint <- aOrderHint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionStatementBody (* 404 *)
    | CreateOrAlterFunctionStatement(methodSpecifier=aMethodSpecifier; name=aName; options=aOptions; orderHint=aOrderHint; parameters=aParameters; returnType=aReturnType; statementList=aStatementList) ->
      let ret = ScriptDom.CreateOrAlterFunctionStatement()
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.OrderHint <- aOrderHint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ReturnType <- aReturnType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.FunctionStatementBody (* 404 *)
//// shared props FunctionStatementBody 
  member this.MethodSpecifier = 
    match this with
    | AlterFunctionStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
    | CreateFunctionStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
    | CreateOrAlterFunctionStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
  member this.Name = 
    match this with
    | AlterFunctionStatement(name=name) -> name
    | CreateFunctionStatement(name=name) -> name
    | CreateOrAlterFunctionStatement(name=name) -> name
  member this.Options = 
    match this with
    | AlterFunctionStatement(options=options) -> options
    | CreateFunctionStatement(options=options) -> options
    | CreateOrAlterFunctionStatement(options=options) -> options
  member this.OrderHint = 
    match this with
    | AlterFunctionStatement(orderHint=orderHint) -> orderHint
    | CreateFunctionStatement(orderHint=orderHint) -> orderHint
    | CreateOrAlterFunctionStatement(orderHint=orderHint) -> orderHint
  member this.Parameters = 
    match this with
    | AlterFunctionStatement(parameters=parameters) -> parameters
    | CreateFunctionStatement(parameters=parameters) -> parameters
    | CreateOrAlterFunctionStatement(parameters=parameters) -> parameters
  member this.ReturnType = 
    match this with
    | AlterFunctionStatement(returnType=returnType) -> returnType
    | CreateFunctionStatement(returnType=returnType) -> returnType
    | CreateOrAlterFunctionStatement(returnType=returnType) -> returnType
  member this.StatementList = 
    match this with
    | AlterFunctionStatement(statementList=statementList) -> statementList
    | CreateFunctionStatement(statementList=statementList) -> statementList
    | CreateOrAlterFunctionStatement(statementList=statementList) -> statementList
  static member FromCs(src:ScriptDom.FunctionStatementBody) : FunctionStatementBody =
    match src with
    | :? ScriptDom.AlterFunctionStatement as src ->
      FunctionStatementBody.AlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FunctionOption.FromCs) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (OrderBulkInsertOption.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (FunctionReturnType.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | :? ScriptDom.CreateFunctionStatement as src ->
      FunctionStatementBody.CreateFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FunctionOption.FromCs) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (OrderBulkInsertOption.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (FunctionReturnType.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | :? ScriptDom.CreateOrAlterFunctionStatement as src ->
      FunctionStatementBody.CreateOrAlterFunctionStatement((src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Options |> Seq.map (FunctionOption.FromCs) |> List.ofSeq), (src.OrderHint |> Option.ofObj |> Option.map (OrderBulkInsertOption.FromCs)), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ReturnType |> Option.ofObj |> Option.map (FunctionReturnType.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
and ProcedureStatementBody = (* IsAbstract = true , children = 3*)
  | AlterProcedureStatement of isForReplication:bool * methodSpecifier:MethodSpecifier option * options:(ProcedureOption) list * parameters:(ProcedureParameter) list * procedureReference:ProcedureReference option * statementList:StatementList option
  | CreateOrAlterProcedureStatement of isForReplication:bool * methodSpecifier:MethodSpecifier option * options:(ProcedureOption) list * parameters:(ProcedureParameter) list * procedureReference:ProcedureReference option * statementList:StatementList option
  | CreateProcedureStatement of isForReplication:bool * methodSpecifier:MethodSpecifier option * options:(ProcedureOption) list * parameters:(ProcedureParameter) list * procedureReference:ProcedureReference option * statementList:StatementList option
  member this.ToCs() : ScriptDom.ProcedureStatementBody =
    match this with
    | AlterProcedureStatement(isForReplication=aIsForReplication; methodSpecifier=aMethodSpecifier; options=aOptions; parameters=aParameters; procedureReference=aProcedureReference; statementList=aStatementList) ->
      let ret = ScriptDom.AlterProcedureStatement()
      ret.IsForReplication <- aIsForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ProcedureStatementBody (* 404 *)
    | CreateOrAlterProcedureStatement(isForReplication=aIsForReplication; methodSpecifier=aMethodSpecifier; options=aOptions; parameters=aParameters; procedureReference=aProcedureReference; statementList=aStatementList) ->
      let ret = ScriptDom.CreateOrAlterProcedureStatement()
      ret.IsForReplication <- aIsForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ProcedureStatementBody (* 404 *)
    | CreateProcedureStatement(isForReplication=aIsForReplication; methodSpecifier=aMethodSpecifier; options=aOptions; parameters=aParameters; procedureReference=aProcedureReference; statementList=aStatementList) ->
      let ret = ScriptDom.CreateProcedureStatement()
      ret.IsForReplication <- aIsForReplication
      ret.MethodSpecifier <- aMethodSpecifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatementList <- aStatementList |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.ProcedureStatementBody (* 404 *)
//// shared props ProcedureStatementBody 
  member this.IsForReplication = 
    match this with
    | AlterProcedureStatement(isForReplication=isForReplication) -> isForReplication
    | CreateOrAlterProcedureStatement(isForReplication=isForReplication) -> isForReplication
    | CreateProcedureStatement(isForReplication=isForReplication) -> isForReplication
  member this.MethodSpecifier = 
    match this with
    | AlterProcedureStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
    | CreateOrAlterProcedureStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
    | CreateProcedureStatement(methodSpecifier=methodSpecifier) -> methodSpecifier
  member this.Options = 
    match this with
    | AlterProcedureStatement(options=options) -> options
    | CreateOrAlterProcedureStatement(options=options) -> options
    | CreateProcedureStatement(options=options) -> options
  member this.Parameters = 
    match this with
    | AlterProcedureStatement(parameters=parameters) -> parameters
    | CreateOrAlterProcedureStatement(parameters=parameters) -> parameters
    | CreateProcedureStatement(parameters=parameters) -> parameters
  member this.ProcedureReference = 
    match this with
    | AlterProcedureStatement(procedureReference=procedureReference) -> procedureReference
    | CreateOrAlterProcedureStatement(procedureReference=procedureReference) -> procedureReference
    | CreateProcedureStatement(procedureReference=procedureReference) -> procedureReference
  member this.StatementList = 
    match this with
    | AlterProcedureStatement(statementList=statementList) -> statementList
    | CreateOrAlterProcedureStatement(statementList=statementList) -> statementList
    | CreateProcedureStatement(statementList=statementList) -> statementList
  static member FromCs(src:ScriptDom.ProcedureStatementBody) : ProcedureStatementBody =
    match src with
    | :? ScriptDom.AlterProcedureStatement as src ->
      ProcedureStatementBody.AlterProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Options |> Seq.map (ProcedureOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | :? ScriptDom.CreateOrAlterProcedureStatement as src ->
      ProcedureStatementBody.CreateOrAlterProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Options |> Seq.map (ProcedureOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
    | :? ScriptDom.CreateProcedureStatement as src ->
      ProcedureStatementBody.CreateProcedureStatement((src.IsForReplication), (src.MethodSpecifier |> Option.ofObj |> Option.map (MethodSpecifier.FromCs)), (src.Options |> Seq.map (ProcedureOption.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (fun src -> ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))) |> List.ofSeq), (src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.StatementList |> Option.ofObj |> Option.map (StatementList.FromCs)))
and AlterRoleStatement = (* IsAbstract = false , children = 1*)
  | Base of action:AlterRoleAction option * name:Identifier option
  | AlterServerRoleStatement of action:AlterRoleAction option * name:Identifier option
  member this.ToCs() : ScriptDom.AlterRoleStatement =
    match this with
    | AlterServerRoleStatement(action=aAction; name=aName) ->
      let ret = ScriptDom.AlterServerRoleStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.AlterRoleStatement (* 404 *)
    | Base(action=aAction; name=aName) ->

      let ret = ScriptDom.AlterRoleStatement()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props AlterRoleStatement 
  member this.Action = 
    match this with
    | Base (action=action) -> action
    | AlterServerRoleStatement(action=action) -> action
  member this.Name = 
    match this with
    | Base (name=name) -> name
    | AlterServerRoleStatement(name=name) -> name
  static member FromCs(src:ScriptDom.AlterRoleStatement) : AlterRoleStatement =
    match src with
    | :? ScriptDom.AlterServerRoleStatement as src ->
      AlterRoleStatement.AlterServerRoleStatement((src.Action |> Option.ofObj |> Option.map (AlterRoleAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | _ -> (* :? ScriptDom.AlterRoleStatement as src *)
      AlterRoleStatement.Base(((src.Action |> Option.ofObj |> Option.map (AlterRoleAction.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs))))
and CreateRoleStatement = (* IsAbstract = false , children = 1*)
  | Base of name:Identifier option * owner:Identifier option
  | CreateServerRoleStatement of name:Identifier option * owner:Identifier option
  member this.ToCs() : ScriptDom.CreateRoleStatement =
    match this with
    | CreateServerRoleStatement(name=aName; owner=aOwner) ->
      let ret = ScriptDom.CreateServerRoleStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.CreateRoleStatement (* 404 *)
    | Base(name=aName; owner=aOwner) ->

      let ret = ScriptDom.CreateRoleStatement()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Owner <- aOwner |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props CreateRoleStatement 
  member this.Name = 
    match this with
    | Base (name=name) -> name
    | CreateServerRoleStatement(name=name) -> name
  member this.Owner = 
    match this with
    | Base (owner=owner) -> owner
    | CreateServerRoleStatement(owner=owner) -> owner
  static member FromCs(src:ScriptDom.CreateRoleStatement) : CreateRoleStatement =
    match src with
    | :? ScriptDom.CreateServerRoleStatement as src ->
      CreateRoleStatement.CreateServerRoleStatement((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs)))
    | _ -> (* :? ScriptDom.CreateRoleStatement as src *)
      CreateRoleStatement.Base(((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Owner |> Option.ofObj |> Option.map (Identifier.FromCs))))
and DataModificationStatement = (* IsAbstract = true , children = 4*)
  | DeleteStatement of deleteSpecification:DeleteSpecification option * optimizerHints:(OptimizerHint) list * withCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | InsertStatement of insertSpecification:InsertSpecification option * optimizerHints:(OptimizerHint) list * withCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | MergeStatement of mergeSpecification:MergeSpecification option * optimizerHints:(OptimizerHint) list * withCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | UpdateStatement of optimizerHints:(OptimizerHint) list * updateSpecification:UpdateSpecification option * withCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  member this.ToCs() : ScriptDom.DataModificationStatement =
    match this with
    | DeleteStatement(deleteSpecification=aDeleteSpecification; optimizerHints=aOptimizerHints; withCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.DeleteStatement()
      ret.DeleteSpecification <- aDeleteSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 404 *)
    | InsertStatement(insertSpecification=aInsertSpecification; optimizerHints=aOptimizerHints; withCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.InsertStatement()
      ret.InsertSpecification <- aInsertSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 404 *)
    | MergeStatement(mergeSpecification=aMergeSpecification; optimizerHints=aOptimizerHints; withCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.MergeStatement()
      ret.MergeSpecification <- aMergeSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 404 *)
    | UpdateStatement(optimizerHints=aOptimizerHints; updateSpecification=aUpdateSpecification; withCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.UpdateStatement()
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.UpdateSpecification <- aUpdateSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.DataModificationStatement (* 404 *)
//// shared props DataModificationStatement 
  member this.OptimizerHints = 
    match this with
    | DeleteStatement(optimizerHints=optimizerHints) -> optimizerHints
    | InsertStatement(optimizerHints=optimizerHints) -> optimizerHints
    | MergeStatement(optimizerHints=optimizerHints) -> optimizerHints
    | UpdateStatement(optimizerHints=optimizerHints) -> optimizerHints
  member this.WithCtesAndXmlNamespaces = 
    match this with
    | DeleteStatement(withCtesAndXmlNamespaces=withCtesAndXmlNamespaces) -> withCtesAndXmlNamespaces
    | InsertStatement(withCtesAndXmlNamespaces=withCtesAndXmlNamespaces) -> withCtesAndXmlNamespaces
    | MergeStatement(withCtesAndXmlNamespaces=withCtesAndXmlNamespaces) -> withCtesAndXmlNamespaces
    | UpdateStatement(withCtesAndXmlNamespaces=withCtesAndXmlNamespaces) -> withCtesAndXmlNamespaces
  static member FromCs(src:ScriptDom.DataModificationStatement) : DataModificationStatement =
    match src with
    | :? ScriptDom.DeleteStatement as src ->
      DataModificationStatement.DeleteStatement((src.DeleteSpecification |> Option.ofObj |> Option.map (DeleteSpecification.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))
    | :? ScriptDom.InsertStatement as src ->
      DataModificationStatement.InsertStatement((src.InsertSpecification |> Option.ofObj |> Option.map (InsertSpecification.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))
    | :? ScriptDom.MergeStatement as src ->
      DataModificationStatement.MergeStatement((src.MergeSpecification |> Option.ofObj |> Option.map (MergeSpecification.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))
    | :? ScriptDom.UpdateStatement as src ->
      DataModificationStatement.UpdateStatement((src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.UpdateSpecification |> Option.ofObj |> Option.map (UpdateSpecification.FromCs)), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))
and SelectStatement = (* IsAbstract = false , children = 1*)
  | Base of computeClauses:(ComputeClause) list * into:SchemaObjectName option * on:Identifier option * optimizerHints:(OptimizerHint) list * queryExpression:QueryExpression option * withCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  | SelectStatementSnippet of computeClauses:(ComputeClause) list * into:SchemaObjectName option * on:Identifier option * optimizerHints:(OptimizerHint) list * queryExpression:QueryExpression option * script:String * withCtesAndXmlNamespaces:WithCtesAndXmlNamespaces option
  member this.ToCs() : ScriptDom.SelectStatement =
    match this with
    | SelectStatementSnippet(computeClauses=aComputeClauses; into=aInto; on=aOn; optimizerHints=aOptimizerHints; queryExpression=aQueryExpression; script=aScript; withCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->
      let ret = ScriptDom.SelectStatementSnippet()
      for e in aComputeClauses do ret.ComputeClauses.Add (e.ToCs())
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.On <- aOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Script <- aScript
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.SelectStatement (* 404 *)
    | Base(computeClauses=aComputeClauses; into=aInto; on=aOn; optimizerHints=aOptimizerHints; queryExpression=aQueryExpression; withCtesAndXmlNamespaces=aWithCtesAndXmlNamespaces) ->

      let ret = ScriptDom.SelectStatement()
      for e in aComputeClauses do ret.ComputeClauses.Add (e.ToCs())
      ret.Into <- aInto |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.On <- aOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptimizerHints do ret.OptimizerHints.Add (e.ToCs())
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithCtesAndXmlNamespaces <- aWithCtesAndXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret
//// shared props SelectStatement 
  member this.ComputeClauses = 
    match this with
    | Base (computeClauses=computeClauses) -> computeClauses
    | SelectStatementSnippet(computeClauses=computeClauses) -> computeClauses
  member this.Into = 
    match this with
    | Base (into=into) -> into
    | SelectStatementSnippet(into=into) -> into
  member this.On = 
    match this with
    | Base (on=on) -> on
    | SelectStatementSnippet(on=on) -> on
  member this.OptimizerHints = 
    match this with
    | Base (optimizerHints=optimizerHints) -> optimizerHints
    | SelectStatementSnippet(optimizerHints=optimizerHints) -> optimizerHints
  member this.QueryExpression = 
    match this with
    | Base (queryExpression=queryExpression) -> queryExpression
    | SelectStatementSnippet(queryExpression=queryExpression) -> queryExpression
  member this.WithCtesAndXmlNamespaces = 
    match this with
    | Base (withCtesAndXmlNamespaces=withCtesAndXmlNamespaces) -> withCtesAndXmlNamespaces
    | SelectStatementSnippet(withCtesAndXmlNamespaces=withCtesAndXmlNamespaces) -> withCtesAndXmlNamespaces
  static member FromCs(src:ScriptDom.SelectStatement) : SelectStatement =
    match src with
    | :? ScriptDom.SelectStatementSnippet as src ->
      SelectStatement.SelectStatementSnippet((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.On |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)), (src.Script), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs)))
    | _ -> (* :? ScriptDom.SelectStatement as src *)
      SelectStatement.Base(((src.ComputeClauses |> Seq.map (fun src -> ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))) |> List.ofSeq), (src.Into |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.On |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OptimizerHints |> Seq.map (OptimizerHint.FromCs) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)), (src.WithCtesAndXmlNamespaces |> Option.ofObj |> Option.map (WithCtesAndXmlNamespaces.FromCs))))
and TableReferenceWithAliasAndColumns = (* IsAbstract = true , children = 8*)
  | BulkOpenRowset of alias:Identifier option * columns:(Identifier) list * dataFile:StringLiteral option * options:(BulkInsertOption) list
  | ChangeTableChangesTableReference of alias:Identifier option * columns:(Identifier) list * sinceVersion:ValueExpression option * target:SchemaObjectName option
  | ChangeTableVersionTableReference of alias:Identifier option * columns:(Identifier) list * primaryKeyColumns:(Identifier) list * primaryKeyValues:(ScalarExpression) list * target:SchemaObjectName option
  | DataModificationTableReference of alias:Identifier option * columns:(Identifier) list * dataModificationSpecification:DataModificationSpecification option
  | InlineDerivedTable of alias:Identifier option * columns:(Identifier) list * rowValues:(RowValue) list
  | QueryDerivedTable of alias:Identifier option * columns:(Identifier) list * queryExpression:QueryExpression option
  | SchemaObjectFunctionTableReference of alias:Identifier option * columns:(Identifier) list * parameters:(ScalarExpression) list * schemaObject:SchemaObjectName option
  | VariableMethodCallTableReference of alias:Identifier option * columns:(Identifier) list * methodName:Identifier option * parameters:(ScalarExpression) list * variable:VariableReference option
  member this.ToCs() : ScriptDom.TableReferenceWithAliasAndColumns =
    match this with
    | BulkOpenRowset(alias=aAlias; columns=aColumns; dataFile=aDataFile; options=aOptions) ->
      let ret = ScriptDom.BulkOpenRowset()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.DataFile <- aDataFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | ChangeTableChangesTableReference(alias=aAlias; columns=aColumns; sinceVersion=aSinceVersion; target=aTarget) ->
      let ret = ScriptDom.ChangeTableChangesTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.SinceVersion <- aSinceVersion |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | ChangeTableVersionTableReference(alias=aAlias; columns=aColumns; primaryKeyColumns=aPrimaryKeyColumns; primaryKeyValues=aPrimaryKeyValues; target=aTarget) ->
      let ret = ScriptDom.ChangeTableVersionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aPrimaryKeyColumns do ret.PrimaryKeyColumns.Add (e.ToCs())
      for e in aPrimaryKeyValues do ret.PrimaryKeyValues.Add (e.ToCs())
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | DataModificationTableReference(alias=aAlias; columns=aColumns; dataModificationSpecification=aDataModificationSpecification) ->
      let ret = ScriptDom.DataModificationTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.DataModificationSpecification <- aDataModificationSpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | InlineDerivedTable(alias=aAlias; columns=aColumns; rowValues=aRowValues) ->
      let ret = ScriptDom.InlineDerivedTable()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aRowValues do ret.RowValues.Add (e.ToCs())
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | QueryDerivedTable(alias=aAlias; columns=aColumns; queryExpression=aQueryExpression) ->
      let ret = ScriptDom.QueryDerivedTable()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | SchemaObjectFunctionTableReference(alias=aAlias; columns=aColumns; parameters=aParameters; schemaObject=aSchemaObject) ->
      let ret = ScriptDom.SchemaObjectFunctionTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.SchemaObject <- aSchemaObject |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
    | VariableMethodCallTableReference(alias=aAlias; columns=aColumns; methodName=aMethodName; parameters=aParameters; variable=aVariable) ->
      let ret = ScriptDom.VariableMethodCallTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.MethodName <- aMethodName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret :> ScriptDom.TableReferenceWithAliasAndColumns (* 404 *)
//// shared props TableReferenceWithAliasAndColumns 
  member this.Alias = 
    match this with
    | BulkOpenRowset(alias=alias) -> alias
    | ChangeTableChangesTableReference(alias=alias) -> alias
    | ChangeTableVersionTableReference(alias=alias) -> alias
    | DataModificationTableReference(alias=alias) -> alias
    | InlineDerivedTable(alias=alias) -> alias
    | QueryDerivedTable(alias=alias) -> alias
    | SchemaObjectFunctionTableReference(alias=alias) -> alias
    | VariableMethodCallTableReference(alias=alias) -> alias
  member this.Columns = 
    match this with
    | BulkOpenRowset(columns=columns) -> columns
    | ChangeTableChangesTableReference(columns=columns) -> columns
    | ChangeTableVersionTableReference(columns=columns) -> columns
    | DataModificationTableReference(columns=columns) -> columns
    | InlineDerivedTable(columns=columns) -> columns
    | QueryDerivedTable(columns=columns) -> columns
    | SchemaObjectFunctionTableReference(columns=columns) -> columns
    | VariableMethodCallTableReference(columns=columns) -> columns
  static member FromCs(src:ScriptDom.TableReferenceWithAliasAndColumns) : TableReferenceWithAliasAndColumns =
    match src with
    | :? ScriptDom.BulkOpenRowset as src ->
      TableReferenceWithAliasAndColumns.BulkOpenRowset((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.DataFile |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.Options |> Seq.map (BulkInsertOption.FromCs) |> List.ofSeq))
    | :? ScriptDom.ChangeTableChangesTableReference as src ->
      TableReferenceWithAliasAndColumns.ChangeTableChangesTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SinceVersion |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.Target |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.ChangeTableVersionTableReference as src ->
      TableReferenceWithAliasAndColumns.ChangeTableVersionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrimaryKeyColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrimaryKeyValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.DataModificationTableReference as src ->
      TableReferenceWithAliasAndColumns.DataModificationTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.DataModificationSpecification |> Option.ofObj |> Option.map (DataModificationSpecification.FromCs)))
    | :? ScriptDom.InlineDerivedTable as src ->
      TableReferenceWithAliasAndColumns.InlineDerivedTable((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))) |> List.ofSeq))
    | :? ScriptDom.QueryDerivedTable as src ->
      TableReferenceWithAliasAndColumns.QueryDerivedTable((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
    | :? ScriptDom.SchemaObjectFunctionTableReference as src ->
      TableReferenceWithAliasAndColumns.SchemaObjectFunctionTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.SchemaObject |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
    | :? ScriptDom.VariableMethodCallTableReference as src ->
      TableReferenceWithAliasAndColumns.VariableMethodCallTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.MethodName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and Literal = (* IsAbstract = true , children = 11*)
  | BinaryLiteral of collation:Identifier option * isLargeObject:bool * literalType:ScriptDom.LiteralType * value:String
  | DefaultLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | IdentifierLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * quoteType:ScriptDom.QuoteType * value:String
  | IntegerLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | MaxLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | MoneyLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | NullLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | NumericLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | OdbcLiteral of collation:Identifier option * isNational:bool * literalType:ScriptDom.LiteralType * odbcLiteralType:ScriptDom.OdbcLiteralType * value:String
  | RealLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String
  | StringLiteral of collation:Identifier option * isLargeObject:bool * isNational:bool * literalType:ScriptDom.LiteralType * value:String
  member this.ToCs() : ScriptDom.Literal =
    match this with
    | BinaryLiteral(collation=aCollation; isLargeObject=aIsLargeObject; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.BinaryLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | DefaultLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.DefaultLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | IdentifierLiteral(collation=aCollation; literalType=aLiteralType; quoteType=aQuoteType; value=aValue) ->
      let ret = ScriptDom.IdentifierLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.QuoteType <- aQuoteType
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | IntegerLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.IntegerLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | MaxLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.MaxLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | MoneyLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.MoneyLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | NullLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.NullLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | NumericLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.NumericLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | OdbcLiteral(collation=aCollation; isNational=aIsNational; literalType=aLiteralType; odbcLiteralType=aOdbcLiteralType; value=aValue) ->
      let ret = ScriptDom.OdbcLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsNational <- aIsNational
       // Skipping prop LiteralType - it is Readonly
      ret.OdbcLiteralType <- aOdbcLiteralType
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | RealLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.RealLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
    | StringLiteral(collation=aCollation; isLargeObject=aIsLargeObject; isNational=aIsNational; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.StringLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
      ret.IsNational <- aIsNational
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret :> ScriptDom.Literal (* 404 *)
//// shared props Literal 
  member this.Collation = 
    match this with
    | BinaryLiteral(collation=collation) -> collation
    | DefaultLiteral(collation=collation) -> collation
    | IdentifierLiteral(collation=collation) -> collation
    | IntegerLiteral(collation=collation) -> collation
    | MaxLiteral(collation=collation) -> collation
    | MoneyLiteral(collation=collation) -> collation
    | NullLiteral(collation=collation) -> collation
    | NumericLiteral(collation=collation) -> collation
    | OdbcLiteral(collation=collation) -> collation
    | RealLiteral(collation=collation) -> collation
    | StringLiteral(collation=collation) -> collation
  member this.LiteralType = 
    match this with
    | BinaryLiteral(literalType=literalType) -> literalType
    | DefaultLiteral(literalType=literalType) -> literalType
    | IdentifierLiteral(literalType=literalType) -> literalType
    | IntegerLiteral(literalType=literalType) -> literalType
    | MaxLiteral(literalType=literalType) -> literalType
    | MoneyLiteral(literalType=literalType) -> literalType
    | NullLiteral(literalType=literalType) -> literalType
    | NumericLiteral(literalType=literalType) -> literalType
    | OdbcLiteral(literalType=literalType) -> literalType
    | RealLiteral(literalType=literalType) -> literalType
    | StringLiteral(literalType=literalType) -> literalType
  member this.Value = 
    match this with
    | BinaryLiteral(value=value) -> value
    | DefaultLiteral(value=value) -> value
    | IdentifierLiteral(value=value) -> value
    | IntegerLiteral(value=value) -> value
    | MaxLiteral(value=value) -> value
    | MoneyLiteral(value=value) -> value
    | NullLiteral(value=value) -> value
    | NumericLiteral(value=value) -> value
    | OdbcLiteral(value=value) -> value
    | RealLiteral(value=value) -> value
    | StringLiteral(value=value) -> value
  static member FromCs(src:ScriptDom.Literal) : Literal =
    match src with
    | :? ScriptDom.BinaryLiteral as src ->
      Literal.BinaryLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.LiteralType), (src.Value))
    | :? ScriptDom.DefaultLiteral as src ->
      Literal.DefaultLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.IdentifierLiteral as src ->
      Literal.IdentifierLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.QuoteType), (src.Value))
    | :? ScriptDom.IntegerLiteral as src ->
      Literal.IntegerLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.MaxLiteral as src ->
      Literal.MaxLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.MoneyLiteral as src ->
      Literal.MoneyLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.NullLiteral as src ->
      Literal.NullLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.NumericLiteral as src ->
      Literal.NumericLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.OdbcLiteral as src ->
      Literal.OdbcLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsNational), (src.LiteralType), (src.OdbcLiteralType), (src.Value))
    | :? ScriptDom.RealLiteral as src ->
      Literal.RealLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
    | :? ScriptDom.StringLiteral as src ->
      Literal.StringLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (src.Value))
// Rendering missing cases
and StringLiteral = (* IsAbstract = false , children = 0*)
  | StringLiteral of collation:Identifier option * isLargeObject:bool * isNational:bool * literalType:ScriptDom.LiteralType * value:String  
  member this.ToCs() : ScriptDom.StringLiteral =
    match this with
    | StringLiteral(collation=aCollation; isLargeObject=aIsLargeObject; isNational=aIsNational; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.StringLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
      ret.IsNational <- aIsNational
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret (* 402 *)
//// shared props StringLiteral 
  member this.Collation = let (StringLiteral.StringLiteral(collation=x)) = this in x
  member this.IsLargeObject = let (StringLiteral.StringLiteral(isLargeObject=x)) = this in x
  member this.IsNational = let (StringLiteral.StringLiteral(isNational=x)) = this in x
  member this.LiteralType = let (StringLiteral.StringLiteral(literalType=x)) = this in x
  member this.Value = let (StringLiteral.StringLiteral(value=x)) = this in x
  static member FromCs(src:ScriptDom.StringLiteral) : StringLiteral =
    StringLiteral.StringLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.IsNational), (src.LiteralType), (src.Value))
and AlterAvailabilityGroupFailoverOption = (* IsAbstract = false , children = 0*)
  | AlterAvailabilityGroupFailoverOption of optionKind:ScriptDom.FailoverActionOptionKind * value:Literal option  
  member this.ToCs() : ScriptDom.AlterAvailabilityGroupFailoverOption =
    match this with
    | AlterAvailabilityGroupFailoverOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.AlterAvailabilityGroupFailoverOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AlterAvailabilityGroupFailoverOption 
  member this.OptionKind = let (AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption(optionKind=x)) = this in x
  member this.Value = let (AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.AlterAvailabilityGroupFailoverOption) : AlterAvailabilityGroupFailoverOption =
    AlterAvailabilityGroupFailoverOption.AlterAvailabilityGroupFailoverOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and FullTextIndexColumn = (* IsAbstract = false , children = 0*)
  | FullTextIndexColumn of languageTerm:IdentifierOrValueExpression option * name:Identifier option * statisticalSemantics:bool * typeColumn:Identifier option  
  member this.ToCs() : ScriptDom.FullTextIndexColumn =
    match this with
    | FullTextIndexColumn(languageTerm=aLanguageTerm; name=aName; statisticalSemantics=aStatisticalSemantics; typeColumn=aTypeColumn) ->
      let ret = ScriptDom.FullTextIndexColumn()
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StatisticalSemantics <- aStatisticalSemantics
      ret.TypeColumn <- aTypeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FullTextIndexColumn 
  member this.LanguageTerm = let (FullTextIndexColumn.FullTextIndexColumn(languageTerm=x)) = this in x
  member this.Name = let (FullTextIndexColumn.FullTextIndexColumn(name=x)) = this in x
  member this.StatisticalSemantics = let (FullTextIndexColumn.FullTextIndexColumn(statisticalSemantics=x)) = this in x
  member this.TypeColumn = let (FullTextIndexColumn.FullTextIndexColumn(typeColumn=x)) = this in x
  static member FromCs(src:ScriptDom.FullTextIndexColumn) : FullTextIndexColumn =
    FullTextIndexColumn.FullTextIndexColumn((src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StatisticalSemantics), (src.TypeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
and SearchPropertyListFullTextIndexOption = (* IsAbstract = false , children = 0*)
  | SearchPropertyListFullTextIndexOption of isOff:bool * optionKind:ScriptDom.FullTextIndexOptionKind * propertyListName:Identifier option  
  member this.ToCs() : ScriptDom.SearchPropertyListFullTextIndexOption =
    match this with
    | SearchPropertyListFullTextIndexOption(isOff=aIsOff; optionKind=aOptionKind; propertyListName=aPropertyListName) ->
      let ret = ScriptDom.SearchPropertyListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.PropertyListName <- aPropertyListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SearchPropertyListFullTextIndexOption 
  member this.IsOff = let (SearchPropertyListFullTextIndexOption.SearchPropertyListFullTextIndexOption(isOff=x)) = this in x
  member this.OptionKind = let (SearchPropertyListFullTextIndexOption.SearchPropertyListFullTextIndexOption(optionKind=x)) = this in x
  member this.PropertyListName = let (SearchPropertyListFullTextIndexOption.SearchPropertyListFullTextIndexOption(propertyListName=x)) = this in x
  static member FromCs(src:ScriptDom.SearchPropertyListFullTextIndexOption) : SearchPropertyListFullTextIndexOption =
    SearchPropertyListFullTextIndexOption.SearchPropertyListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.PropertyListName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and StopListFullTextIndexOption = (* IsAbstract = false , children = 0*)
  | StopListFullTextIndexOption of isOff:bool * optionKind:ScriptDom.FullTextIndexOptionKind * stopListName:Identifier option  
  member this.ToCs() : ScriptDom.StopListFullTextIndexOption =
    match this with
    | StopListFullTextIndexOption(isOff=aIsOff; optionKind=aOptionKind; stopListName=aStopListName) ->
      let ret = ScriptDom.StopListFullTextIndexOption()
      ret.IsOff <- aIsOff
      ret.OptionKind <- aOptionKind
      ret.StopListName <- aStopListName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props StopListFullTextIndexOption 
  member this.IsOff = let (StopListFullTextIndexOption.StopListFullTextIndexOption(isOff=x)) = this in x
  member this.OptionKind = let (StopListFullTextIndexOption.StopListFullTextIndexOption(optionKind=x)) = this in x
  member this.StopListName = let (StopListFullTextIndexOption.StopListFullTextIndexOption(stopListName=x)) = this in x
  static member FromCs(src:ScriptDom.StopListFullTextIndexOption) : StopListFullTextIndexOption =
    StopListFullTextIndexOption.StopListFullTextIndexOption((src.IsOff), (src.OptionKind), (src.StopListName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and IdentifierOrValueExpression = (* IsAbstract = false , children = 0*)
  | IdentifierOrValueExpression of identifier:Identifier option * value:String * valueExpression:ValueExpression option  
  member this.ToCs() : ScriptDom.IdentifierOrValueExpression =
    match this with
    | IdentifierOrValueExpression(identifier=aIdentifier; value=aValue; valueExpression=aValueExpression) ->
      let ret = ScriptDom.IdentifierOrValueExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop Value - it is Readonly
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props IdentifierOrValueExpression 
  member this.Identifier = let (IdentifierOrValueExpression.IdentifierOrValueExpression(identifier=x)) = this in x
  member this.Value = let (IdentifierOrValueExpression.IdentifierOrValueExpression(value=x)) = this in x
  member this.ValueExpression = let (IdentifierOrValueExpression.IdentifierOrValueExpression(valueExpression=x)) = this in x
  static member FromCs(src:ScriptDom.IdentifierOrValueExpression) : IdentifierOrValueExpression =
    IdentifierOrValueExpression.IdentifierOrValueExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Value), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
and DatabaseAuditAction = (* IsAbstract = false , children = 0*)
  | DatabaseAuditAction of actionKind:ScriptDom.DatabaseAuditActionKind  
  member this.ToCs() : ScriptDom.DatabaseAuditAction =
    match this with
    | DatabaseAuditAction(actionKind=aActionKind) ->
      let ret = ScriptDom.DatabaseAuditAction()
      ret.ActionKind <- aActionKind
      ret (* 402 *)
//// shared props DatabaseAuditAction 
  member this.ActionKind = let (DatabaseAuditAction.DatabaseAuditAction(actionKind=x)) = this in x
  static member FromCs(src:ScriptDom.DatabaseAuditAction) : DatabaseAuditAction =
    DatabaseAuditAction.DatabaseAuditAction((src.ActionKind))
and SecurityPrincipal = (* IsAbstract = false , children = 0*)
  | SecurityPrincipal of identifier:Identifier option * principalType:ScriptDom.PrincipalType  
  member this.ToCs() : ScriptDom.SecurityPrincipal =
    match this with
    | SecurityPrincipal(identifier=aIdentifier; principalType=aPrincipalType) ->
      let ret = ScriptDom.SecurityPrincipal()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PrincipalType <- aPrincipalType
      ret (* 402 *)
//// shared props SecurityPrincipal 
  member this.Identifier = let (SecurityPrincipal.SecurityPrincipal(identifier=x)) = this in x
  member this.PrincipalType = let (SecurityPrincipal.SecurityPrincipal(principalType=x)) = this in x
  static member FromCs(src:ScriptDom.SecurityPrincipal) : SecurityPrincipal =
    SecurityPrincipal.SecurityPrincipal((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PrincipalType))
and SecurityTargetObject = (* IsAbstract = false , children = 0*)
  | SecurityTargetObject of columns:(Identifier) list * objectKind:ScriptDom.SecurityObjectKind * objectName:SecurityTargetObjectName option  
  member this.ToCs() : ScriptDom.SecurityTargetObject =
    match this with
    | SecurityTargetObject(columns=aColumns; objectKind=aObjectKind; objectName=aObjectName) ->
      let ret = ScriptDom.SecurityTargetObject()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ObjectKind <- aObjectKind
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SecurityTargetObject 
  member this.Columns = let (SecurityTargetObject.SecurityTargetObject(columns=x)) = this in x
  member this.ObjectKind = let (SecurityTargetObject.SecurityTargetObject(objectKind=x)) = this in x
  member this.ObjectName = let (SecurityTargetObject.SecurityTargetObject(objectName=x)) = this in x
  static member FromCs(src:ScriptDom.SecurityTargetObject) : SecurityTargetObject =
    SecurityTargetObject.SecurityTargetObject((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ObjectKind), (src.ObjectName |> Option.ofObj |> Option.map (SecurityTargetObjectName.FromCs)))
and CryptoMechanism = (* IsAbstract = false , children = 0*)
  | CryptoMechanism of cryptoMechanismType:ScriptDom.CryptoMechanismType * identifier:Identifier option * passwordOrSignature:Literal option  
  member this.ToCs() : ScriptDom.CryptoMechanism =
    match this with
    | CryptoMechanism(cryptoMechanismType=aCryptoMechanismType; identifier=aIdentifier; passwordOrSignature=aPasswordOrSignature) ->
      let ret = ScriptDom.CryptoMechanism()
      ret.CryptoMechanismType <- aCryptoMechanismType
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PasswordOrSignature <- aPasswordOrSignature |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props CryptoMechanism 
  member this.CryptoMechanismType = let (CryptoMechanism.CryptoMechanism(cryptoMechanismType=x)) = this in x
  member this.Identifier = let (CryptoMechanism.CryptoMechanism(identifier=x)) = this in x
  member this.PasswordOrSignature = let (CryptoMechanism.CryptoMechanism(passwordOrSignature=x)) = this in x
  static member FromCs(src:ScriptDom.CryptoMechanism) : CryptoMechanism =
    CryptoMechanism.CryptoMechanism((src.CryptoMechanismType), (src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.PasswordOrSignature |> Option.ofObj |> Option.map (Literal.FromCs)))
and EventSessionObjectName = (* IsAbstract = false , children = 0*)
  | EventSessionObjectName of multiPartIdentifier:MultiPartIdentifier option  
  member this.ToCs() : ScriptDom.EventSessionObjectName =
    match this with
    | EventSessionObjectName(multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.EventSessionObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props EventSessionObjectName 
  member this.MultiPartIdentifier = let (EventSessionObjectName.EventSessionObjectName(multiPartIdentifier=x)) = this in x
  static member FromCs(src:ScriptDom.EventSessionObjectName) : EventSessionObjectName =
    EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
and SourceDeclaration = (* IsAbstract = false , children = 0*)
  | SourceDeclaration of value:EventSessionObjectName option  
  member this.ToCs() : ScriptDom.SourceDeclaration =
    match this with
    | SourceDeclaration(value=aValue) ->
      let ret = ScriptDom.SourceDeclaration()
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SourceDeclaration 
  member this.Value = let (SourceDeclaration.SourceDeclaration(value=x)) = this in x
  static member FromCs(src:ScriptDom.SourceDeclaration) : SourceDeclaration =
    SourceDeclaration.SourceDeclaration((src.Value |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))
and ScalarSubquery = (* IsAbstract = false , children = 0*)
  | ScalarSubquery of collation:Identifier option * queryExpression:QueryExpression option  
  member this.ToCs() : ScriptDom.ScalarSubquery =
    match this with
    | ScalarSubquery(collation=aCollation; queryExpression=aQueryExpression) ->
      let ret = ScriptDom.ScalarSubquery()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ScalarSubquery 
  member this.Collation = let (ScalarSubquery.ScalarSubquery(collation=x)) = this in x
  member this.QueryExpression = let (ScalarSubquery.ScalarSubquery(queryExpression=x)) = this in x
  static member FromCs(src:ScriptDom.ScalarSubquery) : ScalarSubquery =
    ScalarSubquery.ScalarSubquery((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
and ColumnReferenceExpression = (* IsAbstract = false , children = 0*)
  | ColumnReferenceExpression of collation:Identifier option * columnType:ScriptDom.ColumnType * multiPartIdentifier:MultiPartIdentifier option  
  member this.ToCs() : ScriptDom.ColumnReferenceExpression =
    match this with
    | ColumnReferenceExpression(collation=aCollation; columnType=aColumnType; multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.ColumnReferenceExpression()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnType <- aColumnType
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ColumnReferenceExpression 
  member this.Collation = let (ColumnReferenceExpression.ColumnReferenceExpression(collation=x)) = this in x
  member this.ColumnType = let (ColumnReferenceExpression.ColumnReferenceExpression(columnType=x)) = this in x
  member this.MultiPartIdentifier = let (ColumnReferenceExpression.ColumnReferenceExpression(multiPartIdentifier=x)) = this in x
  static member FromCs(src:ScriptDom.ColumnReferenceExpression) : ColumnReferenceExpression =
    ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
and GraphMatchNodeExpression = (* IsAbstract = false , children = 0*)
  | GraphMatchNodeExpression of node:Identifier option * usesLastNode:bool  
  member this.ToCs() : ScriptDom.GraphMatchNodeExpression =
    match this with
    | GraphMatchNodeExpression(node=aNode; usesLastNode=aUsesLastNode) ->
      let ret = ScriptDom.GraphMatchNodeExpression()
      ret.Node <- aNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UsesLastNode <- aUsesLastNode
      ret (* 402 *)
//// shared props GraphMatchNodeExpression 
  member this.Node = let (GraphMatchNodeExpression.GraphMatchNodeExpression(node=x)) = this in x
  member this.UsesLastNode = let (GraphMatchNodeExpression.GraphMatchNodeExpression(usesLastNode=x)) = this in x
  static member FromCs(src:ScriptDom.GraphMatchNodeExpression) : GraphMatchNodeExpression =
    GraphMatchNodeExpression.GraphMatchNodeExpression((src.Node |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UsesLastNode))
and GraphRecursiveMatchQuantifier = (* IsAbstract = false , children = 0*)
  | GraphRecursiveMatchQuantifier of isPlusSign:bool * lowerLimit:Literal option * upperLimit:Literal option  
  member this.ToCs() : ScriptDom.GraphRecursiveMatchQuantifier =
    match this with
    | GraphRecursiveMatchQuantifier(isPlusSign=aIsPlusSign; lowerLimit=aLowerLimit; upperLimit=aUpperLimit) ->
      let ret = ScriptDom.GraphRecursiveMatchQuantifier()
      ret.IsPlusSign <- aIsPlusSign
      ret.LowerLimit <- aLowerLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UpperLimit <- aUpperLimit |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props GraphRecursiveMatchQuantifier 
  member this.IsPlusSign = let (GraphRecursiveMatchQuantifier.GraphRecursiveMatchQuantifier(isPlusSign=x)) = this in x
  member this.LowerLimit = let (GraphRecursiveMatchQuantifier.GraphRecursiveMatchQuantifier(lowerLimit=x)) = this in x
  member this.UpperLimit = let (GraphRecursiveMatchQuantifier.GraphRecursiveMatchQuantifier(upperLimit=x)) = this in x
  static member FromCs(src:ScriptDom.GraphRecursiveMatchQuantifier) : GraphRecursiveMatchQuantifier =
    GraphRecursiveMatchQuantifier.GraphRecursiveMatchQuantifier((src.IsPlusSign), (src.LowerLimit |> Option.ofObj |> Option.map (Literal.FromCs)), (src.UpperLimit |> Option.ofObj |> Option.map (Literal.FromCs)))
and ColumnWithSortOrder = (* IsAbstract = false , children = 0*)
  | ColumnWithSortOrder of column:ColumnReferenceExpression option * sortOrder:ScriptDom.SortOrder  
  member this.ToCs() : ScriptDom.ColumnWithSortOrder =
    match this with
    | ColumnWithSortOrder(column=aColumn; sortOrder=aSortOrder) ->
      let ret = ScriptDom.ColumnWithSortOrder()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret (* 402 *)
//// shared props ColumnWithSortOrder 
  member this.Column = let (ColumnWithSortOrder.ColumnWithSortOrder(column=x)) = this in x
  member this.SortOrder = let (ColumnWithSortOrder.ColumnWithSortOrder(sortOrder=x)) = this in x
  static member FromCs(src:ScriptDom.ColumnWithSortOrder) : ColumnWithSortOrder =
    ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))
and DefaultConstraintDefinition = (* IsAbstract = false , children = 0*)
  | DefaultConstraintDefinition of column:Identifier option * constraintIdentifier:Identifier option * expression:ScalarExpression option * withValues:bool  
  member this.ToCs() : ScriptDom.DefaultConstraintDefinition =
    match this with
    | DefaultConstraintDefinition(column=aColumn; constraintIdentifier=aConstraintIdentifier; expression=aExpression; withValues=aWithValues) ->
      let ret = ScriptDom.DefaultConstraintDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WithValues <- aWithValues
      ret (* 402 *)
//// shared props DefaultConstraintDefinition 
  member this.Column = let (DefaultConstraintDefinition.DefaultConstraintDefinition(column=x)) = this in x
  member this.ConstraintIdentifier = let (DefaultConstraintDefinition.DefaultConstraintDefinition(constraintIdentifier=x)) = this in x
  member this.Expression = let (DefaultConstraintDefinition.DefaultConstraintDefinition(expression=x)) = this in x
  member this.WithValues = let (DefaultConstraintDefinition.DefaultConstraintDefinition(withValues=x)) = this in x
  static member FromCs(src:ScriptDom.DefaultConstraintDefinition) : DefaultConstraintDefinition =
    DefaultConstraintDefinition.DefaultConstraintDefinition((src.Column |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WithValues))
and ColumnEncryptionDefinition = (* IsAbstract = false , children = 0*)
  | ColumnEncryptionDefinition of parameters:(ColumnEncryptionDefinitionParameter) list  
  member this.ToCs() : ScriptDom.ColumnEncryptionDefinition =
    match this with
    | ColumnEncryptionDefinition(parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionDefinition()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret (* 402 *)
//// shared props ColumnEncryptionDefinition 
  member this.Parameters = let (ColumnEncryptionDefinition.ColumnEncryptionDefinition(parameters=x)) = this in x
  static member FromCs(src:ScriptDom.ColumnEncryptionDefinition) : ColumnEncryptionDefinition =
    ColumnEncryptionDefinition.ColumnEncryptionDefinition((src.Parameters |> Seq.map (ColumnEncryptionDefinitionParameter.FromCs) |> List.ofSeq))
and IdentityOptions = (* IsAbstract = false , children = 0*)
  | IdentityOptions of identityIncrement:ScalarExpression option * identitySeed:ScalarExpression option * isIdentityNotForReplication:bool  
  member this.ToCs() : ScriptDom.IdentityOptions =
    match this with
    | IdentityOptions(identityIncrement=aIdentityIncrement; identitySeed=aIdentitySeed; isIdentityNotForReplication=aIsIdentityNotForReplication) ->
      let ret = ScriptDom.IdentityOptions()
      ret.IdentityIncrement <- aIdentityIncrement |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IdentitySeed <- aIdentitySeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsIdentityNotForReplication <- aIsIdentityNotForReplication
      ret (* 402 *)
//// shared props IdentityOptions 
  member this.IdentityIncrement = let (IdentityOptions.IdentityOptions(identityIncrement=x)) = this in x
  member this.IdentitySeed = let (IdentityOptions.IdentityOptions(identitySeed=x)) = this in x
  member this.IsIdentityNotForReplication = let (IdentityOptions.IdentityOptions(isIdentityNotForReplication=x)) = this in x
  static member FromCs(src:ScriptDom.IdentityOptions) : IdentityOptions =
    IdentityOptions.IdentityOptions((src.IdentityIncrement |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IdentitySeed |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.IsIdentityNotForReplication))
and IndexDefinition = (* IsAbstract = false , children = 0*)
  | IndexDefinition of columns:(ColumnWithSortOrder) list * fileStreamOn:IdentifierOrValueExpression option * filterPredicate:BooleanExpression option * indexOptions:(IndexOption) list * indexType:IndexType option * name:Identifier option * onFileGroupOrPartitionScheme:FileGroupOrPartitionScheme option * unique:bool  
  member this.ToCs() : ScriptDom.IndexDefinition =
    match this with
    | IndexDefinition(columns=aColumns; fileStreamOn=aFileStreamOn; filterPredicate=aFilterPredicate; indexOptions=aIndexOptions; indexType=aIndexType; name=aName; onFileGroupOrPartitionScheme=aOnFileGroupOrPartitionScheme; unique=aUnique) ->
      let ret = ScriptDom.IndexDefinition()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.FileStreamOn <- aFileStreamOn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FilterPredicate <- aFilterPredicate |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIndexOptions do ret.IndexOptions.Add (e.ToCs())
      ret.IndexType <- aIndexType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OnFileGroupOrPartitionScheme <- aOnFileGroupOrPartitionScheme |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Unique <- aUnique
      ret (* 402 *)
//// shared props IndexDefinition 
  member this.Columns = let (IndexDefinition.IndexDefinition(columns=x)) = this in x
  member this.FileStreamOn = let (IndexDefinition.IndexDefinition(fileStreamOn=x)) = this in x
  member this.FilterPredicate = let (IndexDefinition.IndexDefinition(filterPredicate=x)) = this in x
  member this.IndexOptions = let (IndexDefinition.IndexDefinition(indexOptions=x)) = this in x
  member this.IndexType = let (IndexDefinition.IndexDefinition(indexType=x)) = this in x
  member this.Name = let (IndexDefinition.IndexDefinition(name=x)) = this in x
  member this.OnFileGroupOrPartitionScheme = let (IndexDefinition.IndexDefinition(onFileGroupOrPartitionScheme=x)) = this in x
  member this.Unique = let (IndexDefinition.IndexDefinition(unique=x)) = this in x
  static member FromCs(src:ScriptDom.IndexDefinition) : IndexDefinition =
    IndexDefinition.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Unique))
and ColumnStorageOptions = (* IsAbstract = false , children = 0*)
  | ColumnStorageOptions of isFileStream:bool * sparseOption:ScriptDom.SparseColumnOption  
  member this.ToCs() : ScriptDom.ColumnStorageOptions =
    match this with
    | ColumnStorageOptions(isFileStream=aIsFileStream; sparseOption=aSparseOption) ->
      let ret = ScriptDom.ColumnStorageOptions()
      ret.IsFileStream <- aIsFileStream
      ret.SparseOption <- aSparseOption
      ret (* 402 *)
//// shared props ColumnStorageOptions 
  member this.IsFileStream = let (ColumnStorageOptions.ColumnStorageOptions(isFileStream=x)) = this in x
  member this.SparseOption = let (ColumnStorageOptions.ColumnStorageOptions(sparseOption=x)) = this in x
  static member FromCs(src:ScriptDom.ColumnStorageOptions) : ColumnStorageOptions =
    ColumnStorageOptions.ColumnStorageOptions((src.IsFileStream), (src.SparseOption))
and BinaryLiteral = (* IsAbstract = false , children = 0*)
  | BinaryLiteral of collation:Identifier option * isLargeObject:bool * literalType:ScriptDom.LiteralType * value:String  
  member this.ToCs() : ScriptDom.BinaryLiteral =
    match this with
    | BinaryLiteral(collation=aCollation; isLargeObject=aIsLargeObject; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.BinaryLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsLargeObject <- aIsLargeObject
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret (* 402 *)
//// shared props BinaryLiteral 
  member this.Collation = let (BinaryLiteral.BinaryLiteral(collation=x)) = this in x
  member this.IsLargeObject = let (BinaryLiteral.BinaryLiteral(isLargeObject=x)) = this in x
  member this.LiteralType = let (BinaryLiteral.BinaryLiteral(literalType=x)) = this in x
  member this.Value = let (BinaryLiteral.BinaryLiteral(value=x)) = this in x
  static member FromCs(src:ScriptDom.BinaryLiteral) : BinaryLiteral =
    BinaryLiteral.BinaryLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.IsLargeObject), (src.LiteralType), (src.Value))
and ComputeFunction = (* IsAbstract = false , children = 0*)
  | ComputeFunction of computeFunctionType:ScriptDom.ComputeFunctionType * expression:ScalarExpression option  
  member this.ToCs() : ScriptDom.ComputeFunction =
    match this with
    | ComputeFunction(computeFunctionType=aComputeFunctionType; expression=aExpression) ->
      let ret = ScriptDom.ComputeFunction()
      ret.ComputeFunctionType <- aComputeFunctionType
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ComputeFunction 
  member this.ComputeFunctionType = let (ComputeFunction.ComputeFunction(computeFunctionType=x)) = this in x
  member this.Expression = let (ComputeFunction.ComputeFunction(expression=x)) = this in x
  static member FromCs(src:ScriptDom.ComputeFunction) : ComputeFunction =
    ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and GraphConnectionBetweenNodes = (* IsAbstract = false , children = 0*)
  | GraphConnectionBetweenNodes of fromNode:SchemaObjectName option * toNode:SchemaObjectName option  
  member this.ToCs() : ScriptDom.GraphConnectionBetweenNodes =
    match this with
    | GraphConnectionBetweenNodes(fromNode=aFromNode; toNode=aToNode) ->
      let ret = ScriptDom.GraphConnectionBetweenNodes()
      ret.FromNode <- aFromNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ToNode <- aToNode |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props GraphConnectionBetweenNodes 
  member this.FromNode = let (GraphConnectionBetweenNodes.GraphConnectionBetweenNodes(fromNode=x)) = this in x
  member this.ToNode = let (GraphConnectionBetweenNodes.GraphConnectionBetweenNodes(toNode=x)) = this in x
  static member FromCs(src:ScriptDom.GraphConnectionBetweenNodes) : GraphConnectionBetweenNodes =
    GraphConnectionBetweenNodes.GraphConnectionBetweenNodes((src.FromNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ToNode |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and IndexType = (* IsAbstract = false , children = 0*)
  | IndexType of indexTypeKind:(ScriptDom.IndexTypeKind) option  
  member this.ToCs() : ScriptDom.IndexType =
    match this with
    | IndexType(indexTypeKind=aIndexTypeKind) ->
      let ret = ScriptDom.IndexType()
      ret.IndexTypeKind <- Option.toNullable aIndexTypeKind
      ret (* 402 *)
//// shared props IndexType 
  member this.IndexTypeKind = let (IndexType.IndexType(indexTypeKind=x)) = this in x
  static member FromCs(src:ScriptDom.IndexType) : IndexType =
    IndexType.IndexType((Option.ofNullable (src.IndexTypeKind)))
and FileGroupOrPartitionScheme = (* IsAbstract = false , children = 0*)
  | FileGroupOrPartitionScheme of name:IdentifierOrValueExpression option * partitionSchemeColumns:(Identifier) list  
  member this.ToCs() : ScriptDom.FileGroupOrPartitionScheme =
    match this with
    | FileGroupOrPartitionScheme(name=aName; partitionSchemeColumns=aPartitionSchemeColumns) ->
      let ret = ScriptDom.FileGroupOrPartitionScheme()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitionSchemeColumns do ret.PartitionSchemeColumns.Add (e.ToCs())
      ret (* 402 *)
//// shared props FileGroupOrPartitionScheme 
  member this.Name = let (FileGroupOrPartitionScheme.FileGroupOrPartitionScheme(name=x)) = this in x
  member this.PartitionSchemeColumns = let (FileGroupOrPartitionScheme.FileGroupOrPartitionScheme(partitionSchemeColumns=x)) = this in x
  static member FromCs(src:ScriptDom.FileGroupOrPartitionScheme) : FileGroupOrPartitionScheme =
    FileGroupOrPartitionScheme.FileGroupOrPartitionScheme((src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PartitionSchemeColumns |> Seq.map (Identifier.FromCs) |> List.ofSeq))
and CursorOption = (* IsAbstract = false , children = 0*)
  | CursorOption of optionKind:ScriptDom.CursorOptionKind  
  member this.ToCs() : ScriptDom.CursorOption =
    match this with
    | CursorOption(optionKind=aOptionKind) ->
      let ret = ScriptDom.CursorOption()
      ret.OptionKind <- aOptionKind
      ret (* 402 *)
//// shared props CursorOption 
  member this.OptionKind = let (CursorOption.CursorOption(optionKind=x)) = this in x
  static member FromCs(src:ScriptDom.CursorOption) : CursorOption =
    CursorOption.CursorOption((src.OptionKind))
and OutputClause = (* IsAbstract = false , children = 0*)
  | OutputClause of selectColumns:(SelectElement) list  
  member this.ToCs() : ScriptDom.OutputClause =
    match this with
    | OutputClause(selectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputClause()
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret (* 402 *)
//// shared props OutputClause 
  member this.SelectColumns = let (OutputClause.OutputClause(selectColumns=x)) = this in x
  static member FromCs(src:ScriptDom.OutputClause) : OutputClause =
    OutputClause.OutputClause((src.SelectColumns |> Seq.map (SelectElement.FromCs) |> List.ofSeq))
and OutputIntoClause = (* IsAbstract = false , children = 0*)
  | OutputIntoClause of intoTable:TableReference option * intoTableColumns:(ColumnReferenceExpression) list * selectColumns:(SelectElement) list  
  member this.ToCs() : ScriptDom.OutputIntoClause =
    match this with
    | OutputIntoClause(intoTable=aIntoTable; intoTableColumns=aIntoTableColumns; selectColumns=aSelectColumns) ->
      let ret = ScriptDom.OutputIntoClause()
      ret.IntoTable <- aIntoTable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aIntoTableColumns do ret.IntoTableColumns.Add (e.ToCs())
      for e in aSelectColumns do ret.SelectColumns.Add (e.ToCs())
      ret (* 402 *)
//// shared props OutputIntoClause 
  member this.IntoTable = let (OutputIntoClause.OutputIntoClause(intoTable=x)) = this in x
  member this.IntoTableColumns = let (OutputIntoClause.OutputIntoClause(intoTableColumns=x)) = this in x
  member this.SelectColumns = let (OutputIntoClause.OutputIntoClause(selectColumns=x)) = this in x
  static member FromCs(src:ScriptDom.OutputIntoClause) : OutputIntoClause =
    OutputIntoClause.OutputIntoClause((src.IntoTable |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.IntoTableColumns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.SelectColumns |> Seq.map (SelectElement.FromCs) |> List.ofSeq))
and TopRowFilter = (* IsAbstract = false , children = 0*)
  | TopRowFilter of expression:ScalarExpression option * percent:bool * withTies:bool  
  member this.ToCs() : ScriptDom.TopRowFilter =
    match this with
    | TopRowFilter(expression=aExpression; percent=aPercent; withTies=aWithTies) ->
      let ret = ScriptDom.TopRowFilter()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Percent <- aPercent
      ret.WithTies <- aWithTies
      ret (* 402 *)
//// shared props TopRowFilter 
  member this.Expression = let (TopRowFilter.TopRowFilter(expression=x)) = this in x
  member this.Percent = let (TopRowFilter.TopRowFilter(percent=x)) = this in x
  member this.WithTies = let (TopRowFilter.TopRowFilter(withTies=x)) = this in x
  static member FromCs(src:ScriptDom.TopRowFilter) : TopRowFilter =
    TopRowFilter.TopRowFilter((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Percent), (src.WithTies))
and MergeActionClause = (* IsAbstract = false , children = 0*)
  | MergeActionClause of action:MergeAction option * condition:ScriptDom.MergeCondition * searchCondition:BooleanExpression option  
  member this.ToCs() : ScriptDom.MergeActionClause =
    match this with
    | MergeActionClause(action=aAction; condition=aCondition; searchCondition=aSearchCondition) ->
      let ret = ScriptDom.MergeActionClause()
      ret.Action <- aAction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Condition <- aCondition
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props MergeActionClause 
  member this.Action = let (MergeActionClause.MergeActionClause(action=x)) = this in x
  member this.Condition = let (MergeActionClause.MergeActionClause(condition=x)) = this in x
  member this.SearchCondition = let (MergeActionClause.MergeActionClause(searchCondition=x)) = this in x
  static member FromCs(src:ScriptDom.MergeActionClause) : MergeActionClause =
    MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (MergeAction.FromCs)), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
and FromClause = (* IsAbstract = false , children = 0*)
  | FromClause of tableReferences:(TableReference) list  
  member this.ToCs() : ScriptDom.FromClause =
    match this with
    | FromClause(tableReferences=aTableReferences) ->
      let ret = ScriptDom.FromClause()
      for e in aTableReferences do ret.TableReferences.Add (e.ToCs())
      ret (* 402 *)
//// shared props FromClause 
  member this.TableReferences = let (FromClause.FromClause(tableReferences=x)) = this in x
  static member FromCs(src:ScriptDom.FromClause) : FromClause =
    FromClause.FromClause((src.TableReferences |> Seq.map (TableReference.FromCs) |> List.ofSeq))
and WhereClause = (* IsAbstract = false , children = 0*)
  | WhereClause of cursor:CursorId option * searchCondition:BooleanExpression option  
  member this.ToCs() : ScriptDom.WhereClause =
    match this with
    | WhereClause(cursor=aCursor; searchCondition=aSearchCondition) ->
      let ret = ScriptDom.WhereClause()
      ret.Cursor <- aCursor |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props WhereClause 
  member this.Cursor = let (WhereClause.WhereClause(cursor=x)) = this in x
  member this.SearchCondition = let (WhereClause.WhereClause(searchCondition=x)) = this in x
  static member FromCs(src:ScriptDom.WhereClause) : WhereClause =
    WhereClause.WhereClause((src.Cursor |> Option.ofObj |> Option.map (CursorId.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
and IdentifierOrScalarExpression = (* IsAbstract = false , children = 0*)
  | IdentifierOrScalarExpression of identifier:Identifier option * scalarExpression:ScalarExpression option  
  member this.ToCs() : ScriptDom.IdentifierOrScalarExpression =
    match this with
    | IdentifierOrScalarExpression(identifier=aIdentifier; scalarExpression=aScalarExpression) ->
      let ret = ScriptDom.IdentifierOrScalarExpression()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ScalarExpression <- aScalarExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props IdentifierOrScalarExpression 
  member this.Identifier = let (IdentifierOrScalarExpression.IdentifierOrScalarExpression(identifier=x)) = this in x
  member this.ScalarExpression = let (IdentifierOrScalarExpression.IdentifierOrScalarExpression(scalarExpression=x)) = this in x
  static member FromCs(src:ScriptDom.IdentifierOrScalarExpression) : IdentifierOrScalarExpression =
    IdentifierOrScalarExpression.IdentifierOrScalarExpression((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ScalarExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and TableDefinition = (* IsAbstract = false , children = 0*)
  | TableDefinition of columnDefinitions:(ColumnDefinition) list * indexes:(IndexDefinition) list * systemTimePeriod:SystemTimePeriodDefinition option * tableConstraints:(ConstraintDefinition) list  
  member this.ToCs() : ScriptDom.TableDefinition =
    match this with
    | TableDefinition(columnDefinitions=aColumnDefinitions; indexes=aIndexes; systemTimePeriod=aSystemTimePeriod; tableConstraints=aTableConstraints) ->
      let ret = ScriptDom.TableDefinition()
      for e in aColumnDefinitions do ret.ColumnDefinitions.Add (e.ToCs())
      for e in aIndexes do ret.Indexes.Add (e.ToCs())
      ret.SystemTimePeriod <- aSystemTimePeriod |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTableConstraints do ret.TableConstraints.Add (e.ToCs())
      ret (* 402 *)
//// shared props TableDefinition 
  member this.ColumnDefinitions = let (TableDefinition.TableDefinition(columnDefinitions=x)) = this in x
  member this.Indexes = let (TableDefinition.TableDefinition(indexes=x)) = this in x
  member this.SystemTimePeriod = let (TableDefinition.TableDefinition(systemTimePeriod=x)) = this in x
  member this.TableConstraints = let (TableDefinition.TableDefinition(tableConstraints=x)) = this in x
  static member FromCs(src:ScriptDom.TableDefinition) : TableDefinition =
    TableDefinition.TableDefinition((src.ColumnDefinitions |> Seq.map (fun src -> ColumnDefinition.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Constraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DefaultConstraint |> Option.ofObj |> Option.map (DefaultConstraintDefinition.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (IdentityOptions.FromCs)), (src.Index |> Option.ofObj |> Option.map (IndexDefinition.FromCs)), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))) |> List.ofSeq), (src.Indexes |> Seq.map (fun src -> IndexDefinition.IndexDefinition((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.FileStreamOn |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.FilterPredicate |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.IndexOptions |> Seq.map (IndexOption.FromCs) |> List.ofSeq), (src.IndexType |> Option.ofObj |> Option.map (IndexType.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OnFileGroupOrPartitionScheme |> Option.ofObj |> Option.map (FileGroupOrPartitionScheme.FromCs)), (src.Unique))) |> List.ofSeq), (src.SystemTimePeriod |> Option.ofObj |> Option.map (SystemTimePeriodDefinition.FromCs)), (src.TableConstraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq))
and NullableConstraintDefinition = (* IsAbstract = false , children = 0*)
  | NullableConstraintDefinition of constraintIdentifier:Identifier option * nullable:bool  
  member this.ToCs() : ScriptDom.NullableConstraintDefinition =
    match this with
    | NullableConstraintDefinition(constraintIdentifier=aConstraintIdentifier; nullable=aNullable) ->
      let ret = ScriptDom.NullableConstraintDefinition()
      ret.ConstraintIdentifier <- aConstraintIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable
      ret (* 402 *)
//// shared props NullableConstraintDefinition 
  member this.ConstraintIdentifier = let (NullableConstraintDefinition.NullableConstraintDefinition(constraintIdentifier=x)) = this in x
  member this.Nullable = let (NullableConstraintDefinition.NullableConstraintDefinition(nullable=x)) = this in x
  static member FromCs(src:ScriptDom.NullableConstraintDefinition) : NullableConstraintDefinition =
    NullableConstraintDefinition.NullableConstraintDefinition((src.ConstraintIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Nullable))
and ChildObjectName = (* IsAbstract = false , children = 0*)
  | ChildObjectName of baseIdentifier:Identifier option * childIdentifier:Identifier option * count:Int32 * databaseIdentifier:Identifier option * identifiers:(Identifier) list * schemaIdentifier:Identifier option * serverIdentifier:Identifier option  
  member this.ToCs() : ScriptDom.ChildObjectName =
    match this with
    | ChildObjectName(baseIdentifier=aBaseIdentifier; childIdentifier=aChildIdentifier; count=aCount; databaseIdentifier=aDatabaseIdentifier; identifiers=aIdentifiers; schemaIdentifier=aSchemaIdentifier; serverIdentifier=aServerIdentifier) ->
      let ret = ScriptDom.ChildObjectName()
       // Skipping prop BaseIdentifier - it is Readonly
       // Skipping prop ChildIdentifier - it is Readonly
       // Skipping prop Count - it is Readonly
       // Skipping prop DatabaseIdentifier - it is Readonly
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
       // Skipping prop SchemaIdentifier - it is Readonly
       // Skipping prop ServerIdentifier - it is Readonly
      ret (* 402 *)
//// shared props ChildObjectName 
  member this.BaseIdentifier = let (ChildObjectName.ChildObjectName(baseIdentifier=x)) = this in x
  member this.ChildIdentifier = let (ChildObjectName.ChildObjectName(childIdentifier=x)) = this in x
  member this.Count = let (ChildObjectName.ChildObjectName(count=x)) = this in x
  member this.DatabaseIdentifier = let (ChildObjectName.ChildObjectName(databaseIdentifier=x)) = this in x
  member this.Identifiers = let (ChildObjectName.ChildObjectName(identifiers=x)) = this in x
  member this.SchemaIdentifier = let (ChildObjectName.ChildObjectName(schemaIdentifier=x)) = this in x
  member this.ServerIdentifier = let (ChildObjectName.ChildObjectName(serverIdentifier=x)) = this in x
  static member FromCs(src:ScriptDom.ChildObjectName) : ChildObjectName =
    ChildObjectName.ChildObjectName((src.BaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ChildIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Count), (src.DatabaseIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.SchemaIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ServerIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)))
and IPv4 = (* IsAbstract = false , children = 0*)
  | IPv4 of octetFour:Literal option * octetOne:Literal option * octetThree:Literal option * octetTwo:Literal option  
  member this.ToCs() : ScriptDom.IPv4 =
    match this with
    | IPv4(octetFour=aOctetFour; octetOne=aOctetOne; octetThree=aOctetThree; octetTwo=aOctetTwo) ->
      let ret = ScriptDom.IPv4()
      ret.OctetFour <- aOctetFour |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetOne <- aOctetOne |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetThree <- aOctetThree |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OctetTwo <- aOctetTwo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props IPv4 
  member this.OctetFour = let (IPv4.IPv4(octetFour=x)) = this in x
  member this.OctetOne = let (IPv4.IPv4(octetOne=x)) = this in x
  member this.OctetThree = let (IPv4.IPv4(octetThree=x)) = this in x
  member this.OctetTwo = let (IPv4.IPv4(octetTwo=x)) = this in x
  static member FromCs(src:ScriptDom.IPv4) : IPv4 =
    IPv4.IPv4((src.OctetFour |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OctetOne |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OctetThree |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OctetTwo |> Option.ofObj |> Option.map (Literal.FromCs)))
and EventDeclarationSetParameter = (* IsAbstract = false , children = 0*)
  | EventDeclarationSetParameter of eventField:Identifier option * eventValue:ScalarExpression option  
  member this.ToCs() : ScriptDom.EventDeclarationSetParameter =
    match this with
    | EventDeclarationSetParameter(eventField=aEventField; eventValue=aEventValue) ->
      let ret = ScriptDom.EventDeclarationSetParameter()
      ret.EventField <- aEventField |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.EventValue <- aEventValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props EventDeclarationSetParameter 
  member this.EventField = let (EventDeclarationSetParameter.EventDeclarationSetParameter(eventField=x)) = this in x
  member this.EventValue = let (EventDeclarationSetParameter.EventDeclarationSetParameter(eventValue=x)) = this in x
  static member FromCs(src:ScriptDom.EventDeclarationSetParameter) : EventDeclarationSetParameter =
    EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and ExecuteParameter = (* IsAbstract = false , children = 0*)
  | ExecuteParameter of isOutput:bool * parameterValue:ScalarExpression option * variable:VariableReference option  
  member this.ToCs() : ScriptDom.ExecuteParameter =
    match this with
    | ExecuteParameter(isOutput=aIsOutput; parameterValue=aParameterValue; variable=aVariable) ->
      let ret = ScriptDom.ExecuteParameter()
      ret.IsOutput <- aIsOutput
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ExecuteParameter 
  member this.IsOutput = let (ExecuteParameter.ExecuteParameter(isOutput=x)) = this in x
  member this.ParameterValue = let (ExecuteParameter.ExecuteParameter(parameterValue=x)) = this in x
  member this.Variable = let (ExecuteParameter.ExecuteParameter(variable=x)) = this in x
  static member FromCs(src:ScriptDom.ExecuteParameter) : ExecuteParameter =
    ExecuteParameter.ExecuteParameter((src.IsOutput), (src.ParameterValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and AdHocDataSource = (* IsAbstract = false , children = 0*)
  | AdHocDataSource of initString:StringLiteral option * providerName:StringLiteral option  
  member this.ToCs() : ScriptDom.AdHocDataSource =
    match this with
    | AdHocDataSource(initString=aInitString; providerName=aProviderName) ->
      let ret = ScriptDom.AdHocDataSource()
      ret.InitString <- aInitString |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProviderName <- aProviderName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AdHocDataSource 
  member this.InitString = let (AdHocDataSource.AdHocDataSource(initString=x)) = this in x
  member this.ProviderName = let (AdHocDataSource.AdHocDataSource(providerName=x)) = this in x
  static member FromCs(src:ScriptDom.AdHocDataSource) : AdHocDataSource =
    AdHocDataSource.AdHocDataSource((src.InitString |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.ProviderName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
and ProcedureReferenceName = (* IsAbstract = false , children = 0*)
  | ProcedureReferenceName of procedureReference:ProcedureReference option * procedureVariable:VariableReference option  
  member this.ToCs() : ScriptDom.ProcedureReferenceName =
    match this with
    | ProcedureReferenceName(procedureReference=aProcedureReference; procedureVariable=aProcedureVariable) ->
      let ret = ScriptDom.ProcedureReferenceName()
      ret.ProcedureReference <- aProcedureReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ProcedureVariable <- aProcedureVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ProcedureReferenceName 
  member this.ProcedureReference = let (ProcedureReferenceName.ProcedureReferenceName(procedureReference=x)) = this in x
  member this.ProcedureVariable = let (ProcedureReferenceName.ProcedureReferenceName(procedureVariable=x)) = this in x
  static member FromCs(src:ScriptDom.ProcedureReferenceName) : ProcedureReferenceName =
    ProcedureReferenceName.ProcedureReferenceName((src.ProcedureReference |> Option.ofObj |> Option.map (ProcedureReference.FromCs)), (src.ProcedureVariable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and VariableReference = (* IsAbstract = false , children = 0*)
  | VariableReference of collation:Identifier option * name:String  
  member this.ToCs() : ScriptDom.VariableReference =
    match this with
    | VariableReference(collation=aCollation; name=aName) ->
      let ret = ScriptDom.VariableReference()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName
      ret (* 402 *)
//// shared props VariableReference 
  member this.Collation = let (VariableReference.VariableReference(collation=x)) = this in x
  member this.Name = let (VariableReference.VariableReference(name=x)) = this in x
  static member FromCs(src:ScriptDom.VariableReference) : VariableReference =
    VariableReference.VariableReference((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name))
and ExecuteContext = (* IsAbstract = false , children = 0*)
  | ExecuteContext of kind:ScriptDom.ExecuteAsOption * principal:ScalarExpression option  
  member this.ToCs() : ScriptDom.ExecuteContext =
    match this with
    | ExecuteContext(kind=aKind; principal=aPrincipal) ->
      let ret = ScriptDom.ExecuteContext()
      ret.Kind <- aKind
      ret.Principal <- aPrincipal |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ExecuteContext 
  member this.Kind = let (ExecuteContext.ExecuteContext(kind=x)) = this in x
  member this.Principal = let (ExecuteContext.ExecuteContext(principal=x)) = this in x
  static member FromCs(src:ScriptDom.ExecuteContext) : ExecuteContext =
    ExecuteContext.ExecuteContext((src.Kind), (src.Principal |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and ExternalResourcePoolAffinitySpecification = (* IsAbstract = false , children = 0*)
  | ExternalResourcePoolAffinitySpecification of affinityType:ScriptDom.ExternalResourcePoolAffinityType * isAuto:bool * parameterValue:Literal option * poolAffinityRanges:(LiteralRange) list  
  member this.ToCs() : ScriptDom.ExternalResourcePoolAffinitySpecification =
    match this with
    | ExternalResourcePoolAffinitySpecification(affinityType=aAffinityType; isAuto=aIsAuto; parameterValue=aParameterValue; poolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ExternalResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret (* 402 *)
//// shared props ExternalResourcePoolAffinitySpecification 
  member this.AffinityType = let (ExternalResourcePoolAffinitySpecification.ExternalResourcePoolAffinitySpecification(affinityType=x)) = this in x
  member this.IsAuto = let (ExternalResourcePoolAffinitySpecification.ExternalResourcePoolAffinitySpecification(isAuto=x)) = this in x
  member this.ParameterValue = let (ExternalResourcePoolAffinitySpecification.ExternalResourcePoolAffinitySpecification(parameterValue=x)) = this in x
  member this.PoolAffinityRanges = let (ExternalResourcePoolAffinitySpecification.ExternalResourcePoolAffinitySpecification(poolAffinityRanges=x)) = this in x
  static member FromCs(src:ScriptDom.ExternalResourcePoolAffinitySpecification) : ExternalResourcePoolAffinitySpecification =
    ExternalResourcePoolAffinitySpecification.ExternalResourcePoolAffinitySpecification((src.AffinityType), (src.IsAuto), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)), (src.PoolAffinityRanges |> Seq.map (LiteralRange.FromCs) |> List.ofSeq))
and FileDeclaration = (* IsAbstract = false , children = 0*)
  | FileDeclaration of isPrimary:bool * options:(FileDeclarationOption) list  
  member this.ToCs() : ScriptDom.FileDeclaration =
    match this with
    | FileDeclaration(isPrimary=aIsPrimary; options=aOptions) ->
      let ret = ScriptDom.FileDeclaration()
      ret.IsPrimary <- aIsPrimary
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret (* 402 *)
//// shared props FileDeclaration 
  member this.IsPrimary = let (FileDeclaration.FileDeclaration(isPrimary=x)) = this in x
  member this.Options = let (FileDeclaration.FileDeclaration(options=x)) = this in x
  static member FromCs(src:ScriptDom.FileDeclaration) : FileDeclaration =
    FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))
and JsonForClauseOption = (* IsAbstract = false , children = 0*)
  | JsonForClauseOption of optionKind:ScriptDom.JsonForClauseOptions * value:Literal option  
  member this.ToCs() : ScriptDom.JsonForClauseOption =
    match this with
    | JsonForClauseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.JsonForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props JsonForClauseOption 
  member this.OptionKind = let (JsonForClauseOption.JsonForClauseOption(optionKind=x)) = this in x
  member this.Value = let (JsonForClauseOption.JsonForClauseOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.JsonForClauseOption) : JsonForClauseOption =
    JsonForClauseOption.JsonForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and XmlForClauseOption = (* IsAbstract = false , children = 0*)
  | XmlForClauseOption of optionKind:ScriptDom.XmlForClauseOptions * value:Literal option  
  member this.ToCs() : ScriptDom.XmlForClauseOption =
    match this with
    | XmlForClauseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.XmlForClauseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props XmlForClauseOption 
  member this.OptionKind = let (XmlForClauseOption.XmlForClauseOption(optionKind=x)) = this in x
  member this.Value = let (XmlForClauseOption.XmlForClauseOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.XmlForClauseOption) : XmlForClauseOption =
    XmlForClauseOption.XmlForClauseOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and ExecuteAsClause = (* IsAbstract = false , children = 0*)
  | ExecuteAsClause of executeAsOption:ScriptDom.ExecuteAsOption * literal:Literal option  
  member this.ToCs() : ScriptDom.ExecuteAsClause =
    match this with
    | ExecuteAsClause(executeAsOption=aExecuteAsOption; literal=aLiteral) ->
      let ret = ScriptDom.ExecuteAsClause()
      ret.ExecuteAsOption <- aExecuteAsOption
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ExecuteAsClause 
  member this.ExecuteAsOption = let (ExecuteAsClause.ExecuteAsClause(executeAsOption=x)) = this in x
  member this.Literal = let (ExecuteAsClause.ExecuteAsClause(literal=x)) = this in x
  static member FromCs(src:ScriptDom.ExecuteAsClause) : ExecuteAsClause =
    ExecuteAsClause.ExecuteAsClause((src.ExecuteAsOption), (src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)))
and DeclareTableVariableBody = (* IsAbstract = false , children = 0*)
  | DeclareTableVariableBody of asDefined:bool * definition:TableDefinition option * variableName:Identifier option  
  member this.ToCs() : ScriptDom.DeclareTableVariableBody =
    match this with
    | DeclareTableVariableBody(asDefined=aAsDefined; definition=aDefinition; variableName=aVariableName) ->
      let ret = ScriptDom.DeclareTableVariableBody()
      ret.AsDefined <- aAsDefined
      ret.Definition <- aDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props DeclareTableVariableBody 
  member this.AsDefined = let (DeclareTableVariableBody.DeclareTableVariableBody(asDefined=x)) = this in x
  member this.Definition = let (DeclareTableVariableBody.DeclareTableVariableBody(definition=x)) = this in x
  member this.VariableName = let (DeclareTableVariableBody.DeclareTableVariableBody(variableName=x)) = this in x
  static member FromCs(src:ScriptDom.DeclareTableVariableBody) : DeclareTableVariableBody =
    DeclareTableVariableBody.DeclareTableVariableBody((src.AsDefined), (src.Definition |> Option.ofObj |> Option.map (TableDefinition.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and CompressionPartitionRange = (* IsAbstract = false , children = 0*)
  | CompressionPartitionRange of from:ScalarExpression option * to_:ScalarExpression option  
  member this.ToCs() : ScriptDom.CompressionPartitionRange =
    match this with
    | CompressionPartitionRange(from=aFrom; to_=aTo) ->
      let ret = ScriptDom.CompressionPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props CompressionPartitionRange 
  member this.From = let (CompressionPartitionRange.CompressionPartitionRange(from=x)) = this in x
  member this.To = let (CompressionPartitionRange.CompressionPartitionRange(to_=x)) = this in x
  static member FromCs(src:ScriptDom.CompressionPartitionRange) : CompressionPartitionRange =
    CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and OnlineIndexLowPriorityLockWaitOption = (* IsAbstract = false , children = 0*)
  | OnlineIndexLowPriorityLockWaitOption of options:(LowPriorityLockWaitOption) list  
  member this.ToCs() : ScriptDom.OnlineIndexLowPriorityLockWaitOption =
    match this with
    | OnlineIndexLowPriorityLockWaitOption(options=aOptions) ->
      let ret = ScriptDom.OnlineIndexLowPriorityLockWaitOption()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret (* 402 *)
//// shared props OnlineIndexLowPriorityLockWaitOption 
  member this.Options = let (OnlineIndexLowPriorityLockWaitOption.OnlineIndexLowPriorityLockWaitOption(options=x)) = this in x
  static member FromCs(src:ScriptDom.OnlineIndexLowPriorityLockWaitOption) : OnlineIndexLowPriorityLockWaitOption =
    OnlineIndexLowPriorityLockWaitOption.OnlineIndexLowPriorityLockWaitOption((src.Options |> Seq.map (LowPriorityLockWaitOption.FromCs) |> List.ofSeq))
and ExecuteSpecification = (* IsAbstract = false , children = 0*)
  | ExecuteSpecification of executableEntity:ExecutableEntity option * executeContext:ExecuteContext option * linkedServer:Identifier option * variable:VariableReference option  
  member this.ToCs() : ScriptDom.ExecuteSpecification =
    match this with
    | ExecuteSpecification(executableEntity=aExecutableEntity; executeContext=aExecuteContext; linkedServer=aLinkedServer; variable=aVariable) ->
      let ret = ScriptDom.ExecuteSpecification()
      ret.ExecutableEntity <- aExecutableEntity |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ExecuteContext <- aExecuteContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.LinkedServer <- aLinkedServer |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ExecuteSpecification 
  member this.ExecutableEntity = let (ExecuteSpecification.ExecuteSpecification(executableEntity=x)) = this in x
  member this.ExecuteContext = let (ExecuteSpecification.ExecuteSpecification(executeContext=x)) = this in x
  member this.LinkedServer = let (ExecuteSpecification.ExecuteSpecification(linkedServer=x)) = this in x
  member this.Variable = let (ExecuteSpecification.ExecuteSpecification(variable=x)) = this in x
  static member FromCs(src:ScriptDom.ExecuteSpecification) : ExecuteSpecification =
    ExecuteSpecification.ExecuteSpecification((src.ExecutableEntity |> Option.ofObj |> Option.map (ExecutableEntity.FromCs)), (src.ExecuteContext |> Option.ofObj |> Option.map (ExecuteContext.FromCs)), (src.LinkedServer |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and RowValue = (* IsAbstract = false , children = 0*)
  | RowValue of columnValues:(ScalarExpression) list  
  member this.ToCs() : ScriptDom.RowValue =
    match this with
    | RowValue(columnValues=aColumnValues) ->
      let ret = ScriptDom.RowValue()
      for e in aColumnValues do ret.ColumnValues.Add (e.ToCs())
      ret (* 402 *)
//// shared props RowValue 
  member this.ColumnValues = let (RowValue.RowValue(columnValues=x)) = this in x
  static member FromCs(src:ScriptDom.RowValue) : RowValue =
    RowValue.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))
and ValuesInsertSource = (* IsAbstract = false , children = 0*)
  | ValuesInsertSource of isDefaultValues:bool * rowValues:(RowValue) list  
  member this.ToCs() : ScriptDom.ValuesInsertSource =
    match this with
    | ValuesInsertSource(isDefaultValues=aIsDefaultValues; rowValues=aRowValues) ->
      let ret = ScriptDom.ValuesInsertSource()
      ret.IsDefaultValues <- aIsDefaultValues
      for e in aRowValues do ret.RowValues.Add (e.ToCs())
      ret (* 402 *)
//// shared props ValuesInsertSource 
  member this.IsDefaultValues = let (ValuesInsertSource.ValuesInsertSource(isDefaultValues=x)) = this in x
  member this.RowValues = let (ValuesInsertSource.ValuesInsertSource(rowValues=x)) = this in x
  static member FromCs(src:ScriptDom.ValuesInsertSource) : ValuesInsertSource =
    ValuesInsertSource.ValuesInsertSource((src.IsDefaultValues), (src.RowValues |> Seq.map (fun src -> RowValue.RowValue((src.ColumnValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq))) |> List.ofSeq))
and DeviceInfo = (* IsAbstract = false , children = 0*)
  | DeviceInfo of deviceType:ScriptDom.DeviceType * logicalDevice:IdentifierOrValueExpression option * physicalDevice:ValueExpression option  
  member this.ToCs() : ScriptDom.DeviceInfo =
    match this with
    | DeviceInfo(deviceType=aDeviceType; logicalDevice=aLogicalDevice; physicalDevice=aPhysicalDevice) ->
      let ret = ScriptDom.DeviceInfo()
      ret.DeviceType <- aDeviceType
      ret.LogicalDevice <- aLogicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.PhysicalDevice <- aPhysicalDevice |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props DeviceInfo 
  member this.DeviceType = let (DeviceInfo.DeviceInfo(deviceType=x)) = this in x
  member this.LogicalDevice = let (DeviceInfo.DeviceInfo(logicalDevice=x)) = this in x
  member this.PhysicalDevice = let (DeviceInfo.DeviceInfo(physicalDevice=x)) = this in x
  static member FromCs(src:ScriptDom.DeviceInfo) : DeviceInfo =
    DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
and VariableValuePair = (* IsAbstract = false , children = 0*)
  | VariableValuePair of isForUnknown:bool * value:ScalarExpression option * variable:VariableReference option  
  member this.ToCs() : ScriptDom.VariableValuePair =
    match this with
    | VariableValuePair(isForUnknown=aIsForUnknown; value=aValue; variable=aVariable) ->
      let ret = ScriptDom.VariableValuePair()
      ret.IsForUnknown <- aIsForUnknown
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props VariableValuePair 
  member this.IsForUnknown = let (VariableValuePair.VariableValuePair(isForUnknown=x)) = this in x
  member this.Value = let (VariableValuePair.VariableValuePair(value=x)) = this in x
  member this.Variable = let (VariableValuePair.VariableValuePair(variable=x)) = this in x
  static member FromCs(src:ScriptDom.VariableValuePair) : VariableValuePair =
    VariableValuePair.VariableValuePair((src.IsForUnknown), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and ExpressionWithSortOrder = (* IsAbstract = false , children = 0*)
  | ExpressionWithSortOrder of expression:ScalarExpression option * sortOrder:ScriptDom.SortOrder  
  member this.ToCs() : ScriptDom.ExpressionWithSortOrder =
    match this with
    | ExpressionWithSortOrder(expression=aExpression; sortOrder=aSortOrder) ->
      let ret = ScriptDom.ExpressionWithSortOrder()
      ret.Expression <- aExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SortOrder <- aSortOrder
      ret (* 402 *)
//// shared props ExpressionWithSortOrder 
  member this.Expression = let (ExpressionWithSortOrder.ExpressionWithSortOrder(expression=x)) = this in x
  member this.SortOrder = let (ExpressionWithSortOrder.ExpressionWithSortOrder(sortOrder=x)) = this in x
  static member FromCs(src:ScriptDom.ExpressionWithSortOrder) : ExpressionWithSortOrder =
    ExpressionWithSortOrder.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SortOrder))
and OrderByClause = (* IsAbstract = false , children = 0*)
  | OrderByClause of orderByElements:(ExpressionWithSortOrder) list  
  member this.ToCs() : ScriptDom.OrderByClause =
    match this with
    | OrderByClause(orderByElements=aOrderByElements) ->
      let ret = ScriptDom.OrderByClause()
      for e in aOrderByElements do ret.OrderByElements.Add (e.ToCs())
      ret (* 402 *)
//// shared props OrderByClause 
  member this.OrderByElements = let (OrderByClause.OrderByClause(orderByElements=x)) = this in x
  static member FromCs(src:ScriptDom.OrderByClause) : OrderByClause =
    OrderByClause.OrderByClause((src.OrderByElements |> Seq.map (fun src -> ExpressionWithSortOrder.ExpressionWithSortOrder((src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SortOrder))) |> List.ofSeq))
and WindowFrameClause = (* IsAbstract = false , children = 0*)
  | WindowFrameClause of bottom:WindowDelimiter option * top:WindowDelimiter option * windowFrameType:ScriptDom.WindowFrameType  
  member this.ToCs() : ScriptDom.WindowFrameClause =
    match this with
    | WindowFrameClause(bottom=aBottom; top=aTop; windowFrameType=aWindowFrameType) ->
      let ret = ScriptDom.WindowFrameClause()
      ret.Bottom <- aBottom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Top <- aTop |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowFrameType <- aWindowFrameType
      ret (* 402 *)
//// shared props WindowFrameClause 
  member this.Bottom = let (WindowFrameClause.WindowFrameClause(bottom=x)) = this in x
  member this.Top = let (WindowFrameClause.WindowFrameClause(top=x)) = this in x
  member this.WindowFrameType = let (WindowFrameClause.WindowFrameClause(windowFrameType=x)) = this in x
  static member FromCs(src:ScriptDom.WindowFrameClause) : WindowFrameClause =
    WindowFrameClause.WindowFrameClause((src.Bottom |> Option.ofObj |> Option.map (WindowDelimiter.FromCs)), (src.Top |> Option.ofObj |> Option.map (WindowDelimiter.FromCs)), (src.WindowFrameType))
and ProcedureReference = (* IsAbstract = false , children = 0*)
  | ProcedureReference of name:SchemaObjectName option * number:Literal option  
  member this.ToCs() : ScriptDom.ProcedureReference =
    match this with
    | ProcedureReference(name=aName; number=aNumber) ->
      let ret = ScriptDom.ProcedureReference()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ProcedureReference 
  member this.Name = let (ProcedureReference.ProcedureReference(name=x)) = this in x
  member this.Number = let (ProcedureReference.ProcedureReference(number=x)) = this in x
  static member FromCs(src:ScriptDom.ProcedureReference) : ProcedureReference =
    ProcedureReference.ProcedureReference((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Number |> Option.ofObj |> Option.map (Literal.FromCs)))
and OffsetClause = (* IsAbstract = false , children = 0*)
  | OffsetClause of fetchExpression:ScalarExpression option * offsetExpression:ScalarExpression option  
  member this.ToCs() : ScriptDom.OffsetClause =
    match this with
    | OffsetClause(fetchExpression=aFetchExpression; offsetExpression=aOffsetExpression) ->
      let ret = ScriptDom.OffsetClause()
      ret.FetchExpression <- aFetchExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OffsetExpression <- aOffsetExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props OffsetClause 
  member this.FetchExpression = let (OffsetClause.OffsetClause(fetchExpression=x)) = this in x
  member this.OffsetExpression = let (OffsetClause.OffsetClause(offsetExpression=x)) = this in x
  static member FromCs(src:ScriptDom.OffsetClause) : OffsetClause =
    OffsetClause.OffsetClause((src.FetchExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.OffsetExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and GroupByClause = (* IsAbstract = false , children = 0*)
  | GroupByClause of all:bool * groupByOption:ScriptDom.GroupByOption * groupingSpecifications:(GroupingSpecification) list  
  member this.ToCs() : ScriptDom.GroupByClause =
    match this with
    | GroupByClause(all=aAll; groupByOption=aGroupByOption; groupingSpecifications=aGroupingSpecifications) ->
      let ret = ScriptDom.GroupByClause()
      ret.All <- aAll
      ret.GroupByOption <- aGroupByOption
      for e in aGroupingSpecifications do ret.GroupingSpecifications.Add (e.ToCs())
      ret (* 402 *)
//// shared props GroupByClause 
  member this.All = let (GroupByClause.GroupByClause(all=x)) = this in x
  member this.GroupByOption = let (GroupByClause.GroupByClause(groupByOption=x)) = this in x
  member this.GroupingSpecifications = let (GroupByClause.GroupByClause(groupingSpecifications=x)) = this in x
  static member FromCs(src:ScriptDom.GroupByClause) : GroupByClause =
    GroupByClause.GroupByClause((src.All), (src.GroupByOption), (src.GroupingSpecifications |> Seq.map (GroupingSpecification.FromCs) |> List.ofSeq))
and HavingClause = (* IsAbstract = false , children = 0*)
  | HavingClause of searchCondition:BooleanExpression option  
  member this.ToCs() : ScriptDom.HavingClause =
    match this with
    | HavingClause(searchCondition=aSearchCondition) ->
      let ret = ScriptDom.HavingClause()
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props HavingClause 
  member this.SearchCondition = let (HavingClause.HavingClause(searchCondition=x)) = this in x
  static member FromCs(src:ScriptDom.HavingClause) : HavingClause =
    HavingClause.HavingClause((src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
and ResourcePoolAffinitySpecification = (* IsAbstract = false , children = 0*)
  | ResourcePoolAffinitySpecification of affinityType:ScriptDom.ResourcePoolAffinityType * isAuto:bool * parameterValue:Literal option * poolAffinityRanges:(LiteralRange) list  
  member this.ToCs() : ScriptDom.ResourcePoolAffinitySpecification =
    match this with
    | ResourcePoolAffinitySpecification(affinityType=aAffinityType; isAuto=aIsAuto; parameterValue=aParameterValue; poolAffinityRanges=aPoolAffinityRanges) ->
      let ret = ScriptDom.ResourcePoolAffinitySpecification()
      ret.AffinityType <- aAffinityType
      ret.IsAuto <- aIsAuto
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPoolAffinityRanges do ret.PoolAffinityRanges.Add (e.ToCs())
      ret (* 402 *)
//// shared props ResourcePoolAffinitySpecification 
  member this.AffinityType = let (ResourcePoolAffinitySpecification.ResourcePoolAffinitySpecification(affinityType=x)) = this in x
  member this.IsAuto = let (ResourcePoolAffinitySpecification.ResourcePoolAffinitySpecification(isAuto=x)) = this in x
  member this.ParameterValue = let (ResourcePoolAffinitySpecification.ResourcePoolAffinitySpecification(parameterValue=x)) = this in x
  member this.PoolAffinityRanges = let (ResourcePoolAffinitySpecification.ResourcePoolAffinitySpecification(poolAffinityRanges=x)) = this in x
  static member FromCs(src:ScriptDom.ResourcePoolAffinitySpecification) : ResourcePoolAffinitySpecification =
    ResourcePoolAffinitySpecification.ResourcePoolAffinitySpecification((src.AffinityType), (src.IsAuto), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)), (src.PoolAffinityRanges |> Seq.map (LiteralRange.FromCs) |> List.ofSeq))
and FileStreamDatabaseOption = (* IsAbstract = false , children = 0*)
  | FileStreamDatabaseOption of directoryName:Literal option * nonTransactedAccess:(ScriptDom.NonTransactedFileStreamAccess) option * optionKind:ScriptDom.DatabaseOptionKind  
  member this.ToCs() : ScriptDom.FileStreamDatabaseOption =
    match this with
    | FileStreamDatabaseOption(directoryName=aDirectoryName; nonTransactedAccess=aNonTransactedAccess; optionKind=aOptionKind) ->
      let ret = ScriptDom.FileStreamDatabaseOption()
      ret.DirectoryName <- aDirectoryName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NonTransactedAccess <- Option.toNullable aNonTransactedAccess
      ret.OptionKind <- aOptionKind
      ret (* 402 *)
//// shared props FileStreamDatabaseOption 
  member this.DirectoryName = let (FileStreamDatabaseOption.FileStreamDatabaseOption(directoryName=x)) = this in x
  member this.NonTransactedAccess = let (FileStreamDatabaseOption.FileStreamDatabaseOption(nonTransactedAccess=x)) = this in x
  member this.OptionKind = let (FileStreamDatabaseOption.FileStreamDatabaseOption(optionKind=x)) = this in x
  static member FromCs(src:ScriptDom.FileStreamDatabaseOption) : FileStreamDatabaseOption =
    FileStreamDatabaseOption.FileStreamDatabaseOption((src.DirectoryName |> Option.ofObj |> Option.map (Literal.FromCs)), (Option.ofNullable (src.NonTransactedAccess)), (src.OptionKind))
and ResultColumnDefinition = (* IsAbstract = false , children = 0*)
  | ResultColumnDefinition of columnDefinition:ColumnDefinitionBase option * nullable:NullableConstraintDefinition option  
  member this.ToCs() : ScriptDom.ResultColumnDefinition =
    match this with
    | ResultColumnDefinition(columnDefinition=aColumnDefinition; nullable=aNullable) ->
      let ret = ScriptDom.ResultColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ResultColumnDefinition 
  member this.ColumnDefinition = let (ResultColumnDefinition.ResultColumnDefinition(columnDefinition=x)) = this in x
  member this.Nullable = let (ResultColumnDefinition.ResultColumnDefinition(nullable=x)) = this in x
  static member FromCs(src:ScriptDom.ResultColumnDefinition) : ResultColumnDefinition =
    ResultColumnDefinition.ResultColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))
and IntegerLiteral = (* IsAbstract = false , children = 0*)
  | IntegerLiteral of collation:Identifier option * literalType:ScriptDom.LiteralType * value:String  
  member this.ToCs() : ScriptDom.IntegerLiteral =
    match this with
    | IntegerLiteral(collation=aCollation; literalType=aLiteralType; value=aValue) ->
      let ret = ScriptDom.IntegerLiteral()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
       // Skipping prop LiteralType - it is Readonly
      ret.Value <- aValue
      ret (* 402 *)
//// shared props IntegerLiteral 
  member this.Collation = let (IntegerLiteral.IntegerLiteral(collation=x)) = this in x
  member this.LiteralType = let (IntegerLiteral.IntegerLiteral(literalType=x)) = this in x
  member this.Value = let (IntegerLiteral.IntegerLiteral(value=x)) = this in x
  static member FromCs(src:ScriptDom.IntegerLiteral) : IntegerLiteral =
    IntegerLiteral.IntegerLiteral((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.LiteralType), (src.Value))
and SearchedWhenClause = (* IsAbstract = false , children = 0*)
  | SearchedWhenClause of thenExpression:ScalarExpression option * whenExpression:BooleanExpression option  
  member this.ToCs() : ScriptDom.SearchedWhenClause =
    match this with
    | SearchedWhenClause(thenExpression=aThenExpression; whenExpression=aWhenExpression) ->
      let ret = ScriptDom.SearchedWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SearchedWhenClause 
  member this.ThenExpression = let (SearchedWhenClause.SearchedWhenClause(thenExpression=x)) = this in x
  member this.WhenExpression = let (SearchedWhenClause.SearchedWhenClause(whenExpression=x)) = this in x
  static member FromCs(src:ScriptDom.SearchedWhenClause) : SearchedWhenClause =
    SearchedWhenClause.SearchedWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))
and SimpleWhenClause = (* IsAbstract = false , children = 0*)
  | SimpleWhenClause of thenExpression:ScalarExpression option * whenExpression:ScalarExpression option  
  member this.ToCs() : ScriptDom.SimpleWhenClause =
    match this with
    | SimpleWhenClause(thenExpression=aThenExpression; whenExpression=aWhenExpression) ->
      let ret = ScriptDom.SimpleWhenClause()
      ret.ThenExpression <- aThenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhenExpression <- aWhenExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SimpleWhenClause 
  member this.ThenExpression = let (SimpleWhenClause.SimpleWhenClause(thenExpression=x)) = this in x
  member this.WhenExpression = let (SimpleWhenClause.SimpleWhenClause(whenExpression=x)) = this in x
  static member FromCs(src:ScriptDom.SimpleWhenClause) : SimpleWhenClause =
    SimpleWhenClause.SimpleWhenClause((src.ThenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WhenExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and OverClause = (* IsAbstract = false , children = 0*)
  | OverClause of orderByClause:OrderByClause option * partitions:(ScalarExpression) list * windowFrameClause:WindowFrameClause option  
  member this.ToCs() : ScriptDom.OverClause =
    match this with
    | OverClause(orderByClause=aOrderByClause; partitions=aPartitions; windowFrameClause=aWindowFrameClause) ->
      let ret = ScriptDom.OverClause()
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aPartitions do ret.Partitions.Add (e.ToCs())
      ret.WindowFrameClause <- aWindowFrameClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props OverClause 
  member this.OrderByClause = let (OverClause.OverClause(orderByClause=x)) = this in x
  member this.Partitions = let (OverClause.OverClause(partitions=x)) = this in x
  member this.WindowFrameClause = let (OverClause.OverClause(windowFrameClause=x)) = this in x
  static member FromCs(src:ScriptDom.OverClause) : OverClause =
    OverClause.OverClause((src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)), (src.Partitions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.WindowFrameClause |> Option.ofObj |> Option.map (WindowFrameClause.FromCs)))
and WithinGroupClause = (* IsAbstract = false , children = 0*)
  | WithinGroupClause of hasGraphPath:bool * orderByClause:OrderByClause option  
  member this.ToCs() : ScriptDom.WithinGroupClause =
    match this with
    | WithinGroupClause(hasGraphPath=aHasGraphPath; orderByClause=aOrderByClause) ->
      let ret = ScriptDom.WithinGroupClause()
      ret.HasGraphPath <- aHasGraphPath
      ret.OrderByClause <- aOrderByClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props WithinGroupClause 
  member this.HasGraphPath = let (WithinGroupClause.WithinGroupClause(hasGraphPath=x)) = this in x
  member this.OrderByClause = let (WithinGroupClause.WithinGroupClause(orderByClause=x)) = this in x
  static member FromCs(src:ScriptDom.WithinGroupClause) : WithinGroupClause =
    WithinGroupClause.WithinGroupClause((src.HasGraphPath), (src.OrderByClause |> Option.ofObj |> Option.map (OrderByClause.FromCs)))
and Privilege80 = (* IsAbstract = false , children = 0*)
  | Privilege80 of columns:(Identifier) list * privilegeType80:ScriptDom.PrivilegeType80  
  member this.ToCs() : ScriptDom.Privilege80 =
    match this with
    | Privilege80(columns=aColumns; privilegeType80=aPrivilegeType80) ->
      let ret = ScriptDom.Privilege80()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.PrivilegeType80 <- aPrivilegeType80
      ret (* 402 *)
//// shared props Privilege80 
  member this.Columns = let (Privilege80.Privilege80(columns=x)) = this in x
  member this.PrivilegeType80 = let (Privilege80.Privilege80(privilegeType80=x)) = this in x
  static member FromCs(src:ScriptDom.Privilege80) : Privilege80 =
    Privilege80.Privilege80((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.PrivilegeType80))
and FunctionCall = (* IsAbstract = false , children = 0*)
  | FunctionCall of callTarget:CallTarget option * collation:Identifier option * functionName:Identifier option * overClause:OverClause option * parameters:(ScalarExpression) list * uniqueRowFilter:ScriptDom.UniqueRowFilter * withinGroupClause:WithinGroupClause option  
  member this.ToCs() : ScriptDom.FunctionCall =
    match this with
    | FunctionCall(callTarget=aCallTarget; collation=aCollation; functionName=aFunctionName; overClause=aOverClause; parameters=aParameters; uniqueRowFilter=aUniqueRowFilter; withinGroupClause=aWithinGroupClause) ->
      let ret = ScriptDom.FunctionCall()
      ret.CallTarget <- aCallTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FunctionName <- aFunctionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OverClause <- aOverClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret.UniqueRowFilter <- aUniqueRowFilter
      ret.WithinGroupClause <- aWithinGroupClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FunctionCall 
  member this.CallTarget = let (FunctionCall.FunctionCall(callTarget=x)) = this in x
  member this.Collation = let (FunctionCall.FunctionCall(collation=x)) = this in x
  member this.FunctionName = let (FunctionCall.FunctionCall(functionName=x)) = this in x
  member this.OverClause = let (FunctionCall.FunctionCall(overClause=x)) = this in x
  member this.Parameters = let (FunctionCall.FunctionCall(parameters=x)) = this in x
  member this.UniqueRowFilter = let (FunctionCall.FunctionCall(uniqueRowFilter=x)) = this in x
  member this.WithinGroupClause = let (FunctionCall.FunctionCall(withinGroupClause=x)) = this in x
  static member FromCs(src:ScriptDom.FunctionCall) : FunctionCall =
    FunctionCall.FunctionCall((src.CallTarget |> Option.ofObj |> Option.map (CallTarget.FromCs)), (src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FunctionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.OverClause |> Option.ofObj |> Option.map (OverClause.FromCs)), (src.Parameters |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.UniqueRowFilter), (src.WithinGroupClause |> Option.ofObj |> Option.map (WithinGroupClause.FromCs)))
and SecurityTargetObjectName = (* IsAbstract = false , children = 0*)
  | SecurityTargetObjectName of multiPartIdentifier:MultiPartIdentifier option  
  member this.ToCs() : ScriptDom.SecurityTargetObjectName =
    match this with
    | SecurityTargetObjectName(multiPartIdentifier=aMultiPartIdentifier) ->
      let ret = ScriptDom.SecurityTargetObjectName()
      ret.MultiPartIdentifier <- aMultiPartIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SecurityTargetObjectName 
  member this.MultiPartIdentifier = let (SecurityTargetObjectName.SecurityTargetObjectName(multiPartIdentifier=x)) = this in x
  static member FromCs(src:ScriptDom.SecurityTargetObjectName) : SecurityTargetObjectName =
    SecurityTargetObjectName.SecurityTargetObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))
and BoundingBoxParameter = (* IsAbstract = false , children = 0*)
  | BoundingBoxParameter of parameter:ScriptDom.BoundingBoxParameterType * value:ScalarExpression option  
  member this.ToCs() : ScriptDom.BoundingBoxParameter =
    match this with
    | BoundingBoxParameter(parameter=aParameter; value=aValue) ->
      let ret = ScriptDom.BoundingBoxParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props BoundingBoxParameter 
  member this.Parameter = let (BoundingBoxParameter.BoundingBoxParameter(parameter=x)) = this in x
  member this.Value = let (BoundingBoxParameter.BoundingBoxParameter(value=x)) = this in x
  static member FromCs(src:ScriptDom.BoundingBoxParameter) : BoundingBoxParameter =
    BoundingBoxParameter.BoundingBoxParameter((src.Parameter), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and GridParameter = (* IsAbstract = false , children = 0*)
  | GridParameter of parameter:ScriptDom.GridParameterType * value:ScriptDom.ImportanceParameterType  
  member this.ToCs() : ScriptDom.GridParameter =
    match this with
    | GridParameter(parameter=aParameter; value=aValue) ->
      let ret = ScriptDom.GridParameter()
      ret.Parameter <- aParameter
      ret.Value <- aValue
      ret (* 402 *)
//// shared props GridParameter 
  member this.Parameter = let (GridParameter.GridParameter(parameter=x)) = this in x
  member this.Value = let (GridParameter.GridParameter(value=x)) = this in x
  static member FromCs(src:ScriptDom.GridParameter) : GridParameter =
    GridParameter.GridParameter((src.Parameter), (src.Value))
and StatisticsPartitionRange = (* IsAbstract = false , children = 0*)
  | StatisticsPartitionRange of from:IntegerLiteral option * to_:IntegerLiteral option  
  member this.ToCs() : ScriptDom.StatisticsPartitionRange =
    match this with
    | StatisticsPartitionRange(from=aFrom; to_=aTo) ->
      let ret = ScriptDom.StatisticsPartitionRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props StatisticsPartitionRange 
  member this.From = let (StatisticsPartitionRange.StatisticsPartitionRange(from=x)) = this in x
  member this.To = let (StatisticsPartitionRange.StatisticsPartitionRange(to_=x)) = this in x
  static member FromCs(src:ScriptDom.StatisticsPartitionRange) : StatisticsPartitionRange =
    StatisticsPartitionRange.StatisticsPartitionRange((src.From |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.To |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)))
and TSqlBatch = (* IsAbstract = false , children = 0*)
  | TSqlBatch of statements:(TSqlStatement) list  
  member this.ToCs() : ScriptDom.TSqlBatch =
    match this with
    | TSqlBatch(statements=aStatements) ->
      let ret = ScriptDom.TSqlBatch()
      for e in aStatements do ret.Statements.Add (e.ToCs())
      ret (* 402 *)
//// shared props TSqlBatch 
  member this.Statements = let (TSqlBatch.TSqlBatch(statements=x)) = this in x
  static member FromCs(src:ScriptDom.TSqlBatch) : TSqlBatch =
    TSqlBatch.TSqlBatch((src.Statements |> Seq.map (TSqlStatement.FromCs) |> List.ofSeq))
and EndpointAffinity = (* IsAbstract = false , children = 0*)
  | EndpointAffinity of kind:ScriptDom.AffinityKind * value:Literal option  
  member this.ToCs() : ScriptDom.EndpointAffinity =
    match this with
    | EndpointAffinity(kind=aKind; value=aValue) ->
      let ret = ScriptDom.EndpointAffinity()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props EndpointAffinity 
  member this.Kind = let (EndpointAffinity.EndpointAffinity(kind=x)) = this in x
  member this.Value = let (EndpointAffinity.EndpointAffinity(value=x)) = this in x
  static member FromCs(src:ScriptDom.EndpointAffinity) : EndpointAffinity =
    EndpointAffinity.EndpointAffinity((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and ServiceContract = (* IsAbstract = false , children = 0*)
  | ServiceContract of action:ScriptDom.AlterAction * name:Identifier option  
  member this.ToCs() : ScriptDom.ServiceContract =
    match this with
    | ServiceContract(action=aAction; name=aName) ->
      let ret = ScriptDom.ServiceContract()
      ret.Action <- aAction
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ServiceContract 
  member this.Action = let (ServiceContract.ServiceContract(action=x)) = this in x
  member this.Name = let (ServiceContract.ServiceContract(name=x)) = this in x
  static member FromCs(src:ScriptDom.ServiceContract) : ServiceContract =
    ServiceContract.ServiceContract((src.Action), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and DatabaseConfigurationClearOption = (* IsAbstract = false , children = 0*)
  | DatabaseConfigurationClearOption of optionKind:ScriptDom.DatabaseConfigClearOptionKind * planHandle:BinaryLiteral option  
  member this.ToCs() : ScriptDom.DatabaseConfigurationClearOption =
    match this with
    | DatabaseConfigurationClearOption(optionKind=aOptionKind; planHandle=aPlanHandle) ->
      let ret = ScriptDom.DatabaseConfigurationClearOption()
      ret.OptionKind <- aOptionKind
      ret.PlanHandle <- aPlanHandle |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props DatabaseConfigurationClearOption 
  member this.OptionKind = let (DatabaseConfigurationClearOption.DatabaseConfigurationClearOption(optionKind=x)) = this in x
  member this.PlanHandle = let (DatabaseConfigurationClearOption.DatabaseConfigurationClearOption(planHandle=x)) = this in x
  static member FromCs(src:ScriptDom.DatabaseConfigurationClearOption) : DatabaseConfigurationClearOption =
    DatabaseConfigurationClearOption.DatabaseConfigurationClearOption((src.OptionKind), (src.PlanHandle |> Option.ofObj |> Option.map (BinaryLiteral.FromCs)))
and AlterDatabaseTermination = (* IsAbstract = false , children = 0*)
  | AlterDatabaseTermination of immediateRollback:bool * noWait:bool * rollbackAfter:Literal option  
  member this.ToCs() : ScriptDom.AlterDatabaseTermination =
    match this with
    | AlterDatabaseTermination(immediateRollback=aImmediateRollback; noWait=aNoWait; rollbackAfter=aRollbackAfter) ->
      let ret = ScriptDom.AlterDatabaseTermination()
      ret.ImmediateRollback <- aImmediateRollback
      ret.NoWait <- aNoWait
      ret.RollbackAfter <- aRollbackAfter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AlterDatabaseTermination 
  member this.ImmediateRollback = let (AlterDatabaseTermination.AlterDatabaseTermination(immediateRollback=x)) = this in x
  member this.NoWait = let (AlterDatabaseTermination.AlterDatabaseTermination(noWait=x)) = this in x
  member this.RollbackAfter = let (AlterDatabaseTermination.AlterDatabaseTermination(rollbackAfter=x)) = this in x
  static member FromCs(src:ScriptDom.AlterDatabaseTermination) : AlterDatabaseTermination =
    AlterDatabaseTermination.AlterDatabaseTermination((src.ImmediateRollback), (src.NoWait), (src.RollbackAfter |> Option.ofObj |> Option.map (Literal.FromCs)))
and FullTextStopListAction = (* IsAbstract = false , children = 0*)
  | FullTextStopListAction of isAdd:bool * isAll:bool * languageTerm:IdentifierOrValueExpression option * stopWord:Literal option  
  member this.ToCs() : ScriptDom.FullTextStopListAction =
    match this with
    | FullTextStopListAction(isAdd=aIsAdd; isAll=aIsAll; languageTerm=aLanguageTerm; stopWord=aStopWord) ->
      let ret = ScriptDom.FullTextStopListAction()
      ret.IsAdd <- aIsAdd
      ret.IsAll <- aIsAll
      ret.LanguageTerm <- aLanguageTerm |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StopWord <- aStopWord |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FullTextStopListAction 
  member this.IsAdd = let (FullTextStopListAction.FullTextStopListAction(isAdd=x)) = this in x
  member this.IsAll = let (FullTextStopListAction.FullTextStopListAction(isAll=x)) = this in x
  member this.LanguageTerm = let (FullTextStopListAction.FullTextStopListAction(languageTerm=x)) = this in x
  member this.StopWord = let (FullTextStopListAction.FullTextStopListAction(stopWord=x)) = this in x
  static member FromCs(src:ScriptDom.FullTextStopListAction) : FullTextStopListAction =
    FullTextStopListAction.FullTextStopListAction((src.IsAdd), (src.IsAll), (src.LanguageTerm |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.StopWord |> Option.ofObj |> Option.map (Literal.FromCs)))
and AlterServerConfigurationFailoverClusterPropertyOption = (* IsAbstract = false , children = 0*)
  | AlterServerConfigurationFailoverClusterPropertyOption of optionKind:ScriptDom.AlterServerConfigurationFailoverClusterPropertyOptionKind * optionValue:OptionValue option  
  member this.ToCs() : ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption =
    match this with
    | AlterServerConfigurationFailoverClusterPropertyOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AlterServerConfigurationFailoverClusterPropertyOption 
  member this.OptionKind = let (AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption(optionKind=x)) = this in x
  member this.OptionValue = let (AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption(optionValue=x)) = this in x
  static member FromCs(src:ScriptDom.AlterServerConfigurationFailoverClusterPropertyOption) : AlterServerConfigurationFailoverClusterPropertyOption =
    AlterServerConfigurationFailoverClusterPropertyOption.AlterServerConfigurationFailoverClusterPropertyOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))
and AlterServerConfigurationHadrClusterOption = (* IsAbstract = false , children = 0*)
  | AlterServerConfigurationHadrClusterOption of isLocal:bool * optionKind:ScriptDom.AlterServerConfigurationHadrClusterOptionKind * optionValue:OptionValue option  
  member this.ToCs() : ScriptDom.AlterServerConfigurationHadrClusterOption =
    match this with
    | AlterServerConfigurationHadrClusterOption(isLocal=aIsLocal; optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationHadrClusterOption()
      ret.IsLocal <- aIsLocal
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AlterServerConfigurationHadrClusterOption 
  member this.IsLocal = let (AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption(isLocal=x)) = this in x
  member this.OptionKind = let (AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption(optionKind=x)) = this in x
  member this.OptionValue = let (AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption(optionValue=x)) = this in x
  static member FromCs(src:ScriptDom.AlterServerConfigurationHadrClusterOption) : AlterServerConfigurationHadrClusterOption =
    AlterServerConfigurationHadrClusterOption.AlterServerConfigurationHadrClusterOption((src.IsLocal), (src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))
and AlterServerConfigurationSoftNumaOption = (* IsAbstract = false , children = 0*)
  | AlterServerConfigurationSoftNumaOption of optionKind:ScriptDom.AlterServerConfigurationSoftNumaOptionKind * optionValue:OptionValue option  
  member this.ToCs() : ScriptDom.AlterServerConfigurationSoftNumaOption =
    match this with
    | AlterServerConfigurationSoftNumaOption(optionKind=aOptionKind; optionValue=aOptionValue) ->
      let ret = ScriptDom.AlterServerConfigurationSoftNumaOption()
      ret.OptionKind <- aOptionKind
      ret.OptionValue <- aOptionValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AlterServerConfigurationSoftNumaOption 
  member this.OptionKind = let (AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption(optionKind=x)) = this in x
  member this.OptionValue = let (AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption(optionValue=x)) = this in x
  static member FromCs(src:ScriptDom.AlterServerConfigurationSoftNumaOption) : AlterServerConfigurationSoftNumaOption =
    AlterServerConfigurationSoftNumaOption.AlterServerConfigurationSoftNumaOption((src.OptionKind), (src.OptionValue |> Option.ofObj |> Option.map (OptionValue.FromCs)))
and ProcessAffinityRange = (* IsAbstract = false , children = 0*)
  | ProcessAffinityRange of from:Literal option * to_:Literal option  
  member this.ToCs() : ScriptDom.ProcessAffinityRange =
    match this with
    | ProcessAffinityRange(from=aFrom; to_=aTo) ->
      let ret = ScriptDom.ProcessAffinityRange()
      ret.From <- aFrom |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.To <- aTo |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ProcessAffinityRange 
  member this.From = let (ProcessAffinityRange.ProcessAffinityRange(from=x)) = this in x
  member this.To = let (ProcessAffinityRange.ProcessAffinityRange(to_=x)) = this in x
  static member FromCs(src:ScriptDom.ProcessAffinityRange) : ProcessAffinityRange =
    ProcessAffinityRange.ProcessAffinityRange((src.From |> Option.ofObj |> Option.map (Literal.FromCs)), (src.To |> Option.ofObj |> Option.map (Literal.FromCs)))
and AlterTableDropTableElement = (* IsAbstract = false , children = 0*)
  | AlterTableDropTableElement of dropClusteredConstraintOptions:(DropClusteredConstraintOption) list * isIfExists:bool * name:Identifier option * tableElementType:ScriptDom.TableElementType  
  member this.ToCs() : ScriptDom.AlterTableDropTableElement =
    match this with
    | AlterTableDropTableElement(dropClusteredConstraintOptions=aDropClusteredConstraintOptions; isIfExists=aIsIfExists; name=aName; tableElementType=aTableElementType) ->
      let ret = ScriptDom.AlterTableDropTableElement()
      for e in aDropClusteredConstraintOptions do ret.DropClusteredConstraintOptions.Add (e.ToCs())
      ret.IsIfExists <- aIsIfExists
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableElementType <- aTableElementType
      ret (* 402 *)
//// shared props AlterTableDropTableElement 
  member this.DropClusteredConstraintOptions = let (AlterTableDropTableElement.AlterTableDropTableElement(dropClusteredConstraintOptions=x)) = this in x
  member this.IsIfExists = let (AlterTableDropTableElement.AlterTableDropTableElement(isIfExists=x)) = this in x
  member this.Name = let (AlterTableDropTableElement.AlterTableDropTableElement(name=x)) = this in x
  member this.TableElementType = let (AlterTableDropTableElement.AlterTableDropTableElement(tableElementType=x)) = this in x
  static member FromCs(src:ScriptDom.AlterTableDropTableElement) : AlterTableDropTableElement =
    AlterTableDropTableElement.AlterTableDropTableElement((src.DropClusteredConstraintOptions |> Seq.map (DropClusteredConstraintOption.FromCs) |> List.ofSeq), (src.IsIfExists), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableElementType))
and PartitionSpecifier = (* IsAbstract = false , children = 0*)
  | PartitionSpecifier of all:bool * number:ScalarExpression option  
  member this.ToCs() : ScriptDom.PartitionSpecifier =
    match this with
    | PartitionSpecifier(all=aAll; number=aNumber) ->
      let ret = ScriptDom.PartitionSpecifier()
      ret.All <- aAll
      ret.Number <- aNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props PartitionSpecifier 
  member this.All = let (PartitionSpecifier.PartitionSpecifier(all=x)) = this in x
  member this.Number = let (PartitionSpecifier.PartitionSpecifier(number=x)) = this in x
  static member FromCs(src:ScriptDom.PartitionSpecifier) : PartitionSpecifier =
    PartitionSpecifier.PartitionSpecifier((src.All), (src.Number |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and ApplicationRoleOption = (* IsAbstract = false , children = 0*)
  | ApplicationRoleOption of optionKind:ScriptDom.ApplicationRoleOptionKind * value:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.ApplicationRoleOption =
    match this with
    | ApplicationRoleOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ApplicationRoleOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ApplicationRoleOption 
  member this.OptionKind = let (ApplicationRoleOption.ApplicationRoleOption(optionKind=x)) = this in x
  member this.Value = let (ApplicationRoleOption.ApplicationRoleOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.ApplicationRoleOption) : ApplicationRoleOption =
    ApplicationRoleOption.ApplicationRoleOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
and AddFileSpec = (* IsAbstract = false , children = 0*)
  | AddFileSpec of file:ScalarExpression option * fileName:Literal option  
  member this.ToCs() : ScriptDom.AddFileSpec =
    match this with
    | AddFileSpec(file=aFile; fileName=aFileName) ->
      let ret = ScriptDom.AddFileSpec()
      ret.File <- aFile |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileName <- aFileName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AddFileSpec 
  member this.File = let (AddFileSpec.AddFileSpec(file=x)) = this in x
  member this.FileName = let (AddFileSpec.AddFileSpec(fileName=x)) = this in x
  static member FromCs(src:ScriptDom.AddFileSpec) : AddFileSpec =
    AddFileSpec.AddFileSpec((src.File |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.FileName |> Option.ofObj |> Option.map (Literal.FromCs)))
and AuditSpecificationPart = (* IsAbstract = false , children = 0*)
  | AuditSpecificationPart of details:AuditSpecificationDetail option * isDrop:bool  
  member this.ToCs() : ScriptDom.AuditSpecificationPart =
    match this with
    | AuditSpecificationPart(details=aDetails; isDrop=aIsDrop) ->
      let ret = ScriptDom.AuditSpecificationPart()
      ret.Details <- aDetails |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsDrop <- aIsDrop
      ret (* 402 *)
//// shared props AuditSpecificationPart 
  member this.Details = let (AuditSpecificationPart.AuditSpecificationPart(details=x)) = this in x
  member this.IsDrop = let (AuditSpecificationPart.AuditSpecificationPart(isDrop=x)) = this in x
  static member FromCs(src:ScriptDom.AuditSpecificationPart) : AuditSpecificationPart =
    AuditSpecificationPart.AuditSpecificationPart((src.Details |> Option.ofObj |> Option.map (AuditSpecificationDetail.FromCs)), (src.IsDrop))
and AvailabilityReplica = (* IsAbstract = false , children = 0*)
  | AvailabilityReplica of options:(AvailabilityReplicaOption) list * serverName:StringLiteral option  
  member this.ToCs() : ScriptDom.AvailabilityReplica =
    match this with
    | AvailabilityReplica(options=aOptions; serverName=aServerName) ->
      let ret = ScriptDom.AvailabilityReplica()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.ServerName <- aServerName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AvailabilityReplica 
  member this.Options = let (AvailabilityReplica.AvailabilityReplica(options=x)) = this in x
  member this.ServerName = let (AvailabilityReplica.AvailabilityReplica(serverName=x)) = this in x
  static member FromCs(src:ScriptDom.AvailabilityReplica) : AvailabilityReplica =
    AvailabilityReplica.AvailabilityReplica((src.Options |> Seq.map (AvailabilityReplicaOption.FromCs) |> List.ofSeq), (src.ServerName |> Option.ofObj |> Option.map (StringLiteral.FromCs)))
and MirrorToClause = (* IsAbstract = false , children = 0*)
  | MirrorToClause of devices:(DeviceInfo) list  
  member this.ToCs() : ScriptDom.MirrorToClause =
    match this with
    | MirrorToClause(devices=aDevices) ->
      let ret = ScriptDom.MirrorToClause()
      for e in aDevices do ret.Devices.Add (e.ToCs())
      ret (* 402 *)
//// shared props MirrorToClause 
  member this.Devices = let (MirrorToClause.MirrorToClause(devices=x)) = this in x
  static member FromCs(src:ScriptDom.MirrorToClause) : MirrorToClause =
    MirrorToClause.MirrorToClause((src.Devices |> Seq.map (fun src -> DeviceInfo.DeviceInfo((src.DeviceType), (src.LogicalDevice |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)), (src.PhysicalDevice |> Option.ofObj |> Option.map (ValueExpression.FromCs)))) |> List.ofSeq))
and BackupRestoreFileInfo = (* IsAbstract = false , children = 0*)
  | BackupRestoreFileInfo of itemKind:ScriptDom.BackupRestoreItemKind * items:(ValueExpression) list  
  member this.ToCs() : ScriptDom.BackupRestoreFileInfo =
    match this with
    | BackupRestoreFileInfo(itemKind=aItemKind; items=aItems) ->
      let ret = ScriptDom.BackupRestoreFileInfo()
      ret.ItemKind <- aItemKind
      for e in aItems do ret.Items.Add (e.ToCs())
      ret (* 402 *)
//// shared props BackupRestoreFileInfo 
  member this.ItemKind = let (BackupRestoreFileInfo.BackupRestoreFileInfo(itemKind=x)) = this in x
  member this.Items = let (BackupRestoreFileInfo.BackupRestoreFileInfo(items=x)) = this in x
  static member FromCs(src:ScriptDom.BackupRestoreFileInfo) : BackupRestoreFileInfo =
    BackupRestoreFileInfo.BackupRestoreFileInfo((src.ItemKind), (src.Items |> Seq.map (ValueExpression.FromCs) |> List.ofSeq))
and BrokerPriorityParameter = (* IsAbstract = false , children = 0*)
  | BrokerPriorityParameter of isDefaultOrAny:ScriptDom.BrokerPriorityParameterSpecialType * parameterType:ScriptDom.BrokerPriorityParameterType * parameterValue:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.BrokerPriorityParameter =
    match this with
    | BrokerPriorityParameter(isDefaultOrAny=aIsDefaultOrAny; parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.BrokerPriorityParameter()
      ret.IsDefaultOrAny <- aIsDefaultOrAny
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props BrokerPriorityParameter 
  member this.IsDefaultOrAny = let (BrokerPriorityParameter.BrokerPriorityParameter(isDefaultOrAny=x)) = this in x
  member this.ParameterType = let (BrokerPriorityParameter.BrokerPriorityParameter(parameterType=x)) = this in x
  member this.ParameterValue = let (BrokerPriorityParameter.BrokerPriorityParameter(parameterValue=x)) = this in x
  static member FromCs(src:ScriptDom.BrokerPriorityParameter) : BrokerPriorityParameter =
    BrokerPriorityParameter.BrokerPriorityParameter((src.IsDefaultOrAny), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
and InsertBulkColumnDefinition = (* IsAbstract = false , children = 0*)
  | InsertBulkColumnDefinition of column:ColumnDefinitionBase option * nullNotNull:ScriptDom.NullNotNull  
  member this.ToCs() : ScriptDom.InsertBulkColumnDefinition =
    match this with
    | InsertBulkColumnDefinition(column=aColumn; nullNotNull=aNullNotNull) ->
      let ret = ScriptDom.InsertBulkColumnDefinition()
      ret.Column <- aColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullNotNull <- aNullNotNull
      ret (* 402 *)
//// shared props InsertBulkColumnDefinition 
  member this.Column = let (InsertBulkColumnDefinition.InsertBulkColumnDefinition(column=x)) = this in x
  member this.NullNotNull = let (InsertBulkColumnDefinition.InsertBulkColumnDefinition(nullNotNull=x)) = this in x
  static member FromCs(src:ScriptDom.InsertBulkColumnDefinition) : InsertBulkColumnDefinition =
    InsertBulkColumnDefinition.InsertBulkColumnDefinition((src.Column |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullNotNull))
and CertificateOption = (* IsAbstract = false , children = 0*)
  | CertificateOption of kind:ScriptDom.CertificateOptionKinds * value:Literal option  
  member this.ToCs() : ScriptDom.CertificateOption =
    match this with
    | CertificateOption(kind=aKind; value=aValue) ->
      let ret = ScriptDom.CertificateOption()
      ret.Kind <- aKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props CertificateOption 
  member this.Kind = let (CertificateOption.CertificateOption(kind=x)) = this in x
  member this.Value = let (CertificateOption.CertificateOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.CertificateOption) : CertificateOption =
    CertificateOption.CertificateOption((src.Kind), (src.Value |> Option.ofObj |> Option.map (Literal.FromCs)))
and ColumnEncryptionKeyValue = (* IsAbstract = false , children = 0*)
  | ColumnEncryptionKeyValue of parameters:(ColumnEncryptionKeyValueParameter) list  
  member this.ToCs() : ScriptDom.ColumnEncryptionKeyValue =
    match this with
    | ColumnEncryptionKeyValue(parameters=aParameters) ->
      let ret = ScriptDom.ColumnEncryptionKeyValue()
      for e in aParameters do ret.Parameters.Add (e.ToCs())
      ret (* 402 *)
//// shared props ColumnEncryptionKeyValue 
  member this.Parameters = let (ColumnEncryptionKeyValue.ColumnEncryptionKeyValue(parameters=x)) = this in x
  static member FromCs(src:ScriptDom.ColumnEncryptionKeyValue) : ColumnEncryptionKeyValue =
    ColumnEncryptionKeyValue.ColumnEncryptionKeyValue((src.Parameters |> Seq.map (ColumnEncryptionKeyValueParameter.FromCs) |> List.ofSeq))
and AssemblyName = (* IsAbstract = false , children = 0*)
  | AssemblyName of className:Identifier option * name:Identifier option  
  member this.ToCs() : ScriptDom.AssemblyName =
    match this with
    | AssemblyName(className=aClassName; name=aName) ->
      let ret = ScriptDom.AssemblyName()
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props AssemblyName 
  member this.ClassName = let (AssemblyName.AssemblyName(className=x)) = this in x
  member this.Name = let (AssemblyName.AssemblyName(name=x)) = this in x
  static member FromCs(src:ScriptDom.AssemblyName) : AssemblyName =
    AssemblyName.AssemblyName((src.ClassName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and ProcedureParameter = (* IsAbstract = false , children = 0*)
  | ProcedureParameter of dataType:DataTypeReference option * isVarying:bool * modifier:ScriptDom.ParameterModifier * nullable:NullableConstraintDefinition option * value:ScalarExpression option * variableName:Identifier option  
  member this.ToCs() : ScriptDom.ProcedureParameter =
    match this with
    | ProcedureParameter(dataType=aDataType; isVarying=aIsVarying; modifier=aModifier; nullable=aNullable; value=aValue; variableName=aVariableName) ->
      let ret = ScriptDom.ProcedureParameter()
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsVarying <- aIsVarying
      ret.Modifier <- aModifier
      ret.Nullable <- aNullable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.VariableName <- aVariableName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ProcedureParameter 
  member this.DataType = let (ProcedureParameter.ProcedureParameter(dataType=x)) = this in x
  member this.IsVarying = let (ProcedureParameter.ProcedureParameter(isVarying=x)) = this in x
  member this.Modifier = let (ProcedureParameter.ProcedureParameter(modifier=x)) = this in x
  member this.Nullable = let (ProcedureParameter.ProcedureParameter(nullable=x)) = this in x
  member this.Value = let (ProcedureParameter.ProcedureParameter(value=x)) = this in x
  member this.VariableName = let (ProcedureParameter.ProcedureParameter(variableName=x)) = this in x
  static member FromCs(src:ScriptDom.ProcedureParameter) : ProcedureParameter =
    ProcedureParameter.ProcedureParameter((src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.IsVarying), (src.Modifier), (src.Nullable |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.VariableName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and ContractMessage = (* IsAbstract = false , children = 0*)
  | ContractMessage of name:Identifier option * sentBy:ScriptDom.MessageSender  
  member this.ToCs() : ScriptDom.ContractMessage =
    match this with
    | ContractMessage(name=aName; sentBy=aSentBy) ->
      let ret = ScriptDom.ContractMessage()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SentBy <- aSentBy
      ret (* 402 *)
//// shared props ContractMessage 
  member this.Name = let (ContractMessage.ContractMessage(name=x)) = this in x
  member this.SentBy = let (ContractMessage.ContractMessage(sentBy=x)) = this in x
  static member FromCs(src:ScriptDom.ContractMessage) : ContractMessage =
    ContractMessage.ContractMessage((src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.SentBy))
and ContainmentDatabaseOption = (* IsAbstract = false , children = 0*)
  | ContainmentDatabaseOption of optionKind:ScriptDom.DatabaseOptionKind * value:ScriptDom.ContainmentOptionKind  
  member this.ToCs() : ScriptDom.ContainmentDatabaseOption =
    match this with
    | ContainmentDatabaseOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.ContainmentDatabaseOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue
      ret (* 402 *)
//// shared props ContainmentDatabaseOption 
  member this.OptionKind = let (ContainmentDatabaseOption.ContainmentDatabaseOption(optionKind=x)) = this in x
  member this.Value = let (ContainmentDatabaseOption.ContainmentDatabaseOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.ContainmentDatabaseOption) : ContainmentDatabaseOption =
    ContainmentDatabaseOption.ContainmentDatabaseOption((src.OptionKind), (src.Value))
and FileGroupDefinition = (* IsAbstract = false , children = 0*)
  | FileGroupDefinition of containsFileStream:bool * containsMemoryOptimizedData:bool * fileDeclarations:(FileDeclaration) list * isDefault:bool * name:Identifier option  
  member this.ToCs() : ScriptDom.FileGroupDefinition =
    match this with
    | FileGroupDefinition(containsFileStream=aContainsFileStream; containsMemoryOptimizedData=aContainsMemoryOptimizedData; fileDeclarations=aFileDeclarations; isDefault=aIsDefault; name=aName) ->
      let ret = ScriptDom.FileGroupDefinition()
      ret.ContainsFileStream <- aContainsFileStream
      ret.ContainsMemoryOptimizedData <- aContainsMemoryOptimizedData
      for e in aFileDeclarations do ret.FileDeclarations.Add (e.ToCs())
      ret.IsDefault <- aIsDefault
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FileGroupDefinition 
  member this.ContainsFileStream = let (FileGroupDefinition.FileGroupDefinition(containsFileStream=x)) = this in x
  member this.ContainsMemoryOptimizedData = let (FileGroupDefinition.FileGroupDefinition(containsMemoryOptimizedData=x)) = this in x
  member this.FileDeclarations = let (FileGroupDefinition.FileGroupDefinition(fileDeclarations=x)) = this in x
  member this.IsDefault = let (FileGroupDefinition.FileGroupDefinition(isDefault=x)) = this in x
  member this.Name = let (FileGroupDefinition.FileGroupDefinition(name=x)) = this in x
  static member FromCs(src:ScriptDom.FileGroupDefinition) : FileGroupDefinition =
    FileGroupDefinition.FileGroupDefinition((src.ContainsFileStream), (src.ContainsMemoryOptimizedData), (src.FileDeclarations |> Seq.map (fun src -> FileDeclaration.FileDeclaration((src.IsPrimary), (src.Options |> Seq.map (FileDeclarationOption.FromCs) |> List.ofSeq))) |> List.ofSeq), (src.IsDefault), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)))
and EventNotificationObjectScope = (* IsAbstract = false , children = 0*)
  | EventNotificationObjectScope of queueName:SchemaObjectName option * target:ScriptDom.EventNotificationTarget  
  member this.ToCs() : ScriptDom.EventNotificationObjectScope =
    match this with
    | EventNotificationObjectScope(queueName=aQueueName; target=aTarget) ->
      let ret = ScriptDom.EventNotificationObjectScope()
      ret.QueueName <- aQueueName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget
      ret (* 402 *)
//// shared props EventNotificationObjectScope 
  member this.QueueName = let (EventNotificationObjectScope.EventNotificationObjectScope(queueName=x)) = this in x
  member this.Target = let (EventNotificationObjectScope.EventNotificationObjectScope(target=x)) = this in x
  static member FromCs(src:ScriptDom.EventNotificationObjectScope) : EventNotificationObjectScope =
    EventNotificationObjectScope.EventNotificationObjectScope((src.QueueName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.Target))
and FullTextCatalogAndFileGroup = (* IsAbstract = false , children = 0*)
  | FullTextCatalogAndFileGroup of catalogName:Identifier option * fileGroupIsFirst:bool * fileGroupName:Identifier option  
  member this.ToCs() : ScriptDom.FullTextCatalogAndFileGroup =
    match this with
    | FullTextCatalogAndFileGroup(catalogName=aCatalogName; fileGroupIsFirst=aFileGroupIsFirst; fileGroupName=aFileGroupName) ->
      let ret = ScriptDom.FullTextCatalogAndFileGroup()
      ret.CatalogName <- aCatalogName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.FileGroupIsFirst <- aFileGroupIsFirst
      ret.FileGroupName <- aFileGroupName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FullTextCatalogAndFileGroup 
  member this.CatalogName = let (FullTextCatalogAndFileGroup.FullTextCatalogAndFileGroup(catalogName=x)) = this in x
  member this.FileGroupIsFirst = let (FullTextCatalogAndFileGroup.FullTextCatalogAndFileGroup(fileGroupIsFirst=x)) = this in x
  member this.FileGroupName = let (FullTextCatalogAndFileGroup.FullTextCatalogAndFileGroup(fileGroupName=x)) = this in x
  static member FromCs(src:ScriptDom.FullTextCatalogAndFileGroup) : FullTextCatalogAndFileGroup =
    FullTextCatalogAndFileGroup.FullTextCatalogAndFileGroup((src.CatalogName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.FileGroupIsFirst), (src.FileGroupName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and PartitionParameterType = (* IsAbstract = false , children = 0*)
  | PartitionParameterType of collation:Identifier option * dataType:DataTypeReference option  
  member this.ToCs() : ScriptDom.PartitionParameterType =
    match this with
    | PartitionParameterType(collation=aCollation; dataType=aDataType) ->
      let ret = ScriptDom.PartitionParameterType()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props PartitionParameterType 
  member this.Collation = let (PartitionParameterType.PartitionParameterType(collation=x)) = this in x
  member this.DataType = let (PartitionParameterType.PartitionParameterType(dataType=x)) = this in x
  static member FromCs(src:ScriptDom.PartitionParameterType) : PartitionParameterType =
    PartitionParameterType.PartitionParameterType((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)))
and FederationScheme = (* IsAbstract = false , children = 0*)
  | FederationScheme of columnName:Identifier option * distributionName:Identifier option  
  member this.ToCs() : ScriptDom.FederationScheme =
    match this with
    | FederationScheme(columnName=aColumnName; distributionName=aDistributionName) ->
      let ret = ScriptDom.FederationScheme()
      ret.ColumnName <- aColumnName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DistributionName <- aDistributionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FederationScheme 
  member this.ColumnName = let (FederationScheme.FederationScheme(columnName=x)) = this in x
  member this.DistributionName = let (FederationScheme.FederationScheme(distributionName=x)) = this in x
  static member FromCs(src:ScriptDom.FederationScheme) : FederationScheme =
    FederationScheme.FederationScheme((src.ColumnName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.DistributionName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and CursorId = (* IsAbstract = false , children = 0*)
  | CursorId of isGlobal:bool * name:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.CursorId =
    match this with
    | CursorId(isGlobal=aIsGlobal; name=aName) ->
      let ret = ScriptDom.CursorId()
      ret.IsGlobal <- aIsGlobal
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props CursorId 
  member this.IsGlobal = let (CursorId.CursorId(isGlobal=x)) = this in x
  member this.Name = let (CursorId.CursorId(name=x)) = this in x
  static member FromCs(src:ScriptDom.CursorId) : CursorId =
    CursorId.CursorId((src.IsGlobal), (src.Name |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
and FetchType = (* IsAbstract = false , children = 0*)
  | FetchType of orientation:ScriptDom.FetchOrientation * rowOffset:ScalarExpression option  
  member this.ToCs() : ScriptDom.FetchType =
    match this with
    | FetchType(orientation=aOrientation; rowOffset=aRowOffset) ->
      let ret = ScriptDom.FetchType()
      ret.Orientation <- aOrientation
      ret.RowOffset <- aRowOffset |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props FetchType 
  member this.Orientation = let (FetchType.FetchType(orientation=x)) = this in x
  member this.RowOffset = let (FetchType.FetchType(rowOffset=x)) = this in x
  static member FromCs(src:ScriptDom.FetchType) : FetchType =
    FetchType.FetchType((src.Orientation), (src.RowOffset |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and DbccNamedLiteral = (* IsAbstract = false , children = 0*)
  | DbccNamedLiteral of name:String * value:ScalarExpression option  
  member this.ToCs() : ScriptDom.DbccNamedLiteral =
    match this with
    | DbccNamedLiteral(name=aName; value=aValue) ->
      let ret = ScriptDom.DbccNamedLiteral()
      ret.Name <- aName
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props DbccNamedLiteral 
  member this.Name = let (DbccNamedLiteral.DbccNamedLiteral(name=x)) = this in x
  member this.Value = let (DbccNamedLiteral.DbccNamedLiteral(value=x)) = this in x
  static member FromCs(src:ScriptDom.DbccNamedLiteral) : DbccNamedLiteral =
    DbccNamedLiteral.DbccNamedLiteral((src.Name), (src.Value |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))
and DbccOption = (* IsAbstract = false , children = 0*)
  | DbccOption of optionKind:ScriptDom.DbccOptionKind  
  member this.ToCs() : ScriptDom.DbccOption =
    match this with
    | DbccOption(optionKind=aOptionKind) ->
      let ret = ScriptDom.DbccOption()
      ret.OptionKind <- aOptionKind
      ret (* 402 *)
//// shared props DbccOption 
  member this.OptionKind = let (DbccOption.DbccOption(optionKind=x)) = this in x
  static member FromCs(src:ScriptDom.DbccOption) : DbccOption =
    DbccOption.DbccOption((src.OptionKind))
and CursorDefinition = (* IsAbstract = false , children = 0*)
  | CursorDefinition of options:(CursorOption) list * select:SelectStatement option  
  member this.ToCs() : ScriptDom.CursorDefinition =
    match this with
    | CursorDefinition(options=aOptions; select=aSelect) ->
      let ret = ScriptDom.CursorDefinition()
      for e in aOptions do ret.Options.Add (e.ToCs())
      ret.Select <- aSelect |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props CursorDefinition 
  member this.Options = let (CursorDefinition.CursorDefinition(options=x)) = this in x
  member this.Select = let (CursorDefinition.CursorDefinition(select=x)) = this in x
  static member FromCs(src:ScriptDom.CursorDefinition) : CursorDefinition =
    CursorDefinition.CursorDefinition((src.Options |> Seq.map (fun src -> CursorOption.CursorOption((src.OptionKind))) |> List.ofSeq), (src.Select |> Option.ofObj |> Option.map (SelectStatement.FromCs)))
and DiskStatementOption = (* IsAbstract = false , children = 0*)
  | DiskStatementOption of optionKind:ScriptDom.DiskStatementOptionKind * value:IdentifierOrValueExpression option  
  member this.ToCs() : ScriptDom.DiskStatementOption =
    match this with
    | DiskStatementOption(optionKind=aOptionKind; value=aValue) ->
      let ret = ScriptDom.DiskStatementOption()
      ret.OptionKind <- aOptionKind
      ret.Value <- aValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props DiskStatementOption 
  member this.OptionKind = let (DiskStatementOption.DiskStatementOption(optionKind=x)) = this in x
  member this.Value = let (DiskStatementOption.DiskStatementOption(value=x)) = this in x
  static member FromCs(src:ScriptDom.DiskStatementOption) : DiskStatementOption =
    DiskStatementOption.DiskStatementOption((src.OptionKind), (src.Value |> Option.ofObj |> Option.map (IdentifierOrValueExpression.FromCs)))
and TriggerObject = (* IsAbstract = false , children = 0*)
  | TriggerObject of name:SchemaObjectName option * triggerScope:ScriptDom.TriggerScope  
  member this.ToCs() : ScriptDom.TriggerObject =
    match this with
    | TriggerObject(name=aName; triggerScope=aTriggerScope) ->
      let ret = ScriptDom.TriggerObject()
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerScope <- aTriggerScope
      ret (* 402 *)
//// shared props TriggerObject 
  member this.Name = let (TriggerObject.TriggerObject(name=x)) = this in x
  member this.TriggerScope = let (TriggerObject.TriggerObject(triggerScope=x)) = this in x
  static member FromCs(src:ScriptDom.TriggerObject) : TriggerObject =
    TriggerObject.TriggerObject((src.Name |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.TriggerScope))
and EventDeclaration = (* IsAbstract = false , children = 0*)
  | EventDeclaration of eventDeclarationActionParameters:(EventSessionObjectName) list * eventDeclarationPredicateParameter:BooleanExpression option * eventDeclarationSetParameters:(EventDeclarationSetParameter) list * objectName:EventSessionObjectName option  
  member this.ToCs() : ScriptDom.EventDeclaration =
    match this with
    | EventDeclaration(eventDeclarationActionParameters=aEventDeclarationActionParameters; eventDeclarationPredicateParameter=aEventDeclarationPredicateParameter; eventDeclarationSetParameters=aEventDeclarationSetParameters; objectName=aObjectName) ->
      let ret = ScriptDom.EventDeclaration()
      for e in aEventDeclarationActionParameters do ret.EventDeclarationActionParameters.Add (e.ToCs())
      ret.EventDeclarationPredicateParameter <- aEventDeclarationPredicateParameter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aEventDeclarationSetParameters do ret.EventDeclarationSetParameters.Add (e.ToCs())
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props EventDeclaration 
  member this.EventDeclarationActionParameters = let (EventDeclaration.EventDeclaration(eventDeclarationActionParameters=x)) = this in x
  member this.EventDeclarationPredicateParameter = let (EventDeclaration.EventDeclaration(eventDeclarationPredicateParameter=x)) = this in x
  member this.EventDeclarationSetParameters = let (EventDeclaration.EventDeclaration(eventDeclarationSetParameters=x)) = this in x
  member this.ObjectName = let (EventDeclaration.EventDeclaration(objectName=x)) = this in x
  static member FromCs(src:ScriptDom.EventDeclaration) : EventDeclaration =
    EventDeclaration.EventDeclaration((src.EventDeclarationActionParameters |> Seq.map (fun src -> EventSessionObjectName.EventSessionObjectName((src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.EventDeclarationPredicateParameter |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.EventDeclarationSetParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq), (src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)))
and TargetDeclaration = (* IsAbstract = false , children = 0*)
  | TargetDeclaration of objectName:EventSessionObjectName option * targetDeclarationParameters:(EventDeclarationSetParameter) list  
  member this.ToCs() : ScriptDom.TargetDeclaration =
    match this with
    | TargetDeclaration(objectName=aObjectName; targetDeclarationParameters=aTargetDeclarationParameters) ->
      let ret = ScriptDom.TargetDeclaration()
      ret.ObjectName <- aObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aTargetDeclarationParameters do ret.TargetDeclarationParameters.Add (e.ToCs())
      ret (* 402 *)
//// shared props TargetDeclaration 
  member this.ObjectName = let (TargetDeclaration.TargetDeclaration(objectName=x)) = this in x
  member this.TargetDeclarationParameters = let (TargetDeclaration.TargetDeclaration(targetDeclarationParameters=x)) = this in x
  static member FromCs(src:ScriptDom.TargetDeclaration) : TargetDeclaration =
    TargetDeclaration.TargetDeclaration((src.ObjectName |> Option.ofObj |> Option.map (EventSessionObjectName.FromCs)), (src.TargetDeclarationParameters |> Seq.map (fun src -> EventDeclarationSetParameter.EventDeclarationSetParameter((src.EventField |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.EventValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
and ExternalResourcePoolParameter = (* IsAbstract = false , children = 0*)
  | ExternalResourcePoolParameter of affinitySpecification:ExternalResourcePoolAffinitySpecification option * parameterType:ScriptDom.ExternalResourcePoolParameterType * parameterValue:Literal option  
  member this.ToCs() : ScriptDom.ExternalResourcePoolParameter =
    match this with
    | ExternalResourcePoolParameter(affinitySpecification=aAffinitySpecification; parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.ExternalResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ExternalResourcePoolParameter 
  member this.AffinitySpecification = let (ExternalResourcePoolParameter.ExternalResourcePoolParameter(affinitySpecification=x)) = this in x
  member this.ParameterType = let (ExternalResourcePoolParameter.ExternalResourcePoolParameter(parameterType=x)) = this in x
  member this.ParameterValue = let (ExternalResourcePoolParameter.ExternalResourcePoolParameter(parameterValue=x)) = this in x
  static member FromCs(src:ScriptDom.ExternalResourcePoolParameter) : ExternalResourcePoolParameter =
    ExternalResourcePoolParameter.ExternalResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ExternalResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))
and ExternalTableColumnDefinition = (* IsAbstract = false , children = 0*)
  | ExternalTableColumnDefinition of columnDefinition:ColumnDefinitionBase option * nullableConstraint:NullableConstraintDefinition option  
  member this.ToCs() : ScriptDom.ExternalTableColumnDefinition =
    match this with
    | ExternalTableColumnDefinition(columnDefinition=aColumnDefinition; nullableConstraint=aNullableConstraint) ->
      let ret = ScriptDom.ExternalTableColumnDefinition()
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.NullableConstraint <- aNullableConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ExternalTableColumnDefinition 
  member this.ColumnDefinition = let (ExternalTableColumnDefinition.ExternalTableColumnDefinition(columnDefinition=x)) = this in x
  member this.NullableConstraint = let (ExternalTableColumnDefinition.ExternalTableColumnDefinition(nullableConstraint=x)) = this in x
  static member FromCs(src:ScriptDom.ExternalTableColumnDefinition) : ExternalTableColumnDefinition =
    ExternalTableColumnDefinition.ExternalTableColumnDefinition((src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.NullableConstraint |> Option.ofObj |> Option.map (NullableConstraintDefinition.FromCs)))
and SelectiveXmlIndexPromotedPath = (* IsAbstract = false , children = 0*)
  | SelectiveXmlIndexPromotedPath of isSingleton:bool * maxLength:IntegerLiteral option * name:Identifier option * path:Literal option * sQLDataType:DataTypeReference option * xQueryDataType:Literal option  
  member this.ToCs() : ScriptDom.SelectiveXmlIndexPromotedPath =
    match this with
    | SelectiveXmlIndexPromotedPath(isSingleton=aIsSingleton; maxLength=aMaxLength; name=aName; path=aPath; sQLDataType=aSQLDataType; xQueryDataType=aXQueryDataType) ->
      let ret = ScriptDom.SelectiveXmlIndexPromotedPath()
      ret.IsSingleton <- aIsSingleton
      ret.MaxLength <- aMaxLength |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Name <- aName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Path <- aPath |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SQLDataType <- aSQLDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.XQueryDataType <- aXQueryDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SelectiveXmlIndexPromotedPath 
  member this.IsSingleton = let (SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath(isSingleton=x)) = this in x
  member this.MaxLength = let (SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath(maxLength=x)) = this in x
  member this.Name = let (SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath(name=x)) = this in x
  member this.Path = let (SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath(path=x)) = this in x
  member this.SQLDataType = let (SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath(sQLDataType=x)) = this in x
  member this.XQueryDataType = let (SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath(xQueryDataType=x)) = this in x
  static member FromCs(src:ScriptDom.SelectiveXmlIndexPromotedPath) : SelectiveXmlIndexPromotedPath =
    SelectiveXmlIndexPromotedPath.SelectiveXmlIndexPromotedPath((src.IsSingleton), (src.MaxLength |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.Name |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Path |> Option.ofObj |> Option.map (Literal.FromCs)), (src.SQLDataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.XQueryDataType |> Option.ofObj |> Option.map (Literal.FromCs)))
and XmlNamespaces = (* IsAbstract = false , children = 0*)
  | XmlNamespaces of xmlNamespacesElements:(XmlNamespacesElement) list  
  member this.ToCs() : ScriptDom.XmlNamespaces =
    match this with
    | XmlNamespaces(xmlNamespacesElements=aXmlNamespacesElements) ->
      let ret = ScriptDom.XmlNamespaces()
      for e in aXmlNamespacesElements do ret.XmlNamespacesElements.Add (e.ToCs())
      ret (* 402 *)
//// shared props XmlNamespaces 
  member this.XmlNamespacesElements = let (XmlNamespaces.XmlNamespaces(xmlNamespacesElements=x)) = this in x
  static member FromCs(src:ScriptDom.XmlNamespaces) : XmlNamespaces =
    XmlNamespaces.XmlNamespaces((src.XmlNamespacesElements |> Seq.map (XmlNamespacesElement.FromCs) |> List.ofSeq))
and MethodSpecifier = (* IsAbstract = false , children = 0*)
  | MethodSpecifier of assemblyName:Identifier option * className:Identifier option * methodName:Identifier option  
  member this.ToCs() : ScriptDom.MethodSpecifier =
    match this with
    | MethodSpecifier(assemblyName=aAssemblyName; className=aClassName; methodName=aMethodName) ->
      let ret = ScriptDom.MethodSpecifier()
      ret.AssemblyName <- aAssemblyName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ClassName <- aClassName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.MethodName <- aMethodName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props MethodSpecifier 
  member this.AssemblyName = let (MethodSpecifier.MethodSpecifier(assemblyName=x)) = this in x
  member this.ClassName = let (MethodSpecifier.MethodSpecifier(className=x)) = this in x
  member this.MethodName = let (MethodSpecifier.MethodSpecifier(methodName=x)) = this in x
  static member FromCs(src:ScriptDom.MethodSpecifier) : MethodSpecifier =
    MethodSpecifier.MethodSpecifier((src.AssemblyName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ClassName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.MethodName |> Option.ofObj |> Option.map (Identifier.FromCs)))
and OrderBulkInsertOption = (* IsAbstract = false , children = 0*)
  | OrderBulkInsertOption of columns:(ColumnWithSortOrder) list * isUnique:bool * optionKind:ScriptDom.BulkInsertOptionKind  
  member this.ToCs() : ScriptDom.OrderBulkInsertOption =
    match this with
    | OrderBulkInsertOption(columns=aColumns; isUnique=aIsUnique; optionKind=aOptionKind) ->
      let ret = ScriptDom.OrderBulkInsertOption()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.IsUnique <- aIsUnique
      ret.OptionKind <- aOptionKind
      ret (* 402 *)
//// shared props OrderBulkInsertOption 
  member this.Columns = let (OrderBulkInsertOption.OrderBulkInsertOption(columns=x)) = this in x
  member this.IsUnique = let (OrderBulkInsertOption.OrderBulkInsertOption(isUnique=x)) = this in x
  member this.OptionKind = let (OrderBulkInsertOption.OrderBulkInsertOption(optionKind=x)) = this in x
  static member FromCs(src:ScriptDom.OrderBulkInsertOption) : OrderBulkInsertOption =
    OrderBulkInsertOption.OrderBulkInsertOption((src.Columns |> Seq.map (fun src -> ColumnWithSortOrder.ColumnWithSortOrder((src.Column |> Option.ofObj |> Option.map (ColumnReferenceExpression.FromCs)), (src.SortOrder))) |> List.ofSeq), (src.IsUnique), (src.OptionKind))
and ResourcePoolParameter = (* IsAbstract = false , children = 0*)
  | ResourcePoolParameter of affinitySpecification:ResourcePoolAffinitySpecification option * parameterType:ScriptDom.ResourcePoolParameterType * parameterValue:Literal option  
  member this.ToCs() : ScriptDom.ResourcePoolParameter =
    match this with
    | ResourcePoolParameter(affinitySpecification=aAffinitySpecification; parameterType=aParameterType; parameterValue=aParameterValue) ->
      let ret = ScriptDom.ResourcePoolParameter()
      ret.AffinitySpecification <- aAffinitySpecification |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ParameterType <- aParameterType
      ret.ParameterValue <- aParameterValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ResourcePoolParameter 
  member this.AffinitySpecification = let (ResourcePoolParameter.ResourcePoolParameter(affinitySpecification=x)) = this in x
  member this.ParameterType = let (ResourcePoolParameter.ResourcePoolParameter(parameterType=x)) = this in x
  member this.ParameterValue = let (ResourcePoolParameter.ResourcePoolParameter(parameterValue=x)) = this in x
  static member FromCs(src:ScriptDom.ResourcePoolParameter) : ResourcePoolParameter =
    ResourcePoolParameter.ResourcePoolParameter((src.AffinitySpecification |> Option.ofObj |> Option.map (ResourcePoolAffinitySpecification.FromCs)), (src.ParameterType), (src.ParameterValue |> Option.ofObj |> Option.map (Literal.FromCs)))
and RouteOption = (* IsAbstract = false , children = 0*)
  | RouteOption of literal:Literal option * optionKind:ScriptDom.RouteOptionKind  
  member this.ToCs() : ScriptDom.RouteOption =
    match this with
    | RouteOption(literal=aLiteral; optionKind=aOptionKind) ->
      let ret = ScriptDom.RouteOption()
      ret.Literal <- aLiteral |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OptionKind <- aOptionKind
      ret (* 402 *)
//// shared props RouteOption 
  member this.Literal = let (RouteOption.RouteOption(literal=x)) = this in x
  member this.OptionKind = let (RouteOption.RouteOption(optionKind=x)) = this in x
  static member FromCs(src:ScriptDom.RouteOption) : RouteOption =
    RouteOption.RouteOption((src.Literal |> Option.ofObj |> Option.map (Literal.FromCs)), (src.OptionKind))
and SecurityPolicyOption = (* IsAbstract = false , children = 0*)
  | SecurityPolicyOption of optionKind:ScriptDom.SecurityPolicyOptionKind * optionState:ScriptDom.OptionState  
  member this.ToCs() : ScriptDom.SecurityPolicyOption =
    match this with
    | SecurityPolicyOption(optionKind=aOptionKind; optionState=aOptionState) ->
      let ret = ScriptDom.SecurityPolicyOption()
      ret.OptionKind <- aOptionKind
      ret.OptionState <- aOptionState
      ret (* 402 *)
//// shared props SecurityPolicyOption 
  member this.OptionKind = let (SecurityPolicyOption.SecurityPolicyOption(optionKind=x)) = this in x
  member this.OptionState = let (SecurityPolicyOption.SecurityPolicyOption(optionState=x)) = this in x
  static member FromCs(src:ScriptDom.SecurityPolicyOption) : SecurityPolicyOption =
    SecurityPolicyOption.SecurityPolicyOption((src.OptionKind), (src.OptionState))
and SecurityPredicateAction = (* IsAbstract = false , children = 0*)
  | SecurityPredicateAction of actionType:ScriptDom.SecurityPredicateActionType * functionCall:FunctionCall option * securityPredicateOperation:ScriptDom.SecurityPredicateOperation * securityPredicateType:ScriptDom.SecurityPredicateType * targetObjectName:SchemaObjectName option  
  member this.ToCs() : ScriptDom.SecurityPredicateAction =
    match this with
    | SecurityPredicateAction(actionType=aActionType; functionCall=aFunctionCall; securityPredicateOperation=aSecurityPredicateOperation; securityPredicateType=aSecurityPredicateType; targetObjectName=aTargetObjectName) ->
      let ret = ScriptDom.SecurityPredicateAction()
      ret.ActionType <- aActionType
      ret.FunctionCall <- aFunctionCall |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SecurityPredicateOperation <- aSecurityPredicateOperation
      ret.SecurityPredicateType <- aSecurityPredicateType
      ret.TargetObjectName <- aTargetObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SecurityPredicateAction 
  member this.ActionType = let (SecurityPredicateAction.SecurityPredicateAction(actionType=x)) = this in x
  member this.FunctionCall = let (SecurityPredicateAction.SecurityPredicateAction(functionCall=x)) = this in x
  member this.SecurityPredicateOperation = let (SecurityPredicateAction.SecurityPredicateAction(securityPredicateOperation=x)) = this in x
  member this.SecurityPredicateType = let (SecurityPredicateAction.SecurityPredicateAction(securityPredicateType=x)) = this in x
  member this.TargetObjectName = let (SecurityPredicateAction.SecurityPredicateAction(targetObjectName=x)) = this in x
  static member FromCs(src:ScriptDom.SecurityPredicateAction) : SecurityPredicateAction =
    SecurityPredicateAction.SecurityPredicateAction((src.ActionType), (src.FunctionCall |> Option.ofObj |> Option.map (FunctionCall.FromCs)), (src.SecurityPredicateOperation), (src.SecurityPredicateType), (src.TargetObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)))
and Permission = (* IsAbstract = false , children = 0*)
  | Permission of columns:(Identifier) list * identifiers:(Identifier) list  
  member this.ToCs() : ScriptDom.Permission =
    match this with
    | Permission(columns=aColumns; identifiers=aIdentifiers) ->
      let ret = ScriptDom.Permission()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      for e in aIdentifiers do ret.Identifiers.Add (e.ToCs())
      ret (* 402 *)
//// shared props Permission 
  member this.Columns = let (Permission.Permission(columns=x)) = this in x
  member this.Identifiers = let (Permission.Permission(identifiers=x)) = this in x
  static member FromCs(src:ScriptDom.Permission) : Permission =
    Permission.Permission((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.Identifiers |> Seq.map (Identifier.FromCs) |> List.ofSeq))
and SecurityUserClause80 = (* IsAbstract = false , children = 0*)
  | SecurityUserClause80 of userType80:ScriptDom.UserType80 * users:(Identifier) list  
  member this.ToCs() : ScriptDom.SecurityUserClause80 =
    match this with
    | SecurityUserClause80(userType80=aUserType80; users=aUsers) ->
      let ret = ScriptDom.SecurityUserClause80()
      ret.UserType80 <- aUserType80
      for e in aUsers do ret.Users.Add (e.ToCs())
      ret (* 402 *)
//// shared props SecurityUserClause80 
  member this.UserType80 = let (SecurityUserClause80.SecurityUserClause80(userType80=x)) = this in x
  member this.Users = let (SecurityUserClause80.SecurityUserClause80(users=x)) = this in x
  static member FromCs(src:ScriptDom.SecurityUserClause80) : SecurityUserClause80 =
    SecurityUserClause80.SecurityUserClause80((src.UserType80), (src.Users |> Seq.map (Identifier.FromCs) |> List.ofSeq))
and AuditTarget = (* IsAbstract = false , children = 0*)
  | AuditTarget of targetKind:ScriptDom.AuditTargetKind * targetOptions:(AuditTargetOption) list  
  member this.ToCs() : ScriptDom.AuditTarget =
    match this with
    | AuditTarget(targetKind=aTargetKind; targetOptions=aTargetOptions) ->
      let ret = ScriptDom.AuditTarget()
      ret.TargetKind <- aTargetKind
      for e in aTargetOptions do ret.TargetOptions.Add (e.ToCs())
      ret (* 402 *)
//// shared props AuditTarget 
  member this.TargetKind = let (AuditTarget.AuditTarget(targetKind=x)) = this in x
  member this.TargetOptions = let (AuditTarget.AuditTarget(targetOptions=x)) = this in x
  static member FromCs(src:ScriptDom.AuditTarget) : AuditTarget =
    AuditTarget.AuditTarget((src.TargetKind), (src.TargetOptions |> Seq.map (AuditTargetOption.FromCs) |> List.ofSeq))
and WithCtesAndXmlNamespaces = (* IsAbstract = false , children = 0*)
  | WithCtesAndXmlNamespaces of changeTrackingContext:ValueExpression option * commonTableExpressions:(CommonTableExpression) list * xmlNamespaces:XmlNamespaces option  
  member this.ToCs() : ScriptDom.WithCtesAndXmlNamespaces =
    match this with
    | WithCtesAndXmlNamespaces(changeTrackingContext=aChangeTrackingContext; commonTableExpressions=aCommonTableExpressions; xmlNamespaces=aXmlNamespaces) ->
      let ret = ScriptDom.WithCtesAndXmlNamespaces()
      ret.ChangeTrackingContext <- aChangeTrackingContext |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aCommonTableExpressions do ret.CommonTableExpressions.Add (e.ToCs())
      ret.XmlNamespaces <- aXmlNamespaces |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props WithCtesAndXmlNamespaces 
  member this.ChangeTrackingContext = let (WithCtesAndXmlNamespaces.WithCtesAndXmlNamespaces(changeTrackingContext=x)) = this in x
  member this.CommonTableExpressions = let (WithCtesAndXmlNamespaces.WithCtesAndXmlNamespaces(commonTableExpressions=x)) = this in x
  member this.XmlNamespaces = let (WithCtesAndXmlNamespaces.WithCtesAndXmlNamespaces(xmlNamespaces=x)) = this in x
  static member FromCs(src:ScriptDom.WithCtesAndXmlNamespaces) : WithCtesAndXmlNamespaces =
    WithCtesAndXmlNamespaces.WithCtesAndXmlNamespaces((src.ChangeTrackingContext |> Option.ofObj |> Option.map (ValueExpression.FromCs)), (src.CommonTableExpressions |> Seq.map (fun src -> CommonTableExpression.CommonTableExpression((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))) |> List.ofSeq), (src.XmlNamespaces |> Option.ofObj |> Option.map (XmlNamespaces.FromCs)))
and DeleteSpecification = (* IsAbstract = false , children = 0*)
  | DeleteSpecification of fromClause:FromClause option * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * target:TableReference option * topRowFilter:TopRowFilter option * whereClause:WhereClause option  
  member this.ToCs() : ScriptDom.DeleteSpecification =
    match this with
    | DeleteSpecification(fromClause=aFromClause; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; target=aTarget; topRowFilter=aTopRowFilter; whereClause=aWhereClause) ->
      let ret = ScriptDom.DeleteSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props DeleteSpecification 
  member this.FromClause = let (DeleteSpecification.DeleteSpecification(fromClause=x)) = this in x
  member this.OutputClause = let (DeleteSpecification.DeleteSpecification(outputClause=x)) = this in x
  member this.OutputIntoClause = let (DeleteSpecification.DeleteSpecification(outputIntoClause=x)) = this in x
  member this.Target = let (DeleteSpecification.DeleteSpecification(target=x)) = this in x
  member this.TopRowFilter = let (DeleteSpecification.DeleteSpecification(topRowFilter=x)) = this in x
  member this.WhereClause = let (DeleteSpecification.DeleteSpecification(whereClause=x)) = this in x
  static member FromCs(src:ScriptDom.DeleteSpecification) : DeleteSpecification =
    DeleteSpecification.DeleteSpecification((src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))
and InsertSpecification = (* IsAbstract = false , children = 0*)
  | InsertSpecification of columns:(ColumnReferenceExpression) list * insertOption:ScriptDom.InsertOption * insertSource:InsertSource option * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * target:TableReference option * topRowFilter:TopRowFilter option  
  member this.ToCs() : ScriptDom.InsertSpecification =
    match this with
    | InsertSpecification(columns=aColumns; insertOption=aInsertOption; insertSource=aInsertSource; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; target=aTarget; topRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.InsertSpecification()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.InsertOption <- aInsertOption
      ret.InsertSource <- aInsertSource |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props InsertSpecification 
  member this.Columns = let (InsertSpecification.InsertSpecification(columns=x)) = this in x
  member this.InsertOption = let (InsertSpecification.InsertSpecification(insertOption=x)) = this in x
  member this.InsertSource = let (InsertSpecification.InsertSpecification(insertSource=x)) = this in x
  member this.OutputClause = let (InsertSpecification.InsertSpecification(outputClause=x)) = this in x
  member this.OutputIntoClause = let (InsertSpecification.InsertSpecification(outputIntoClause=x)) = this in x
  member this.Target = let (InsertSpecification.InsertSpecification(target=x)) = this in x
  member this.TopRowFilter = let (InsertSpecification.InsertSpecification(topRowFilter=x)) = this in x
  static member FromCs(src:ScriptDom.InsertSpecification) : InsertSpecification =
    InsertSpecification.InsertSpecification((src.Columns |> Seq.map (fun src -> ColumnReferenceExpression.ColumnReferenceExpression((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnType), (src.MultiPartIdentifier |> Option.ofObj |> Option.map (MultiPartIdentifier.FromCs)))) |> List.ofSeq), (src.InsertOption), (src.InsertSource |> Option.ofObj |> Option.map (InsertSource.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)))
and MergeSpecification = (* IsAbstract = false , children = 0*)
  | MergeSpecification of actionClauses:(MergeActionClause) list * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * searchCondition:BooleanExpression option * tableAlias:Identifier option * tableReference:TableReference option * target:TableReference option * topRowFilter:TopRowFilter option  
  member this.ToCs() : ScriptDom.MergeSpecification =
    match this with
    | MergeSpecification(actionClauses=aActionClauses; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; searchCondition=aSearchCondition; tableAlias=aTableAlias; tableReference=aTableReference; target=aTarget; topRowFilter=aTopRowFilter) ->
      let ret = ScriptDom.MergeSpecification()
      for e in aActionClauses do ret.ActionClauses.Add (e.ToCs())
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SearchCondition <- aSearchCondition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableAlias <- aTableAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TableReference <- aTableReference |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props MergeSpecification 
  member this.ActionClauses = let (MergeSpecification.MergeSpecification(actionClauses=x)) = this in x
  member this.OutputClause = let (MergeSpecification.MergeSpecification(outputClause=x)) = this in x
  member this.OutputIntoClause = let (MergeSpecification.MergeSpecification(outputIntoClause=x)) = this in x
  member this.SearchCondition = let (MergeSpecification.MergeSpecification(searchCondition=x)) = this in x
  member this.TableAlias = let (MergeSpecification.MergeSpecification(tableAlias=x)) = this in x
  member this.TableReference = let (MergeSpecification.MergeSpecification(tableReference=x)) = this in x
  member this.Target = let (MergeSpecification.MergeSpecification(target=x)) = this in x
  member this.TopRowFilter = let (MergeSpecification.MergeSpecification(topRowFilter=x)) = this in x
  static member FromCs(src:ScriptDom.MergeSpecification) : MergeSpecification =
    MergeSpecification.MergeSpecification((src.ActionClauses |> Seq.map (fun src -> MergeActionClause.MergeActionClause((src.Action |> Option.ofObj |> Option.map (MergeAction.FromCs)), (src.Condition), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)))) |> List.ofSeq), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.SearchCondition |> Option.ofObj |> Option.map (BooleanExpression.FromCs)), (src.TableAlias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.TableReference |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)))
and UpdateSpecification = (* IsAbstract = false , children = 0*)
  | UpdateSpecification of fromClause:FromClause option * outputClause:OutputClause option * outputIntoClause:OutputIntoClause option * setClauses:(SetClause) list * target:TableReference option * topRowFilter:TopRowFilter option * whereClause:WhereClause option  
  member this.ToCs() : ScriptDom.UpdateSpecification =
    match this with
    | UpdateSpecification(fromClause=aFromClause; outputClause=aOutputClause; outputIntoClause=aOutputIntoClause; setClauses=aSetClauses; target=aTarget; topRowFilter=aTopRowFilter; whereClause=aWhereClause) ->
      let ret = ScriptDom.UpdateSpecification()
      ret.FromClause <- aFromClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputClause <- aOutputClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.OutputIntoClause <- aOutputIntoClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aSetClauses do ret.SetClauses.Add (e.ToCs())
      ret.Target <- aTarget |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TopRowFilter <- aTopRowFilter |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WhereClause <- aWhereClause |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props UpdateSpecification 
  member this.FromClause = let (UpdateSpecification.UpdateSpecification(fromClause=x)) = this in x
  member this.OutputClause = let (UpdateSpecification.UpdateSpecification(outputClause=x)) = this in x
  member this.OutputIntoClause = let (UpdateSpecification.UpdateSpecification(outputIntoClause=x)) = this in x
  member this.SetClauses = let (UpdateSpecification.UpdateSpecification(setClauses=x)) = this in x
  member this.Target = let (UpdateSpecification.UpdateSpecification(target=x)) = this in x
  member this.TopRowFilter = let (UpdateSpecification.UpdateSpecification(topRowFilter=x)) = this in x
  member this.WhereClause = let (UpdateSpecification.UpdateSpecification(whereClause=x)) = this in x
  static member FromCs(src:ScriptDom.UpdateSpecification) : UpdateSpecification =
    UpdateSpecification.UpdateSpecification((src.FromClause |> Option.ofObj |> Option.map (FromClause.FromCs)), (src.OutputClause |> Option.ofObj |> Option.map (OutputClause.FromCs)), (src.OutputIntoClause |> Option.ofObj |> Option.map (OutputIntoClause.FromCs)), (src.SetClauses |> Seq.map (SetClause.FromCs) |> List.ofSeq), (src.Target |> Option.ofObj |> Option.map (TableReference.FromCs)), (src.TopRowFilter |> Option.ofObj |> Option.map (TopRowFilter.FromCs)), (src.WhereClause |> Option.ofObj |> Option.map (WhereClause.FromCs)))
and ComputeClause = (* IsAbstract = false , children = 0*)
  | ComputeClause of byExpressions:(ScalarExpression) list * computeFunctions:(ComputeFunction) list  
  member this.ToCs() : ScriptDom.ComputeClause =
    match this with
    | ComputeClause(byExpressions=aByExpressions; computeFunctions=aComputeFunctions) ->
      let ret = ScriptDom.ComputeClause()
      for e in aByExpressions do ret.ByExpressions.Add (e.ToCs())
      for e in aComputeFunctions do ret.ComputeFunctions.Add (e.ToCs())
      ret (* 402 *)
//// shared props ComputeClause 
  member this.ByExpressions = let (ComputeClause.ComputeClause(byExpressions=x)) = this in x
  member this.ComputeFunctions = let (ComputeClause.ComputeClause(computeFunctions=x)) = this in x
  static member FromCs(src:ScriptDom.ComputeClause) : ComputeClause =
    ComputeClause.ComputeClause((src.ByExpressions |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.ComputeFunctions |> Seq.map (fun src -> ComputeFunction.ComputeFunction((src.ComputeFunctionType), (src.Expression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
and TriggerAction = (* IsAbstract = false , children = 0*)
  | TriggerAction of eventTypeGroup:EventTypeGroupContainer option * triggerActionType:ScriptDom.TriggerActionType  
  member this.ToCs() : ScriptDom.TriggerAction =
    match this with
    | TriggerAction(eventTypeGroup=aEventTypeGroup; triggerActionType=aTriggerActionType) ->
      let ret = ScriptDom.TriggerAction()
      ret.EventTypeGroup <- aEventTypeGroup |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TriggerActionType <- aTriggerActionType
      ret (* 402 *)
//// shared props TriggerAction 
  member this.EventTypeGroup = let (TriggerAction.TriggerAction(eventTypeGroup=x)) = this in x
  member this.TriggerActionType = let (TriggerAction.TriggerAction(triggerActionType=x)) = this in x
  static member FromCs(src:ScriptDom.TriggerAction) : TriggerAction =
    TriggerAction.TriggerAction((src.EventTypeGroup |> Option.ofObj |> Option.map (EventTypeGroupContainer.FromCs)), (src.TriggerActionType))
and UserLoginOption = (* IsAbstract = false , children = 0*)
  | UserLoginOption of identifier:Identifier option * userLoginOptionType:ScriptDom.UserLoginOptionType  
  member this.ToCs() : ScriptDom.UserLoginOption =
    match this with
    | UserLoginOption(identifier=aIdentifier; userLoginOptionType=aUserLoginOptionType) ->
      let ret = ScriptDom.UserLoginOption()
      ret.Identifier <- aIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.UserLoginOptionType <- aUserLoginOptionType
      ret (* 402 *)
//// shared props UserLoginOption 
  member this.Identifier = let (UserLoginOption.UserLoginOption(identifier=x)) = this in x
  member this.UserLoginOptionType = let (UserLoginOption.UserLoginOption(userLoginOptionType=x)) = this in x
  static member FromCs(src:ScriptDom.UserLoginOption) : UserLoginOption =
    UserLoginOption.UserLoginOption((src.Identifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.UserLoginOptionType))
and ViewOption = (* IsAbstract = false , children = 0*)
  | ViewOption of optionKind:ScriptDom.ViewOptionKind  
  member this.ToCs() : ScriptDom.ViewOption =
    match this with
    | ViewOption(optionKind=aOptionKind) ->
      let ret = ScriptDom.ViewOption()
      ret.OptionKind <- aOptionKind
      ret (* 402 *)
//// shared props ViewOption 
  member this.OptionKind = let (ViewOption.ViewOption(optionKind=x)) = this in x
  static member FromCs(src:ScriptDom.ViewOption) : ViewOption =
    ViewOption.ViewOption((src.OptionKind))
and VariableTableReference = (* IsAbstract = false , children = 0*)
  | VariableTableReference of alias:Identifier option * variable:VariableReference option  
  member this.ToCs() : ScriptDom.VariableTableReference =
    match this with
    | VariableTableReference(alias=aAlias; variable=aVariable) ->
      let ret = ScriptDom.VariableTableReference()
      ret.Alias <- aAlias |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Variable <- aVariable |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props VariableTableReference 
  member this.Alias = let (VariableTableReference.VariableTableReference(alias=x)) = this in x
  member this.Variable = let (VariableTableReference.VariableTableReference(variable=x)) = this in x
  static member FromCs(src:ScriptDom.VariableTableReference) : VariableTableReference =
    VariableTableReference.VariableTableReference((src.Alias |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.Variable |> Option.ofObj |> Option.map (VariableReference.FromCs)))
and ColumnDefinition = (* IsAbstract = false , children = 0*)
  | ColumnDefinition of collation:Identifier option * columnIdentifier:Identifier option * computedColumnExpression:ScalarExpression option * constraints:(ConstraintDefinition) list * dataType:DataTypeReference option * defaultConstraint:DefaultConstraintDefinition option * encryption:ColumnEncryptionDefinition option * generatedAlways:(ScriptDom.GeneratedAlwaysType) option * identityOptions:IdentityOptions option * index:IndexDefinition option * isHidden:bool * isMasked:bool * isPersisted:bool * isRowGuidCol:bool * maskingFunction:StringLiteral option * storageOptions:ColumnStorageOptions option  
  member this.ToCs() : ScriptDom.ColumnDefinition =
    match this with
    | ColumnDefinition(collation=aCollation; columnIdentifier=aColumnIdentifier; computedColumnExpression=aComputedColumnExpression; constraints=aConstraints; dataType=aDataType; defaultConstraint=aDefaultConstraint; encryption=aEncryption; generatedAlways=aGeneratedAlways; identityOptions=aIdentityOptions; index=aIndex; isHidden=aIsHidden; isMasked=aIsMasked; isPersisted=aIsPersisted; isRowGuidCol=aIsRowGuidCol; maskingFunction=aMaskingFunction; storageOptions=aStorageOptions) ->
      let ret = ScriptDom.ColumnDefinition()
      ret.Collation <- aCollation |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ColumnIdentifier <- aColumnIdentifier |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ComputedColumnExpression <- aComputedColumnExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      for e in aConstraints do ret.Constraints.Add (e.ToCs())
      ret.DataType <- aDataType |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.DefaultConstraint <- aDefaultConstraint |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Encryption <- aEncryption |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.GeneratedAlways <- Option.toNullable aGeneratedAlways
      ret.IdentityOptions <- aIdentityOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Index <- aIndex |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsHidden <- aIsHidden
      ret.IsMasked <- aIsMasked
      ret.IsPersisted <- aIsPersisted
      ret.IsRowGuidCol <- aIsRowGuidCol
      ret.MaskingFunction <- aMaskingFunction |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StorageOptions <- aStorageOptions |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props ColumnDefinition 
  member this.Collation = let (ColumnDefinition.ColumnDefinition(collation=x)) = this in x
  member this.ColumnIdentifier = let (ColumnDefinition.ColumnDefinition(columnIdentifier=x)) = this in x
  member this.ComputedColumnExpression = let (ColumnDefinition.ColumnDefinition(computedColumnExpression=x)) = this in x
  member this.Constraints = let (ColumnDefinition.ColumnDefinition(constraints=x)) = this in x
  member this.DataType = let (ColumnDefinition.ColumnDefinition(dataType=x)) = this in x
  member this.DefaultConstraint = let (ColumnDefinition.ColumnDefinition(defaultConstraint=x)) = this in x
  member this.Encryption = let (ColumnDefinition.ColumnDefinition(encryption=x)) = this in x
  member this.GeneratedAlways = let (ColumnDefinition.ColumnDefinition(generatedAlways=x)) = this in x
  member this.IdentityOptions = let (ColumnDefinition.ColumnDefinition(identityOptions=x)) = this in x
  member this.Index = let (ColumnDefinition.ColumnDefinition(index=x)) = this in x
  member this.IsHidden = let (ColumnDefinition.ColumnDefinition(isHidden=x)) = this in x
  member this.IsMasked = let (ColumnDefinition.ColumnDefinition(isMasked=x)) = this in x
  member this.IsPersisted = let (ColumnDefinition.ColumnDefinition(isPersisted=x)) = this in x
  member this.IsRowGuidCol = let (ColumnDefinition.ColumnDefinition(isRowGuidCol=x)) = this in x
  member this.MaskingFunction = let (ColumnDefinition.ColumnDefinition(maskingFunction=x)) = this in x
  member this.StorageOptions = let (ColumnDefinition.ColumnDefinition(storageOptions=x)) = this in x
  static member FromCs(src:ScriptDom.ColumnDefinition) : ColumnDefinition =
    ColumnDefinition.ColumnDefinition((src.Collation |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ColumnIdentifier |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.ComputedColumnExpression |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.Constraints |> Seq.map (ConstraintDefinition.FromCs) |> List.ofSeq), (src.DataType |> Option.ofObj |> Option.map (DataTypeReference.FromCs)), (src.DefaultConstraint |> Option.ofObj |> Option.map (DefaultConstraintDefinition.FromCs)), (src.Encryption |> Option.ofObj |> Option.map (ColumnEncryptionDefinition.FromCs)), (Option.ofNullable (src.GeneratedAlways)), (src.IdentityOptions |> Option.ofObj |> Option.map (IdentityOptions.FromCs)), (src.Index |> Option.ofObj |> Option.map (IndexDefinition.FromCs)), (src.IsHidden), (src.IsMasked), (src.IsPersisted), (src.IsRowGuidCol), (src.MaskingFunction |> Option.ofObj |> Option.map (StringLiteral.FromCs)), (src.StorageOptions |> Option.ofObj |> Option.map (ColumnStorageOptions.FromCs)))
and SystemTimePeriodDefinition = (* IsAbstract = false , children = 0*)
  | SystemTimePeriodDefinition of endTimeColumn:Identifier option * startTimeColumn:Identifier option  
  member this.ToCs() : ScriptDom.SystemTimePeriodDefinition =
    match this with
    | SystemTimePeriodDefinition(endTimeColumn=aEndTimeColumn; startTimeColumn=aStartTimeColumn) ->
      let ret = ScriptDom.SystemTimePeriodDefinition()
      ret.EndTimeColumn <- aEndTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTimeColumn <- aStartTimeColumn |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SystemTimePeriodDefinition 
  member this.EndTimeColumn = let (SystemTimePeriodDefinition.SystemTimePeriodDefinition(endTimeColumn=x)) = this in x
  member this.StartTimeColumn = let (SystemTimePeriodDefinition.SystemTimePeriodDefinition(startTimeColumn=x)) = this in x
  static member FromCs(src:ScriptDom.SystemTimePeriodDefinition) : SystemTimePeriodDefinition =
    SystemTimePeriodDefinition.SystemTimePeriodDefinition((src.EndTimeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.StartTimeColumn |> Option.ofObj |> Option.map (Identifier.FromCs)))
and RetentionPeriodDefinition = (* IsAbstract = false , children = 0*)
  | RetentionPeriodDefinition of duration:IntegerLiteral option * isInfinity:bool * units:ScriptDom.TemporalRetentionPeriodUnit  
  member this.ToCs() : ScriptDom.RetentionPeriodDefinition =
    match this with
    | RetentionPeriodDefinition(duration=aDuration; isInfinity=aIsInfinity; units=aUnits) ->
      let ret = ScriptDom.RetentionPeriodDefinition()
      ret.Duration <- aDuration |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.IsInfinity <- aIsInfinity
      ret.Units <- aUnits
      ret (* 402 *)
//// shared props RetentionPeriodDefinition 
  member this.Duration = let (RetentionPeriodDefinition.RetentionPeriodDefinition(duration=x)) = this in x
  member this.IsInfinity = let (RetentionPeriodDefinition.RetentionPeriodDefinition(isInfinity=x)) = this in x
  member this.Units = let (RetentionPeriodDefinition.RetentionPeriodDefinition(units=x)) = this in x
  static member FromCs(src:ScriptDom.RetentionPeriodDefinition) : RetentionPeriodDefinition =
    RetentionPeriodDefinition.RetentionPeriodDefinition((src.Duration |> Option.ofObj |> Option.map (IntegerLiteral.FromCs)), (src.IsInfinity), (src.Units))
and DataCompressionOption = (* IsAbstract = false , children = 0*)
  | DataCompressionOption of compressionLevel:ScriptDom.DataCompressionLevel * optionKind:ScriptDom.IndexOptionKind * partitionRanges:(CompressionPartitionRange) list  
  member this.ToCs() : ScriptDom.DataCompressionOption =
    match this with
    | DataCompressionOption(compressionLevel=aCompressionLevel; optionKind=aOptionKind; partitionRanges=aPartitionRanges) ->
      let ret = ScriptDom.DataCompressionOption()
      ret.CompressionLevel <- aCompressionLevel
      ret.OptionKind <- aOptionKind
      for e in aPartitionRanges do ret.PartitionRanges.Add (e.ToCs())
      ret (* 402 *)
//// shared props DataCompressionOption 
  member this.CompressionLevel = let (DataCompressionOption.DataCompressionOption(compressionLevel=x)) = this in x
  member this.OptionKind = let (DataCompressionOption.DataCompressionOption(optionKind=x)) = this in x
  member this.PartitionRanges = let (DataCompressionOption.DataCompressionOption(partitionRanges=x)) = this in x
  static member FromCs(src:ScriptDom.DataCompressionOption) : DataCompressionOption =
    DataCompressionOption.DataCompressionOption((src.CompressionLevel), (src.OptionKind), (src.PartitionRanges |> Seq.map (fun src -> CompressionPartitionRange.CompressionPartitionRange((src.From |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.To |> Option.ofObj |> Option.map (ScalarExpression.FromCs)))) |> List.ofSeq))
and TablePartitionOptionSpecifications = (* IsAbstract = false , children = 0*)
  | TablePartitionOptionSpecifications of boundaryValues:(ScalarExpression) list * range:ScriptDom.PartitionTableOptionRange  
  member this.ToCs() : ScriptDom.TablePartitionOptionSpecifications =
    match this with
    | TablePartitionOptionSpecifications(boundaryValues=aBoundaryValues; range=aRange) ->
      let ret = ScriptDom.TablePartitionOptionSpecifications()
      for e in aBoundaryValues do ret.BoundaryValues.Add (e.ToCs())
      ret.Range <- aRange
      ret (* 402 *)
//// shared props TablePartitionOptionSpecifications 
  member this.BoundaryValues = let (TablePartitionOptionSpecifications.TablePartitionOptionSpecifications(boundaryValues=x)) = this in x
  member this.Range = let (TablePartitionOptionSpecifications.TablePartitionOptionSpecifications(range=x)) = this in x
  static member FromCs(src:ScriptDom.TablePartitionOptionSpecifications) : TablePartitionOptionSpecifications =
    TablePartitionOptionSpecifications.TablePartitionOptionSpecifications((src.BoundaryValues |> Seq.map (ScalarExpression.FromCs) |> List.ofSeq), (src.Range))
and SchemaObjectNameOrValueExpression = (* IsAbstract = false , children = 0*)
  | SchemaObjectNameOrValueExpression of schemaObjectName:SchemaObjectName option * valueExpression:ValueExpression option  
  member this.ToCs() : ScriptDom.SchemaObjectNameOrValueExpression =
    match this with
    | SchemaObjectNameOrValueExpression(schemaObjectName=aSchemaObjectName; valueExpression=aValueExpression) ->
      let ret = ScriptDom.SchemaObjectNameOrValueExpression()
      ret.SchemaObjectName <- aSchemaObjectName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.ValueExpression <- aValueExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SchemaObjectNameOrValueExpression 
  member this.SchemaObjectName = let (SchemaObjectNameOrValueExpression.SchemaObjectNameOrValueExpression(schemaObjectName=x)) = this in x
  member this.ValueExpression = let (SchemaObjectNameOrValueExpression.SchemaObjectNameOrValueExpression(valueExpression=x)) = this in x
  static member FromCs(src:ScriptDom.SchemaObjectNameOrValueExpression) : SchemaObjectNameOrValueExpression =
    SchemaObjectNameOrValueExpression.SchemaObjectNameOrValueExpression((src.SchemaObjectName |> Option.ofObj |> Option.map (SchemaObjectName.FromCs)), (src.ValueExpression |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
and TableSampleClause = (* IsAbstract = false , children = 0*)
  | TableSampleClause of repeatSeed:ScalarExpression option * sampleNumber:ScalarExpression option * system:bool * tableSampleClauseOption:ScriptDom.TableSampleClauseOption  
  member this.ToCs() : ScriptDom.TableSampleClause =
    match this with
    | TableSampleClause(repeatSeed=aRepeatSeed; sampleNumber=aSampleNumber; system=aSystem; tableSampleClauseOption=aTableSampleClauseOption) ->
      let ret = ScriptDom.TableSampleClause()
      ret.RepeatSeed <- aRepeatSeed |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.SampleNumber <- aSampleNumber |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.System <- aSystem
      ret.TableSampleClauseOption <- aTableSampleClauseOption
      ret (* 402 *)
//// shared props TableSampleClause 
  member this.RepeatSeed = let (TableSampleClause.TableSampleClause(repeatSeed=x)) = this in x
  member this.SampleNumber = let (TableSampleClause.TableSampleClause(sampleNumber=x)) = this in x
  member this.System = let (TableSampleClause.TableSampleClause(system=x)) = this in x
  member this.TableSampleClauseOption = let (TableSampleClause.TableSampleClause(tableSampleClauseOption=x)) = this in x
  static member FromCs(src:ScriptDom.TableSampleClause) : TableSampleClause =
    TableSampleClause.TableSampleClause((src.RepeatSeed |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.SampleNumber |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.System), (src.TableSampleClauseOption))
and TemporalClause = (* IsAbstract = false , children = 0*)
  | TemporalClause of endTime:ScalarExpression option * startTime:ScalarExpression option * temporalClauseType:ScriptDom.TemporalClauseType  
  member this.ToCs() : ScriptDom.TemporalClause =
    match this with
    | TemporalClause(endTime=aEndTime; startTime=aStartTime; temporalClauseType=aTemporalClauseType) ->
      let ret = ScriptDom.TemporalClause()
      ret.EndTime <- aEndTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.StartTime <- aStartTime |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.TemporalClauseType <- aTemporalClauseType
      ret (* 402 *)
//// shared props TemporalClause 
  member this.EndTime = let (TemporalClause.TemporalClause(endTime=x)) = this in x
  member this.StartTime = let (TemporalClause.TemporalClause(startTime=x)) = this in x
  member this.TemporalClauseType = let (TemporalClause.TemporalClause(temporalClauseType=x)) = this in x
  static member FromCs(src:ScriptDom.TemporalClause) : TemporalClause =
    TemporalClause.TemporalClause((src.EndTime |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.StartTime |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.TemporalClauseType))
and SchemaDeclarationItemOpenjson = (* IsAbstract = false , children = 0*)
  | SchemaDeclarationItemOpenjson of asJson:bool * columnDefinition:ColumnDefinitionBase option * mapping:ValueExpression option  
  member this.ToCs() : ScriptDom.SchemaDeclarationItemOpenjson =
    match this with
    | SchemaDeclarationItemOpenjson(asJson=aAsJson; columnDefinition=aColumnDefinition; mapping=aMapping) ->
      let ret = ScriptDom.SchemaDeclarationItemOpenjson()
      ret.AsJson <- aAsJson
      ret.ColumnDefinition <- aColumnDefinition |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.Mapping <- aMapping |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props SchemaDeclarationItemOpenjson 
  member this.AsJson = let (SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson(asJson=x)) = this in x
  member this.ColumnDefinition = let (SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson(columnDefinition=x)) = this in x
  member this.Mapping = let (SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson(mapping=x)) = this in x
  static member FromCs(src:ScriptDom.SchemaDeclarationItemOpenjson) : SchemaDeclarationItemOpenjson =
    SchemaDeclarationItemOpenjson.SchemaDeclarationItemOpenjson((src.AsJson), (src.ColumnDefinition |> Option.ofObj |> Option.map (ColumnDefinitionBase.FromCs)), (src.Mapping |> Option.ofObj |> Option.map (ValueExpression.FromCs)))
and WindowDelimiter = (* IsAbstract = false , children = 0*)
  | WindowDelimiter of offsetValue:ScalarExpression option * windowDelimiterType:ScriptDom.WindowDelimiterType  
  member this.ToCs() : ScriptDom.WindowDelimiter =
    match this with
    | WindowDelimiter(offsetValue=aOffsetValue; windowDelimiterType=aWindowDelimiterType) ->
      let ret = ScriptDom.WindowDelimiter()
      ret.OffsetValue <- aOffsetValue |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.WindowDelimiterType <- aWindowDelimiterType
      ret (* 402 *)
//// shared props WindowDelimiter 
  member this.OffsetValue = let (WindowDelimiter.WindowDelimiter(offsetValue=x)) = this in x
  member this.WindowDelimiterType = let (WindowDelimiter.WindowDelimiter(windowDelimiterType=x)) = this in x
  static member FromCs(src:ScriptDom.WindowDelimiter) : WindowDelimiter =
    WindowDelimiter.WindowDelimiter((src.OffsetValue |> Option.ofObj |> Option.map (ScalarExpression.FromCs)), (src.WindowDelimiterType))
and CommonTableExpression = (* IsAbstract = false , children = 0*)
  | CommonTableExpression of columns:(Identifier) list * expressionName:Identifier option * queryExpression:QueryExpression option  
  member this.ToCs() : ScriptDom.CommonTableExpression =
    match this with
    | CommonTableExpression(columns=aColumns; expressionName=aExpressionName; queryExpression=aQueryExpression) ->
      let ret = ScriptDom.CommonTableExpression()
      for e in aColumns do ret.Columns.Add (e.ToCs())
      ret.ExpressionName <- aExpressionName |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret.QueryExpression <- aQueryExpression |> Option.map (fun x -> x.ToCs()) |> Option.toObj
      ret (* 402 *)
//// shared props CommonTableExpression 
  member this.Columns = let (CommonTableExpression.CommonTableExpression(columns=x)) = this in x
  member this.ExpressionName = let (CommonTableExpression.CommonTableExpression(expressionName=x)) = this in x
  member this.QueryExpression = let (CommonTableExpression.CommonTableExpression(queryExpression=x)) = this in x
  static member FromCs(src:ScriptDom.CommonTableExpression) : CommonTableExpression =
    CommonTableExpression.CommonTableExpression((src.Columns |> Seq.map (Identifier.FromCs) |> List.ofSeq), (src.ExpressionName |> Option.ofObj |> Option.map (Identifier.FromCs)), (src.QueryExpression |> Option.ofObj |> Option.map (QueryExpression.FromCs)))
